diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/boolean.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/boolean.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/boolean.out	2024-03-25 11:16:04.663340587 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/boolean.out	2024-04-12 10:23:20.136909022 +0800
@@ -136,11 +136,7 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('junk', 'bool');
-                    message                    | detail | hint | sql_error_code 
------------------------------------------------+--------+------+----------------
- invalid input syntax for type boolean: "junk" |        |      | 22P02
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- and, or, not in qualifications
 SELECT bool 't' or bool 'f' AS true;
  true 
@@ -256,10 +252,7 @@
 SELECT BOOLTBL1.*
    FROM BOOLTBL1
    WHERE booleq(bool 'false', f1);
- f1 
-----
-(0 rows)
-
+ERROR:  function booleq does not exist
 INSERT INTO BOOLTBL1 (f1) VALUES (bool 'f');
 SELECT BOOLTBL1.*
    FROM BOOLTBL1
@@ -279,8 +272,6 @@
 INSERT INTO BOOLTBL2 (f1)
    VALUES (bool 'XXX');
 ERROR:  invalid input syntax for type boolean: "XXX"
-LINE 2:    VALUES (bool 'XXX');
-                        ^
 -- BOOLTBL2 should be full of false's at this point
 SELECT BOOLTBL2.* FROM BOOLTBL2;
  f1 
@@ -294,76 +285,20 @@
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE BOOLTBL2.f1 <> BOOLTBL1.f1;
- f1 | f1 
-----+----
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
-(12 rows)
-
+ERROR:  clapdb doesn't support join currently
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE boolne(BOOLTBL2.f1,BOOLTBL1.f1);
- f1 | f1 
-----+----
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
-(12 rows)
-
+ERROR:  function boolne does not exist
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE BOOLTBL2.f1 = BOOLTBL1.f1 and BOOLTBL1.f1 = bool 'false';
- f1 | f1 
-----+----
- f  | f
- f  | f
- f  | f
- f  | f
-(4 rows)
-
+ERROR:  clapdb doesn't support join currently
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE BOOLTBL2.f1 = BOOLTBL1.f1 or BOOLTBL1.f1 = bool 'true'
    ORDER BY BOOLTBL1.f1, BOOLTBL2.f1;
- f1 | f1 
-----+----
- f  | f
- f  | f
- f  | f
- f  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
-(16 rows)
-
+ERROR:  clapdb doesn't support join currently
 --
 -- SQL syntax
 -- Try all combinations to ensure that we get nothing when we expect nothing
@@ -548,20 +483,20 @@
 
 -- Casts
 SELECT 0::boolean;
- bool 
-------
+ ?column? 
+----------
  f
 (1 row)
 
 SELECT 1::boolean;
- bool 
-------
+ ?column? 
+----------
  t
 (1 row)
 
 SELECT 2::boolean;
- bool 
-------
+ ?column? 
+----------
  t
 (1 row)
 
@@ -572,6 +507,10 @@
 --  - thomas 1997-11-30
 --
 DROP TABLE  BOOLTBL1;
+ERROR:  only support select and create table statement
 DROP TABLE  BOOLTBL2;
+ERROR:  only support select and create table statement
 DROP TABLE  BOOLTBL3;
+ERROR:  only support select and create table statement
 DROP TABLE  BOOLTBL4;
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/int2.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/int2.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/int2.out	2024-03-25 11:16:04.675340599 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/int2.out	2024-04-12 10:23:23.463911297 +0800
@@ -4,21 +4,21 @@
 -- int2_tbl was already created and filled in test_setup.sql.
 -- Here we just try to insert bad values.
 INSERT INTO INT2_TBL(f1) VALUES ('34.5');
-ERROR:  invalid input syntax for type smallint: "34.5"
+ERROR:  invalid input syntax for type integer: "34.5"
 INSERT INTO INT2_TBL(f1) VALUES ('100000');
-ERROR:  value "100000" is out of range for type smallint
+ERROR:  value "100000" is out of range for type integer
 INSERT INTO INT2_TBL(f1) VALUES ('asdf');
-ERROR:  invalid input syntax for type smallint: "asdf"
+ERROR:  invalid input syntax for type integer: "asdf"
 INSERT INTO INT2_TBL(f1) VALUES ('    ');
-ERROR:  invalid input syntax for type smallint: "    "
+ERROR:  invalid input syntax for type integer: "    "
 INSERT INTO INT2_TBL(f1) VALUES ('- 1234');
-ERROR:  invalid input syntax for type smallint: "- 1234"
+ERROR:  invalid input syntax for type integer: "- 1234"
 INSERT INTO INT2_TBL(f1) VALUES ('4 444');
-ERROR:  invalid input syntax for type smallint: "4 444"
+ERROR:  invalid input syntax for type integer: "4 444"
 INSERT INTO INT2_TBL(f1) VALUES ('123 dt');
-ERROR:  invalid input syntax for type smallint: "123 dt"
+ERROR:  invalid input syntax for type integer: "123 dt"
 INSERT INTO INT2_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for type smallint: ""
+ERROR:  invalid input syntax for type integer: ""
 SELECT * FROM INT2_TBL order by 1;
    f1   
 --------
@@ -49,34 +49,38 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('50000', 'int2');
-                     message                     | detail | hint | sql_error_code 
--------------------------------------------------+--------+------+----------------
- value "50000" is out of range for type smallint |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- While we're here, check int2vector as well
 SELECT pg_input_is_valid(' 1 3  5 ', 'int2vector');
  pg_input_is_valid 
 -------------------
- t
+ f
 (1 row)
 
 SELECT * FROM pg_input_error_info('1 asdf', 'int2vector');
-                    message                     | detail | hint | sql_error_code 
-------------------------------------------------+--------+------+----------------
- invalid input syntax for type smallint: "asdf" |        |      | 22P02
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('50000', 'int2vector');
-                     message                     | detail | hint | sql_error_code 
--------------------------------------------------+--------+------+----------------
- value "50000" is out of range for type smallint |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM INT2_TBL AS f(a, b);
-ERROR:  table "f" has 1 columns available but 2 columns specified
+   f1   
+--------
+      0
+   1234
+  -1234
+  32767
+ -32767
+(5 rows)
+
 SELECT * FROM (TABLE int2_tbl) AS s (a, b);
-ERROR:  table "s" has 1 columns available but 2 columns specified
+   f1   
+--------
+      0
+   1234
+  -1234
+  32767
+ -32767
+(5 rows)
+
 SELECT i.* FROM INT2_TBL i WHERE i.f1 <> int2 '0' order by 1;
    f1   
 --------
@@ -184,7 +188,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i order by 1;
-ERROR:  smallint out of range
+   f1   |   x    
+--------+--------
+ -32767 | -65534
+  -1234 |  -2468
+      0 |      0
+   1234 |   2468
+  32767 |  65534
+(5 rows)
+
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i
 WHERE abs(f1) < 16384 order by 1;
   f1   |   x   
@@ -205,7 +217,15 @@
 (5 rows)
 
 SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i order by 1;
-ERROR:  smallint out of range
+   f1   |   x    
+--------+--------
+ -32767 | -32765
+  -1234 |  -1232
+      0 |      2
+   1234 |   1236
+  32767 |  32769
+(5 rows)
+
 SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i
 WHERE f1 < 32766 order by 1;
    f1   |   x    
@@ -227,7 +247,15 @@
 (5 rows)
 
 SELECT i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i order by 1;
-ERROR:  smallint out of range
+   f1   |   x    
+--------+--------
+ -32767 | -32769
+  -1234 |  -1236
+      0 |     -2
+   1234 |   1232
+  32767 |  32765
+(5 rows)
+
 SELECT i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i
 WHERE f1 > -32767 order by 1;
   f1   |   x   
@@ -270,22 +298,22 @@
 
 -- corner cases
 SELECT (-1::int2<<15)::text;
-  text  
---------
- -32768
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 SELECT ((-1::int2<<15)+1::int2)::text;
-  text  
---------
- -32767
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- check sane handling of INT16_MIN overflow cases
 SELECT (-32768)::int2 * (-1)::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+    32768
+(1 row)
+
 SELECT (-32768)::int2 / (-1)::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+    32768
+(1 row)
+
 SELECT (-32768)::int2 % (-1)::int2;
  ?column? 
 ----------
@@ -301,17 +329,7 @@
              (0.5::float8),
              (1.5::float8),
              (2.5::float8)) t(x);
-  x   | int2_value 
-------+------------
- -2.5 |         -2
- -1.5 |         -2
- -0.5 |          0
-    0 |          0
-  0.5 |          0
-  1.5 |          2
-  2.5 |          2
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- check rounding when casting from numeric
 SELECT x, x::int2 AS int2_value
 FROM (VALUES (-2.5::numeric),
@@ -321,126 +339,96 @@
              (0.5::numeric),
              (1.5::numeric),
              (2.5::numeric)) t(x);
-  x   | int2_value 
-------+------------
- -2.5 |         -3
- -1.5 |         -2
- -0.5 |         -1
-  0.0 |          0
-  0.5 |          1
-  1.5 |          2
-  2.5 |          3
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- non-decimal literals
 SELECT int2 '0b100101';
- int2 
-------
-   37
+ ?column? 
+----------
+       37
 (1 row)
 
 SELECT int2 '0o273';
- int2 
-------
-  187
+ ?column? 
+----------
+      187
 (1 row)
 
 SELECT int2 '0x42F';
- int2 
-------
- 1071
+ ?column? 
+----------
+     1071
 (1 row)
 
 SELECT int2 '0b';
-ERROR:  invalid input syntax for type smallint: "0b"
+ERROR:  invalid input syntax for type integer: "0b"
 SELECT int2 '0o';
-ERROR:  invalid input syntax for type smallint: "0o"
+ERROR:  invalid input syntax for type integer: "0o"
 SELECT int2 '0x';
-ERROR:  invalid input syntax for type smallint: "0x"
+ERROR:  invalid input syntax for type integer: "0x"
 -- cases near overflow
 SELECT int2 '0b111111111111111';
- int2  
--------
- 32767
+ ?column? 
+----------
+    32767
 (1 row)
 
 SELECT int2 '0b1000000000000000';
-ERROR:  value "0b1000000000000000" is out of range for type smallint
+ERROR:  value "0b1000000000000000" is out of range for type integer
 SELECT int2 '0o77777';
- int2  
--------
- 32767
+ ?column? 
+----------
+    32767
 (1 row)
 
 SELECT int2 '0o100000';
-ERROR:  value "0o100000" is out of range for type smallint
+ERROR:  value "0o100000" is out of range for type integer
 SELECT int2 '0x7FFF';
- int2  
--------
- 32767
+ ?column? 
+----------
+    32767
 (1 row)
 
 SELECT int2 '0x8000';
-ERROR:  value "0x8000" is out of range for type smallint
+ERROR:  value "0x8000" is out of range for type integer
 SELECT int2 '-0b1000000000000000';
-  int2  
---------
- -32768
+ ?column? 
+----------
+   -32768
 (1 row)
 
 SELECT int2 '-0b1000000000000001';
-ERROR:  value "-0b1000000000000001" is out of range for type smallint
+ERROR:  invalid input syntax for type integer: "-0b1000000000000001"
 SELECT int2 '-0o100000';
-  int2  
---------
- -32768
+ ?column? 
+----------
+   -32768
 (1 row)
 
 SELECT int2 '-0o100001';
-ERROR:  value "-0o100001" is out of range for type smallint
+ERROR:  invalid input syntax for type integer: "-0o100001"
 SELECT int2 '-0x8000';
-  int2  
---------
- -32768
+ ?column? 
+----------
+   -32768
 (1 row)
 
 SELECT int2 '-0x8001';
-ERROR:  value "-0x8001" is out of range for type smallint
+ERROR:  invalid input syntax for type integer: "-0x8001"
 -- underscores
 SELECT int2 '1_000';
- int2 
-------
- 1000
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_000"
 SELECT int2 '1_2_3';
- int2 
-------
-  123
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_2_3"
 SELECT int2 '0xE_FF';
- int2 
-------
- 3839
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0xE_FF"
 SELECT int2 '0o2_73';
- int2 
-------
-  187
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0o2_73"
 SELECT int2 '0b_10_0101';
- int2 
-------
-   37
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0b_10_0101"
 -- error cases
 SELECT int2 '_100';
-ERROR:  invalid input syntax for type smallint: "_100"
+ERROR:  invalid input syntax for type integer: "_100"
 SELECT int2 '100_';
-ERROR:  invalid input syntax for type smallint: "100_"
+ERROR:  invalid input syntax for type integer: "100_"
 SELECT int2 '10__000';
-ERROR:  invalid input syntax for type smallint: "10__000"
+ERROR:  invalid input syntax for type integer: "10__000"
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/int4.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/int4.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/int4.out	2024-03-25 11:16:04.675340599 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/int4.out	2024-04-12 10:23:27.019913730 +0800
@@ -49,11 +49,7 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('1000000000000', 'int4');
-                        message                         | detail | hint | sql_error_code 
---------------------------------------------------------+--------+------+----------------
- value "1000000000000" is out of range for type integer |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT i.* FROM INT4_TBL i WHERE i.f1 <> int2 '0' order by 1;
      f1      
 -------------
@@ -161,7 +157,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |           0
+      123456 |      246912
+     -123456 |     -246912
+  2147483647 |  4294967294
+ -2147483647 | -4294967294
+(5 rows)
+
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i
 WHERE abs(f1) < 1073741824 order by 1;
    f1    |    x    
@@ -172,7 +176,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |           0
+      123456 |      246912
+     -123456 |     -246912
+  2147483647 |  4294967294
+ -2147483647 | -4294967294
+(5 rows)
+
 SELECT i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i
 WHERE abs(f1) < 1073741824 order by 1;
    f1    |    x    
@@ -183,7 +195,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |           2
+      123456 |      123458
+     -123456 |     -123454
+  2147483647 |  2147483649
+ -2147483647 | -2147483645
+(5 rows)
+
 SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i
 WHERE f1 < 2147483646 order by 1;
      f1      |      x      
@@ -195,7 +215,15 @@
 (4 rows)
 
 SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |           2
+      123456 |      123458
+     -123456 |     -123454
+  2147483647 |  2147483649
+ -2147483647 | -2147483645
+(5 rows)
+
 SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i
 WHERE f1 < 2147483646 order by 1;
      f1      |      x      
@@ -207,7 +235,15 @@
 (4 rows)
 
 SELECT i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |          -2
+      123456 |      123454
+     -123456 |     -123458
+  2147483647 |  2147483645
+ -2147483647 | -2147483649
+(5 rows)
+
 SELECT i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i
 WHERE f1 > -2147483647 order by 1;
      f1     |     x      
@@ -219,7 +255,15 @@
 (4 rows)
 
 SELECT i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |          -2
+      123456 |      123454
+     -123456 |     -123458
+  2147483647 |  2147483645
+ -2147483647 | -2147483649
+(5 rows)
+
 SELECT i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i
 WHERE f1 > -2147483647 order by 1;
      f1     |     x      
@@ -322,22 +366,22 @@
 
 -- corner case
 SELECT (-1::int4<<31)::text;
-    text     
--------------
- -2147483648
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 SELECT ((-1::int4<<31)+1)::text;
-    text     
--------------
- -2147483647
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- check sane handling of INT_MIN overflow cases
 SELECT (-2147483648)::int4 * (-1)::int4;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 / (-1)::int4;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 % (-1)::int4;
  ?column? 
 ----------
@@ -345,9 +389,17 @@
 (1 row)
 
 SELECT (-2147483648)::int4 * (-1)::int2;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 / (-1)::int2;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 % (-1)::int2;
  ?column? 
 ----------
@@ -363,17 +415,7 @@
              (0.5::float8),
              (1.5::float8),
              (2.5::float8)) t(x);
-  x   | int4_value 
-------+------------
- -2.5 |         -2
- -1.5 |         -2
- -0.5 |          0
-    0 |          0
-  0.5 |          0
-  1.5 |          2
-  2.5 |          2
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- check rounding when casting from numeric
 SELECT x, x::int4 AS int4_value
 FROM (VALUES (-2.5::numeric),
@@ -383,17 +425,7 @@
              (0.5::numeric),
              (1.5::numeric),
              (2.5::numeric)) t(x);
-  x   | int4_value 
-------+------------
- -2.5 |         -3
- -1.5 |         -2
- -0.5 |         -1
-  0.0 |          0
-  0.5 |          1
-  1.5 |          2
-  2.5 |          3
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- test gcd()
 SELECT a, b, gcd(a, b), gcd(a, -b), gcd(b, a), gcd(-b, a)
 FROM (VALUES (0::int4, 0::int4),
@@ -403,21 +435,11 @@
              ((-2147483648)::int4, 1::int4),
              ((-2147483648)::int4, 2147483647::int4),
              ((-2147483648)::int4, 1073741824::int4)) AS v(a, b);
-      a      |     b      |    gcd     |    gcd     |    gcd     |    gcd     
--------------+------------+------------+------------+------------+------------
-           0 |          0 |          0 |          0 |          0 |          0
-           0 |    6410818 |    6410818 |    6410818 |    6410818 |    6410818
-    61866666 |    6410818 |       1466 |       1466 |       1466 |       1466
-   -61866666 |    6410818 |       1466 |       1466 |       1466 |       1466
- -2147483648 |          1 |          1 |          1 |          1 |          1
- -2147483648 | 2147483647 |          1 |          1 |          1 |          1
- -2147483648 | 1073741824 | 1073741824 | 1073741824 | 1073741824 | 1073741824
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT gcd((-2147483648)::int4, 0::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function gcd does not exist
 SELECT gcd((-2147483648)::int4, (-2147483648)::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function gcd does not exist
 -- test lcm()
 SELECT a, b, lcm(a, b), lcm(a, -b), lcm(b, a), lcm(-b, a)
 FROM (VALUES (0::int4, 0::int4),
@@ -426,37 +448,28 @@
              (330::int4, 462::int4),
              (-330::int4, 462::int4),
              ((-2147483648)::int4, 0::int4)) AS v(a, b);
-      a      |  b  | lcm  | lcm  | lcm  | lcm  
--------------+-----+------+------+------+------
-           0 |   0 |    0 |    0 |    0 |    0
-           0 |  42 |    0 |    0 |    0 |    0
-          42 |  42 |   42 |   42 |   42 |   42
-         330 | 462 | 2310 | 2310 | 2310 | 2310
-        -330 | 462 | 2310 | 2310 | 2310 | 2310
- -2147483648 |   0 |    0 |    0 |    0 |    0
-(6 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT lcm((-2147483648)::int4, 1::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function lcm does not exist
 SELECT lcm(2147483647::int4, 2147483646::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function lcm does not exist
 -- non-decimal literals
 SELECT int4 '0b100101';
- int4 
-------
-   37
+ ?column? 
+----------
+       37
 (1 row)
 
 SELECT int4 '0o273';
- int4 
-------
-  187
+ ?column? 
+----------
+      187
 (1 row)
 
 SELECT int4 '0x42F';
- int4 
-------
- 1071
+ ?column? 
+----------
+     1071
 (1 row)
 
 SELECT int4 '0b';
@@ -467,7 +480,7 @@
 ERROR:  invalid input syntax for type integer: "0x"
 -- cases near overflow
 SELECT int4 '0b1111111111111111111111111111111';
-    int4    
+  ?column?  
 ------------
  2147483647
 (1 row)
@@ -475,7 +488,7 @@
 SELECT int4 '0b10000000000000000000000000000000';
 ERROR:  value "0b10000000000000000000000000000000" is out of range for type integer
 SELECT int4 '0o17777777777';
-    int4    
+  ?column?  
 ------------
  2147483647
 (1 row)
@@ -483,7 +496,7 @@
 SELECT int4 '0o20000000000';
 ERROR:  value "0o20000000000" is out of range for type integer
 SELECT int4 '0x7FFFFFFF';
-    int4    
+  ?column?  
 ------------
  2147483647
 (1 row)
@@ -491,60 +504,40 @@
 SELECT int4 '0x80000000';
 ERROR:  value "0x80000000" is out of range for type integer
 SELECT int4 '-0b10000000000000000000000000000000';
-    int4     
+  ?column?   
 -------------
  -2147483648
 (1 row)
 
 SELECT int4 '-0b10000000000000000000000000000001';
-ERROR:  value "-0b10000000000000000000000000000001" is out of range for type integer
+ERROR:  invalid input syntax for type integer: "-0b10000000000000000000000000000001"
 SELECT int4 '-0o20000000000';
-    int4     
+  ?column?   
 -------------
  -2147483648
 (1 row)
 
 SELECT int4 '-0o20000000001';
-ERROR:  value "-0o20000000001" is out of range for type integer
+ERROR:  invalid input syntax for type integer: "-0o20000000001"
 SELECT int4 '-0x80000000';
-    int4     
+  ?column?   
 -------------
  -2147483648
 (1 row)
 
 SELECT int4 '-0x80000001';
-ERROR:  value "-0x80000001" is out of range for type integer
+ERROR:  invalid input syntax for type integer: "-0x80000001"
 -- underscores
 SELECT int4 '1_000_000';
-  int4   
----------
- 1000000
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_000_000"
 SELECT int4 '1_2_3';
- int4 
-------
-  123
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_2_3"
 SELECT int4 '0x1EEE_FFFF';
-   int4    
------------
- 518979583
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0x1EEE_FFFF"
 SELECT int4 '0o2_73';
- int4 
-------
-  187
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0o2_73"
 SELECT int4 '0b_10_0101';
- int4 
-------
-   37
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0b_10_0101"
 -- error cases
 SELECT int4 '_100';
 ERROR:  invalid input syntax for type integer: "_100"
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/int8.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/int8.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/int8.out	2024-03-25 11:16:04.676340600 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/int8.out	2024-04-12 10:23:35.990919866 +0800
@@ -5,19 +5,19 @@
 -- int8_tbl was already created and filled in test_setup.sql.
 -- Here we just try to insert bad values.
 INSERT INTO INT8_TBL(q1) VALUES ('      ');
-ERROR:  invalid input syntax for type bigint: "      "
+ERROR:  invalid input syntax for type integer: "      "
 INSERT INTO INT8_TBL(q1) VALUES ('xxx');
-ERROR:  invalid input syntax for type bigint: "xxx"
+ERROR:  invalid input syntax for type integer: "xxx"
 INSERT INTO INT8_TBL(q1) VALUES ('3908203590239580293850293850329485');
-ERROR:  value "3908203590239580293850293850329485" is out of range for type bigint
+ERROR:  value "3908203590239580293850293850329485" is out of range for type integer
 INSERT INTO INT8_TBL(q1) VALUES ('-1204982019841029840928340329840934');
-ERROR:  value "-1204982019841029840928340329840934" is out of range for type bigint
+ERROR:  value "-1204982019841029840928340329840934" is out of range for type integer
 INSERT INTO INT8_TBL(q1) VALUES ('- 123');
-ERROR:  invalid input syntax for type bigint: "- 123"
+ERROR:  invalid input syntax for type integer: "- 123"
 INSERT INTO INT8_TBL(q1) VALUES ('  345     5');
-ERROR:  invalid input syntax for type bigint: "  345     5"
+ERROR:  invalid input syntax for type integer: "  345     5"
 INSERT INTO INT8_TBL(q1) VALUES ('');
-ERROR:  invalid input syntax for type bigint: ""
+ERROR:  invalid input syntax for type integer: ""
 SELECT * FROM INT8_TBL order by 1;
         q1        |        q2         
 ------------------+-------------------
@@ -48,11 +48,7 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('10000000000000000000', 'int8');
-                           message                            | detail | hint | sql_error_code 
---------------------------------------------------------------+--------+------+----------------
- value "10000000000000000000" is out of range for type bigint |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- int8/int8 cmp
 SELECT * FROM INT8_TBL WHERE q2 = 4567890123456789 order by 1;
         q1        |        q2        
@@ -314,7 +310,15 @@
 (5 rows)
 
 SELECT q1, q2, q1 * q2 AS multiply FROM INT8_TBL order by 1;
-ERROR:  bigint out of range
+        q1        |        q2         |       multiply       
+------------------+-------------------+----------------------
+              123 |               456 |                56088
+              123 |  4567890123456789 |   561850485185185047
+ 4567890123456789 |               123 |   561850485185185047
+ 4567890123456789 |  4567890123456789 |  4868582358072306617
+ 4567890123456789 | -4567890123456789 | -4868582358072306617
+(5 rows)
+
 SELECT q1, q2, q1 * q2 AS multiply FROM INT8_TBL
  WHERE q1 < 1000 or (q2 > 0 and q2 < 1000);
         q1        |        q2        |      multiply      
@@ -335,25 +339,9 @@
 (5 rows)
 
 SELECT q1, float8(q1) FROM INT8_TBL order by 1;
-        q1        |        float8         
-------------------+-----------------------
-              123 |                   123
-              123 |                   123
- 4567890123456789 | 4.567890123456789e+15
- 4567890123456789 | 4.567890123456789e+15
- 4567890123456789 | 4.567890123456789e+15
-(5 rows)
-
+ERROR:  function float8 does not exist
 SELECT q2, float8(q2) FROM INT8_TBL order by 1;
-        q2         |         float8         
--------------------+------------------------
- -4567890123456789 | -4.567890123456789e+15
-               123 |                    123
-               456 |                    456
-  4567890123456789 |  4.567890123456789e+15
-  4567890123456789 |  4.567890123456789e+15
-(5 rows)
-
+ERROR:  function float8 does not exist
 SELECT 37 + q1 AS plus4 FROM INT8_TBL order by 1;
       plus4       
 ------------------
@@ -464,195 +452,59 @@
 --
 SELECT to_char(q1, '9G999G999G999G999G999'), to_char(q2, '9,999,999,999,999,999')
 	FROM INT8_TBL order by 1;
-        to_char         |        to_char         
-------------------------+------------------------
-                    123 |                    456
-                    123 |  4,567,890,123,456,789
-  4,567,890,123,456,789 |                    123
-  4,567,890,123,456,789 |  4,567,890,123,456,789
-  4,567,890,123,456,789 | -4,567,890,123,456,789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q1, '9G999G999G999G999G999D999G999'), to_char(q2, '9,999,999,999,999,999.999,999')
 	FROM INT8_TBL order by 1;
-            to_char             |            to_char             
---------------------------------+--------------------------------
-                    123.000,000 |                    456.000,000
-                    123.000,000 |  4,567,890,123,456,789.000,000
-  4,567,890,123,456,789.000,000 |                    123.000,000
-  4,567,890,123,456,789.000,000 |  4,567,890,123,456,789.000,000
-  4,567,890,123,456,789.000,000 | -4,567,890,123,456,789.000,000
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char( (q1 * -1), '9999999999999999PR'), to_char( (q2 * -1), '9999999999999999.999PR')
 	FROM INT8_TBL order by 1;
-      to_char       |        to_char         
---------------------+------------------------
-              <123> |              <456.000>
-              <123> | <4567890123456789.000>
- <4567890123456789> |              <123.000>
- <4567890123456789> | <4567890123456789.000>
- <4567890123456789> |  4567890123456789.000 
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char( (q1 * -1), '9999999999999999S'), to_char( (q2 * -1), 'S9999999999999999')
 	FROM INT8_TBL order by 1;
-      to_char      |      to_char      
--------------------+-------------------
-              123- |              -456
-              123- | -4567890123456789
- 4567890123456789- |              -123
- 4567890123456789- | -4567890123456789
- 4567890123456789- | +4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'MI9999999999999999')     FROM INT8_TBL order by 1;
-      to_char      
--------------------
-               123
-               456
-  4567890123456789
-  4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FMS9999999999999999')    FROM INT8_TBL order by 1;
-      to_char      
--------------------
- +123
- +456
- +4567890123456789
- +4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM9999999999999999THPR') FROM INT8_TBL order by 1;
-      to_char       
---------------------
- 123RD
- <4567890123456789>
- 4567890123456789TH
- 4567890123456789TH
- 456TH
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'SG9999999999999999th')   FROM INT8_TBL order by 1;
-       to_char       
----------------------
- +             123rd
- -4567890123456789
- +4567890123456789th
- +4567890123456789th
- +             456th
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, '0999999999999999')       FROM INT8_TBL order by 1;
-      to_char      
--------------------
-  0000000000000123
-  0000000000000456
-  4567890123456789
-  4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'S0999999999999999')      FROM INT8_TBL order by 1;
-      to_char      
--------------------
- +0000000000000123
- +0000000000000456
- +4567890123456789
- +4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM0999999999999999')     FROM INT8_TBL order by 1;
-      to_char      
--------------------
- 0000000000000123
- 0000000000000456
- -4567890123456789
- 4567890123456789
- 4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM9999999999999999.000') FROM INT8_TBL order by 1;
-        to_char        
------------------------
- 123.000
- 456.000
- -4567890123456789.000
- 4567890123456789.000
- 4567890123456789.000
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'L9999999999999999.000')  FROM INT8_TBL order by 1;
-        to_char         
-------------------------
-                123.000
-                456.000
-   4567890123456789.000
-   4567890123456789.000
-  -4567890123456789.000
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM9999999999999999.999') FROM INT8_TBL order by 1;
-      to_char       
---------------------
- 123.
- 456.
- -4567890123456789.
- 4567890123456789.
- 4567890123456789.
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'S 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 . 9 9 9') FROM INT8_TBL order by 1;
-                  to_char                  
--------------------------------------------
-                            +1 2 3 . 0 0 0
-                            +4 5 6 . 0 0 0
-  +4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 . 0 0 0
-  +4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 . 0 0 0
-  -4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 . 0 0 0
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, E'99999 "text" 9999 "9999" 999 "\\"text between quote marks\\"" 9999') FROM INT8_TBL order by 1;
-                          to_char                          
------------------------------------------------------------
-  45678 text 9012 9999 345 "text between quote marks" 6789
-  45678 text 9012 9999 345 "text between quote marks" 6789
- -45678 text 9012 9999 345 "text between quote marks" 6789
-       text      9999     "text between quote marks"   123
-       text      9999     "text between quote marks"   456
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, '999999SG9999999999')     FROM INT8_TBL order by 1;
-      to_char      
--------------------
-       +       123
-       +       456
- 456789+0123456789
- 456789+0123456789
- 456789-0123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 -- check min/max values and overflow behavior
 select '-9223372036854775808'::int8;
-         int8         
+       ?column?       
 ----------------------
  -9223372036854775808
 (1 row)
 
 select '-9223372036854775809'::int8;
-ERROR:  value "-9223372036854775809" is out of range for type bigint
+ERROR:  value "-9223372036854775809" is out of range for type integer
 select '9223372036854775807'::int8;
-        int8         
+      ?column?       
 ---------------------
  9223372036854775807
 (1 row)
 
 select '9223372036854775808'::int8;
-ERROR:  value "9223372036854775808" is out of range for type bigint
+ERROR:  value "9223372036854775808" is out of range for type integer
 select -('-9223372036854775807'::int8);
       ?column?       
 ---------------------
@@ -660,53 +512,129 @@
 (1 row)
 
 select -('-9223372036854775808'::int8);
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 select 0::int8 - '-9223372036854775808'::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 select '9223372036854775800'::int8 + '9223372036854775800'::int8;
-ERROR:  bigint out of range
+       ?column?       
+----------------------
+ 18446744073709551600
+(1 row)
+
 select '-9223372036854775800'::int8 + '-9223372036854775800'::int8;
-ERROR:  bigint out of range
+ ?column? 
+----------
+       16
+(1 row)
+
 select '9223372036854775800'::int8 - '-9223372036854775800'::int8;
-ERROR:  bigint out of range
+       ?column?       
+----------------------
+ 18446744073709551600
+(1 row)
+
 select '-9223372036854775800'::int8 - '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ ?column? 
+----------
+       16
+(1 row)
+
 select '9223372036854775800'::int8 * '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ ?column? 
+----------
+       64
+(1 row)
+
 select '9223372036854775800'::int8 / '0'::int8;
-ERROR:  division by zero
+ERROR:  div zero [func=func_14055022988487885011]
 select '9223372036854775800'::int8 % '0'::int8;
-ERROR:  division by zero
+ERROR:  div zero [func=func_7877234179416231410]
 select abs('-9223372036854775808'::int8);
-ERROR:  bigint out of range
+ERROR:  out of range
 select '9223372036854775800'::int8 + '100'::int4;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775900
+(1 row)
+
 select '-9223372036854775800'::int8 - '100'::int4;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775716
+(1 row)
+
 select '9223372036854775800'::int8 * '100'::int4;
-ERROR:  bigint out of range
+ ?column? 
+----------
+     -800
+(1 row)
+
 select '100'::int4 + '9223372036854775800'::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775900
+(1 row)
+
 select '-100'::int4 - '9223372036854775800'::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775716
+(1 row)
+
 select '100'::int4 * '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ ?column? 
+----------
+     -800
+(1 row)
+
 select '9223372036854775800'::int8 + '100'::int2;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775900
+(1 row)
+
 select '-9223372036854775800'::int8 - '100'::int2;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775716
+(1 row)
+
 select '9223372036854775800'::int8 * '100'::int2;
-ERROR:  bigint out of range
+ ?column? 
+----------
+     -800
+(1 row)
+
 select '-9223372036854775808'::int8 / '0'::int2;
-ERROR:  division by zero
+ERROR:  div zero [func=func_14055022988487885011]
 select '100'::int2 + '9223372036854775800'::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775900
+(1 row)
+
 select '-100'::int2 - '9223372036854775800'::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775716
+(1 row)
+
 select '100'::int2 * '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ ?column? 
+----------
+     -800
+(1 row)
+
 select '100'::int2 / '0'::int8;
-ERROR:  division by zero
+ERROR:  div zero [func=func_9060753810053611181]
 SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 = 456;
  q1  
 -----
@@ -714,7 +642,14 @@
 (1 row)
 
 SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 <> 456;
-ERROR:  integer out of range
+     q1     
+------------
+        123
+ -869367531
+ -869367531
+ -869367531
+(4 rows)
+
 SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 = 456;
  q1  
 -----
@@ -722,108 +657,72 @@
 (1 row)
 
 SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456;
-ERROR:  smallint out of range
+   q1   
+--------
+    123
+ -32491
+ -32491
+ -32491
+(4 rows)
+
 SELECT CAST('42'::int2 AS int8), CAST('-37'::int2 AS int8);
- int8 | int8 
-------+------
-   42 |  -37
+ ?column? | ?column? 
+----------+----------
+       42 |      -37
 (1 row)
 
 SELECT CAST(q1 AS float4), CAST(q2 AS float8) FROM INT8_TBL order by 1;
-     q1      |           q2           
--------------+------------------------
-         123 |                    456
-         123 |  4.567890123456789e+15
- 4.56789e+15 |                    123
- 4.56789e+15 |  4.567890123456789e+15
- 4.56789e+15 | -4.567890123456789e+15
+        q1        |        q2         
+------------------+-------------------
+              123 |               456
+              123 |  4567890123456789
+ 4567890000000000 |               123
+ 4567890000000000 |  4567890123456789
+ 4567890000000000 | -4567890123456789
 (5 rows)
 
 SELECT CAST('36854775807.0'::float4 AS int8);
-    int8     
+  ?column?   
 -------------
  36854775808
 (1 row)
 
 SELECT CAST('922337203685477580700.0'::float8 AS int8);
-ERROR:  bigint out of range
+ERROR:  long out of range
 SELECT CAST(q1 AS oid) FROM INT8_TBL order by 1;
-ERROR:  OID out of range
+ERROR:  not implemented type_cast case [to=oid]
 SELECT oid::int8 FROM pg_class WHERE relname = 'pg_class';
- oid  
-------
- 1259
-(1 row)
-
+ERROR:  relation "public.pg_class" does not exist
 -- bit operations
 SELECT q1, q2, q1 & q2 AS "and", q1 | q2 AS "or", q1 # q2 AS "xor", ~q1 AS "not" FROM INT8_TBL order by 1;
-        q1        |        q2         |       and        |        or        |       xor        |        not        
-------------------+-------------------+------------------+------------------+------------------+-------------------
-              123 |               456 |               72 |              507 |              435 |              -124
-              123 |  4567890123456789 |               17 | 4567890123456895 | 4567890123456878 |              -124
- 4567890123456789 |               123 |               17 | 4567890123456895 | 4567890123456878 | -4567890123456790
- 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |                0 | -4567890123456790
- 4567890123456789 | -4567890123456789 |                1 |               -1 |               -2 | -4567890123456790
-(5 rows)
-
+ERROR:  binary_optr only support binary optr = [optr_str=&]
 SELECT q1, q1 << 2 AS "shl", q1 >> 3 AS "shr" FROM INT8_TBL order by 1;
-        q1        |        shl        |       shr       
-------------------+-------------------+-----------------
-              123 |               492 |              15
-              123 |               492 |              15
- 4567890123456789 | 18271560493827156 | 570986265432098
- 4567890123456789 | 18271560493827156 | 570986265432098
- 4567890123456789 | 18271560493827156 | 570986265432098
-(5 rows)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- generate_series
 SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8);
- generate_series  
-------------------
- 4567890123456789
- 4567890123456790
- 4567890123456791
- 4567890123456792
- 4567890123456793
- 4567890123456794
- 4567890123456795
- 4567890123456796
- 4567890123456797
- 4567890123456798
- 4567890123456799
-(11 rows)
-
+ERROR:  function generate_series does not exist
 SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8, 0);
-ERROR:  step size cannot equal zero
+ERROR:  function generate_series does not exist
 SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8, 2);
- generate_series  
-------------------
- 4567890123456789
- 4567890123456791
- 4567890123456793
- 4567890123456795
- 4567890123456797
- 4567890123456799
-(6 rows)
-
+ERROR:  function generate_series does not exist
 -- corner case
 SELECT (-1::int8<<63)::text;
-         text         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 SELECT ((-1::int8<<63)+1)::text;
-         text         
-----------------------
- -9223372036854775807
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- check sane handling of INT64_MIN overflow cases
 SELECT (-9223372036854775808)::int8 * (-1)::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 SELECT (-9223372036854775808)::int8 / (-1)::int8;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 SELECT (-9223372036854775808)::int8 % (-1)::int8;
  ?column? 
 ----------
@@ -831,9 +730,17 @@
 (1 row)
 
 SELECT (-9223372036854775808)::int8 * (-1)::int4;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 SELECT (-9223372036854775808)::int8 / (-1)::int4;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 SELECT (-9223372036854775808)::int8 % (-1)::int4;
  ?column? 
 ----------
@@ -841,9 +748,17 @@
 (1 row)
 
 SELECT (-9223372036854775808)::int8 * (-1)::int2;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 SELECT (-9223372036854775808)::int8 / (-1)::int2;
-ERROR:  bigint out of range
+      ?column?       
+---------------------
+ 9223372036854775808
+(1 row)
+
 SELECT (-9223372036854775808)::int8 % (-1)::int2;
  ?column? 
 ----------
@@ -859,17 +774,7 @@
              (0.5::float8),
              (1.5::float8),
              (2.5::float8)) t(x);
-  x   | int8_value 
-------+------------
- -2.5 |         -2
- -1.5 |         -2
- -0.5 |          0
-    0 |          0
-  0.5 |          0
-  1.5 |          2
-  2.5 |          2
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- check rounding when casting from numeric
 SELECT x, x::int8 AS int8_value
 FROM (VALUES (-2.5::numeric),
@@ -879,17 +784,7 @@
              (0.5::numeric),
              (1.5::numeric),
              (2.5::numeric)) t(x);
-  x   | int8_value 
-------+------------
- -2.5 |         -3
- -1.5 |         -2
- -0.5 |         -1
-  0.0 |          0
-  0.5 |          1
-  1.5 |          2
-  2.5 |          3
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- test gcd()
 SELECT a, b, gcd(a, b), gcd(a, -b), gcd(b, a), gcd(-b, a)
 FROM (VALUES (0::int8, 0::int8),
@@ -899,21 +794,11 @@
              ((-9223372036854775808)::int8, 1::int8),
              ((-9223372036854775808)::int8, 9223372036854775807::int8),
              ((-9223372036854775808)::int8, 4611686018427387904::int8)) AS v(a, b);
-          a           |          b          |         gcd         |         gcd         |         gcd         |         gcd         
-----------------------+---------------------+---------------------+---------------------+---------------------+---------------------
-                    0 |                   0 |                   0 |                   0 |                   0 |                   0
-                    0 |         29893644334 |         29893644334 |         29893644334 |         29893644334 |         29893644334
-         288484263558 |         29893644334 |             6835958 |             6835958 |             6835958 |             6835958
-        -288484263558 |         29893644334 |             6835958 |             6835958 |             6835958 |             6835958
- -9223372036854775808 |                   1 |                   1 |                   1 |                   1 |                   1
- -9223372036854775808 | 9223372036854775807 |                   1 |                   1 |                   1 |                   1
- -9223372036854775808 | 4611686018427387904 | 4611686018427387904 | 4611686018427387904 | 4611686018427387904 | 4611686018427387904
-(7 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT gcd((-9223372036854775808)::int8, 0::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function gcd does not exist
 SELECT gcd((-9223372036854775808)::int8, (-9223372036854775808)::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function gcd does not exist
 -- test lcm()
 SELECT a, b, lcm(a, b), lcm(a, -b), lcm(b, a), lcm(-b, a)
 FROM (VALUES (0::int8, 0::int8),
@@ -922,129 +807,100 @@
              (288484263558::int8, 29893644334::int8),
              (-288484263558::int8, 29893644334::int8),
              ((-9223372036854775808)::int8, 0::int8)) AS v(a, b);
-          a           |      b      |       lcm        |       lcm        |       lcm        |       lcm        
-----------------------+-------------+------------------+------------------+------------------+------------------
-                    0 |           0 |                0 |                0 |                0 |                0
-                    0 | 29893644334 |                0 |                0 |                0 |                0
-          29893644334 | 29893644334 |      29893644334 |      29893644334 |      29893644334 |      29893644334
-         288484263558 | 29893644334 | 1261541684539134 | 1261541684539134 | 1261541684539134 | 1261541684539134
-        -288484263558 | 29893644334 | 1261541684539134 | 1261541684539134 | 1261541684539134 | 1261541684539134
- -9223372036854775808 |           0 |                0 |                0 |                0 |                0
-(6 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT lcm((-9223372036854775808)::int8, 1::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function lcm does not exist
 SELECT lcm(9223372036854775807::int8, 9223372036854775806::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function lcm does not exist
 -- non-decimal literals
 SELECT int8 '0b100101';
- int8 
-------
-   37
+ ?column? 
+----------
+       37
 (1 row)
 
 SELECT int8 '0o273';
- int8 
-------
-  187
+ ?column? 
+----------
+      187
 (1 row)
 
 SELECT int8 '0x42F';
- int8 
-------
- 1071
+ ?column? 
+----------
+     1071
 (1 row)
 
 SELECT int8 '0b';
-ERROR:  invalid input syntax for type bigint: "0b"
+ERROR:  invalid input syntax for type integer: "0b"
 SELECT int8 '0o';
-ERROR:  invalid input syntax for type bigint: "0o"
+ERROR:  invalid input syntax for type integer: "0o"
 SELECT int8 '0x';
-ERROR:  invalid input syntax for type bigint: "0x"
+ERROR:  invalid input syntax for type integer: "0x"
 -- cases near overflow
 SELECT int8 '0b111111111111111111111111111111111111111111111111111111111111111';
-        int8         
+      ?column?       
 ---------------------
  9223372036854775807
 (1 row)
 
 SELECT int8 '0b1000000000000000000000000000000000000000000000000000000000000000';
-ERROR:  value "0b1000000000000000000000000000000000000000000000000000000000000000" is out of range for type bigint
+ERROR:  value "0b1000000000000000000000000000000000000000000000000000000000000000" is out of range for type integer
 SELECT int8 '0o777777777777777777777';
-        int8         
+      ?column?       
 ---------------------
  9223372036854775807
 (1 row)
 
 SELECT int8 '0o1000000000000000000000';
-ERROR:  value "0o1000000000000000000000" is out of range for type bigint
+ERROR:  value "0o1000000000000000000000" is out of range for type integer
 SELECT int8 '0x7FFFFFFFFFFFFFFF';
-        int8         
+      ?column?       
 ---------------------
  9223372036854775807
 (1 row)
 
 SELECT int8 '0x8000000000000000';
-ERROR:  value "0x8000000000000000" is out of range for type bigint
+ERROR:  value "0x8000000000000000" is out of range for type integer
 SELECT int8 '-0b1000000000000000000000000000000000000000000000000000000000000000';
-         int8         
+       ?column?       
 ----------------------
  -9223372036854775808
 (1 row)
 
 SELECT int8 '-0b1000000000000000000000000000000000000000000000000000000000000001';
-ERROR:  value "-0b1000000000000000000000000000000000000000000000000000000000000001" is out of range for type bigint
+ERROR:  invalid input syntax for type integer: "-0b1000000000000000000000000000000000000000000000000000000000000001"
 SELECT int8 '-0o1000000000000000000000';
-         int8         
+       ?column?       
 ----------------------
  -9223372036854775808
 (1 row)
 
 SELECT int8 '-0o1000000000000000000001';
-ERROR:  value "-0o1000000000000000000001" is out of range for type bigint
+ERROR:  invalid input syntax for type integer: "-0o1000000000000000000001"
 SELECT int8 '-0x8000000000000000';
-         int8         
+       ?column?       
 ----------------------
  -9223372036854775808
 (1 row)
 
 SELECT int8 '-0x8000000000000001';
-ERROR:  value "-0x8000000000000001" is out of range for type bigint
+ERROR:  invalid input syntax for type integer: "-0x8000000000000001"
 -- underscores
 SELECT int8 '1_000_000';
-  int8   
----------
- 1000000
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_000_000"
 SELECT int8 '1_2_3';
- int8 
-------
-  123
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_2_3"
 SELECT int8 '0x1EEE_FFFF';
-   int8    
------------
- 518979583
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0x1EEE_FFFF"
 SELECT int8 '0o2_73';
- int8 
-------
-  187
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0o2_73"
 SELECT int8 '0b_10_0101';
- int8 
-------
-   37
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0b_10_0101"
 -- error cases
 SELECT int8 '_100';
-ERROR:  invalid input syntax for type bigint: "_100"
+ERROR:  invalid input syntax for type integer: "_100"
 SELECT int8 '100_';
-ERROR:  invalid input syntax for type bigint: "100_"
+ERROR:  invalid input syntax for type integer: "100_"
 SELECT int8 '100__000';
-ERROR:  invalid input syntax for type bigint: "100__000"
+ERROR:  invalid input syntax for type integer: "100__000"
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/float4.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/float4.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/float4.out	2024-03-25 11:16:04.670340594 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/float4.out	2024-04-12 10:23:42.798924522 +0800
@@ -9,44 +9,44 @@
 INSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e-20');
 -- test for over and under flow
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');
-ERROR:  "10e70" is out of range for type real
+ERROR:  value "10e70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');
-ERROR:  "-10e70" is out of range for type real
+ERROR:  value "-10e70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');
-ERROR:  "10e-70" is out of range for type real
+ERROR:  value "10e-70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');
-ERROR:  "-10e-70" is out of range for type real
+ERROR:  value "-10e-70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70'::float8);
-ERROR:  value out of range: overflow
+ERROR:  value out of range
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70'::float8);
-ERROR:  value out of range: overflow
+ERROR:  value out of range
 --INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70'::float8);
 --INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70'::float8);
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e400');
-ERROR:  "10e400" is out of range for type real
+ERROR:  value "10e400" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e400');
-ERROR:  "-10e400" is out of range for type real
+ERROR:  value "-10e400" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-400');
-ERROR:  "10e-400" is out of range for type real
+ERROR:  value "10e-400" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-400');
-ERROR:  "-10e-400" is out of range for type real
+ERROR:  value "-10e-400" is out of range for type floating
 -- bad input
 INSERT INTO FLOAT4_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for type real: ""
+ERROR:  invalid input syntax for type floating: ""
 INSERT INTO FLOAT4_TBL(f1) VALUES ('       ');
-ERROR:  invalid input syntax for type real: "       "
+ERROR:  invalid input syntax for type floating: "       "
 INSERT INTO FLOAT4_TBL(f1) VALUES ('xyz');
-ERROR:  invalid input syntax for type real: "xyz"
+ERROR:  invalid input syntax for type floating: "xyz"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('5.0.0');
-ERROR:  invalid input syntax for type real: "5.0.0"
+ERROR:  invalid input syntax for type floating: "5.0.0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('5 . 0');
-ERROR:  invalid input syntax for type real: "5 . 0"
+ERROR:  invalid input syntax for type floating: "5 . 0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('5.   0');
-ERROR:  invalid input syntax for type real: "5.   0"
+ERROR:  invalid input syntax for type floating: "5.   0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('     - 3.0');
-ERROR:  invalid input syntax for type real: "     - 3.0"
+ERROR:  invalid input syntax for type floating: "- 3.0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('123            5');
-ERROR:  invalid input syntax for type real: "123            5"
+ERROR:  invalid input syntax for type floating: "123            5"
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34.5', 'float4');
  pg_input_is_valid 
@@ -67,59 +67,55 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('1e400', 'float4');
-                message                | detail | hint | sql_error_code 
----------------------------------------+--------+------+----------------
- "1e400" is out of range for type real |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- special inputs
 SELECT 'NaN'::float4;
- float4 
---------
-    NaN
+ ?column? 
+----------
+      nan
 (1 row)
 
 SELECT 'nan'::float4;
- float4 
---------
-    NaN
+ ?column? 
+----------
+      nan
 (1 row)
 
 SELECT '   NAN  '::float4;
- float4 
---------
-    NaN
+ ?column? 
+----------
+      nan
 (1 row)
 
 SELECT 'infinity'::float4;
-  float4  
+ ?column? 
 ----------
- Infinity
+      inf
 (1 row)
 
 SELECT '          -INFINiTY   '::float4;
-  float4   
------------
- -Infinity
+ ?column? 
+----------
+     -inf
 (1 row)
 
 -- bad special inputs
 SELECT 'N A N'::float4;
-ERROR:  invalid input syntax for type real: "N A N"
+ERROR:  invalid input syntax for type floating: "N A N"
 SELECT 'NaN x'::float4;
-ERROR:  invalid input syntax for type real: "NaN x"
+ERROR:  invalid input syntax for type floating: "NaN x"
 SELECT ' INFINITY    x'::float4;
-ERROR:  invalid input syntax for type real: " INFINITY    x"
+ERROR:  invalid input syntax for type floating: "INFINITY    x"
 SELECT 'Infinity'::float4 + 100.0;
  ?column? 
 ----------
- Infinity
+      inf
 (1 row)
 
 SELECT 'Infinity'::float4 / 'Infinity'::float4;
  ?column? 
 ----------
-      NaN
+     -nan
 (1 row)
 
 SELECT '42'::float4 / 'Infinity'::float4;
@@ -131,21 +127,17 @@
 SELECT 'nan'::float4 / 'nan'::float4;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::float4 / '0'::float4;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::numeric::float4;
- float4 
---------
-    NaN
-(1 row)
-
+ERROR:  not implemented type_cast case [to=numeric]
 SELECT * FROM FLOAT4_TBL order by 1;
       f1       
 ---------------
@@ -243,7 +235,7 @@
 
 -- test divide by zero
 SELECT f.f1 / '0.0' from FLOAT4_TBL f order by 1;
-ERROR:  division by zero
+ERROR:  div zero [func=func_14154944641562171856]
 SELECT * FROM FLOAT4_TBL order by 1;
       f1       
 ---------------
@@ -256,170 +248,103 @@
 
 -- test the unary float4abs operator
 SELECT f.f1, @f.f1 AS abs_f1 FROM FLOAT4_TBL f order by 1;
-      f1       |    abs_f1     
----------------+---------------
-        -34.84 |         34.84
-             0 |             0
- 1.2345679e-20 | 1.2345679e-20
-        1004.3 |        1004.3
- 1.2345679e+20 | 1.2345679e+20
-(5 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=@]
 UPDATE FLOAT4_TBL
    SET f1 = FLOAT4_TBL.f1 * '-1'
    WHERE FLOAT4_TBL.f1 > '0.0';
+ERROR:  only support select and create table statement
 SELECT * FROM FLOAT4_TBL order by 1;
-       f1       
-----------------
- -1.2345679e+20
-        -1004.3
-         -34.84
- -1.2345679e-20
-              0
+      f1       
+---------------
+        -34.84
+             0
+ 1.2345679e-20
+        1004.3
+ 1.2345679e+20
 (5 rows)
 
 -- test edge-case coercions to integer
 SELECT '32767.4'::float4::int2;
- int2  
--------
- 32767
+ ?column? 
+----------
+    32767
 (1 row)
 
 SELECT '32767.6'::float4::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+    32767
+(1 row)
+
 SELECT '-32768.4'::float4::int2;
-  int2  
---------
- -32768
+ ?column? 
+----------
+   -32768
 (1 row)
 
 SELECT '-32768.6'::float4::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+   -32768
+(1 row)
+
 SELECT '2147483520'::float4::int4;
-    int4    
+  ?column?  
 ------------
  2147483520
 (1 row)
 
 SELECT '2147483647'::float4::int4;
-ERROR:  integer out of range
+ERROR:  int out of range
 SELECT '-2147483648.5'::float4::int4;
-    int4     
--------------
- -2147483648
-(1 row)
-
+ERROR:  int out of range
 SELECT '-2147483900'::float4::int4;
-ERROR:  integer out of range
+ERROR:  int out of range
 SELECT '9223369837831520256'::float4::int8;
-        int8         
+      ?column?       
 ---------------------
  9223369837831520256
 (1 row)
 
 SELECT '9223372036854775807'::float4::int8;
-ERROR:  bigint out of range
+ERROR:  long out of range
 SELECT '-9223372036854775808.5'::float4::int8;
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  long out of range
 SELECT '-9223380000000000000'::float4::int8;
-ERROR:  bigint out of range
+ERROR:  long out of range
 -- Test for correct input rounding in edge cases.
 -- These lists are from Paxson 1991, excluding subnormals and
 -- inputs of over 9 sig. digits.
 SELECT float4send('5e-20'::float4);
- float4send 
-------------
- \x1f6c1e4a
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('67e14'::float4);
- float4send 
-------------
- \x59be6cea
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('985e15'::float4);
- float4send 
-------------
- \x5d5ab6c4
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('55895e-16'::float4);
- float4send 
-------------
- \x2cc4a9bd
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('7038531e-32'::float4);
- float4send 
-------------
- \x15ae43fd
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('702990899e-20'::float4);
- float4send 
-------------
- \x2cf757ca
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('3e-23'::float4);
- float4send 
-------------
- \x1a111234
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('57e18'::float4);
- float4send 
-------------
- \x6045c22c
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('789e-35'::float4);
- float4send 
-------------
- \x0a23de70
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('2539e-18'::float4);
- float4send 
-------------
- \x2736f449
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('76173e28'::float4);
- float4send 
-------------
- \x7616398a
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('887745e-11'::float4);
- float4send 
-------------
- \x3714f05c
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('5382571e-37'::float4);
- float4send 
-------------
- \x0d2eaca7
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('82381273e-35'::float4);
- float4send 
-------------
- \x128289d1
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('750486563e-38'::float4);
- float4send 
-------------
- \x0f18377e
-(1 row)
-
+ERROR:  function float4send does not exist
 -- Test that the smallest possible normalized input value inputs
 -- correctly, either in 9-significant-digit or shortest-decimal
 -- format.
@@ -428,33 +353,31 @@
 -- shortest val is          1.1754944000
 -- midpoint to next val is  1.1754944208...
 SELECT float4send('1.17549435e-38'::float4);
- float4send 
-------------
- \x00800000
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('1.1754944e-38'::float4);
- float4send 
-------------
- \x00800000
-(1 row)
-
+ERROR:  function float4send does not exist
 -- test output (and round-trip safety) of various values.
 -- To ensure we're testing what we think we're testing, start with
 -- float values specified by bit patterns (as a useful side effect,
 -- this means we'll fail on non-IEEE platforms).
 create type xfloat4;
+ERROR:  only support select and create table statement
 create function xfloat4in(cstring) returns xfloat4 immutable strict
   language internal as 'int4in';
-NOTICE:  return type xfloat4 is only a shell
+ERROR:  only support select and create table statement
 create function xfloat4out(xfloat4) returns cstring immutable strict
   language internal as 'int4out';
-NOTICE:  argument type xfloat4 is only a shell
+ERROR:  only support select and create table statement
 create type xfloat4 (input = xfloat4in, output = xfloat4out, like = float4);
+ERROR:  only support select and create table statement
 create cast (xfloat4 as float4) without function;
+ERROR:  only support select and create table statement
 create cast (float4 as xfloat4) without function;
+ERROR:  only support select and create table statement
 create cast (xfloat4 as integer) without function;
+ERROR:  only support select and create table statement
 create cast (integer as xfloat4) without function;
+ERROR:  only support select and create table statement
 -- float4: seeeeeee emmmmmmm mmmmmmmm mmmmmmmm
 -- we don't care to assume the platform's strtod() handles subnormals
 -- correctly; those are "use at your own risk". However we do test
@@ -480,31 +403,7 @@
   from (select bits::integer::xfloat4::float4 as flt
           from testdata
 	offset 0) s;
-   ibits    |      flt      
-------------+---------------
- \x00000001 |         1e-45
- \x00000002 |         3e-45
- \x00000003 |         4e-45
- \x00000010 |       2.2e-44
- \x00000011 |       2.4e-44
- \x00000100 |      3.59e-43
- \x00000101 |       3.6e-43
- \x00004000 |    2.2959e-41
- \x00004001 |     2.296e-41
- \x00080000 |   7.34684e-40
- \x00080001 |   7.34685e-40
- \x0053c4f4 |     7.693e-39
- \x006c85c4 |   9.96622e-39
- \x0041ca76 |  6.041937e-39
- \x004b7678 |  6.930161e-39
- \x00000007 |         1e-44
- \x00424fe2 |    6.0898e-39
- \x007ffff0 | 1.1754921e-38
- \x007ffff1 | 1.1754922e-38
- \x007ffffe | 1.1754941e-38
- \x007fffff | 1.1754942e-38
-(21 rows)
-
+ERROR:  clapdb doesn't support CTE currently
 with testdata(bits) as (values
   (x'00000000'),
   -- smallest normal values
@@ -670,277 +569,7 @@
   from (select bits::integer::xfloat4::float4 as flt
           from testdata
 	offset 0) s;
-   ibits    |      flt       |     r_flt      |   obits    | correct 
-------------+----------------+----------------+------------+---------
- \x00000000 |              0 |              0 | \x00000000 | t
- \x00800000 |  1.1754944e-38 |  1.1754944e-38 | \x00800000 | t
- \x00800001 |  1.1754945e-38 |  1.1754945e-38 | \x00800001 | t
- \x00800004 |  1.1754949e-38 |  1.1754949e-38 | \x00800004 | t
- \x00800005 |   1.175495e-38 |   1.175495e-38 | \x00800005 | t
- \x00800006 |  1.1754952e-38 |  1.1754952e-38 | \x00800006 | t
- \x008002f1 |  1.1755999e-38 |  1.1755999e-38 | \x008002f1 | t
- \x008002f2 |     1.1756e-38 |     1.1756e-38 | \x008002f2 | t
- \x008002f3 |  1.1756001e-38 |  1.1756001e-38 | \x008002f3 | t
- \x00800e17 |  1.1759998e-38 |  1.1759998e-38 | \x00800e17 | t
- \x00800e18 |      1.176e-38 |      1.176e-38 | \x00800e18 | t
- \x00800e19 |  1.1760001e-38 |  1.1760001e-38 | \x00800e19 | t
- \x01000001 |   2.350989e-38 |   2.350989e-38 | \x01000001 | t
- \x01102843 |   2.647751e-38 |   2.647751e-38 | \x01102843 | t
- \x01a52c98 |  6.0675416e-38 |  6.0675416e-38 | \x01a52c98 | t
- \x0219c229 |  1.1296386e-37 |  1.1296386e-37 | \x0219c229 | t
- \x02e4464d |   3.354194e-37 |   3.354194e-37 | \x02e4464d | t
- \x037343c1 |   7.148906e-37 |   7.148906e-37 | \x037343c1 | t
- \x03a91b36 |   9.939175e-37 |   9.939175e-37 | \x03a91b36 | t
- \x047ada65 |   2.948764e-36 |   2.948764e-36 | \x047ada65 | t
- \x0496fe87 |  3.5498577e-36 |  3.5498577e-36 | \x0496fe87 | t
- \x0550844f |   9.804414e-36 |   9.804414e-36 | \x0550844f | t
- \x05999da3 |  1.4445957e-35 |  1.4445957e-35 | \x05999da3 | t
- \x060ea5e2 |  2.6829103e-35 |  2.6829103e-35 | \x060ea5e2 | t
- \x06e63c45 |   8.660494e-35 |   8.660494e-35 | \x06e63c45 | t
- \x07f1e548 |   3.639641e-34 |   3.639641e-34 | \x07f1e548 | t
- \x0fc5282b |  1.9441172e-29 |  1.9441172e-29 | \x0fc5282b | t
- \x1f850283 |  5.6331846e-20 |  5.6331846e-20 | \x1f850283 | t
- \x2874a9d6 |  1.3581548e-14 |  1.3581548e-14 | \x2874a9d6 | t
- \x3356bf94 |  4.9999997e-08 |  4.9999997e-08 | \x3356bf94 | t
- \x3356bf95 |          5e-08 |          5e-08 | \x3356bf95 | t
- \x3356bf96 |  5.0000004e-08 |  5.0000004e-08 | \x3356bf96 | t
- \x33d6bf94 |  9.9999994e-08 |  9.9999994e-08 | \x33d6bf94 | t
- \x33d6bf95 |          1e-07 |          1e-07 | \x33d6bf95 | t
- \x33d6bf96 |  1.0000001e-07 |  1.0000001e-07 | \x33d6bf96 | t
- \x34a10faf |  2.9999998e-07 |  2.9999998e-07 | \x34a10faf | t
- \x34a10fb0 |          3e-07 |          3e-07 | \x34a10fb0 | t
- \x34a10fb1 |  3.0000004e-07 |  3.0000004e-07 | \x34a10fb1 | t
- \x350637bc |  4.9999994e-07 |  4.9999994e-07 | \x350637bc | t
- \x350637bd |          5e-07 |          5e-07 | \x350637bd | t
- \x350637be |  5.0000006e-07 |  5.0000006e-07 | \x350637be | t
- \x35719786 |   8.999999e-07 |   8.999999e-07 | \x35719786 | t
- \x35719787 |          9e-07 |          9e-07 | \x35719787 | t
- \x35719788 |  9.0000003e-07 |  9.0000003e-07 | \x35719788 | t
- \x358637bc |   9.999999e-07 |   9.999999e-07 | \x358637bc | t
- \x358637bd |          1e-06 |          1e-06 | \x358637bd | t
- \x358637be |  1.0000001e-06 |  1.0000001e-06 | \x358637be | t
- \x36a7c5ab |  4.9999994e-06 |  4.9999994e-06 | \x36a7c5ab | t
- \x36a7c5ac |          5e-06 |          5e-06 | \x36a7c5ac | t
- \x36a7c5ad |  5.0000003e-06 |  5.0000003e-06 | \x36a7c5ad | t
- \x3727c5ab |   9.999999e-06 |   9.999999e-06 | \x3727c5ab | t
- \x3727c5ac |          1e-05 |          1e-05 | \x3727c5ac | t
- \x3727c5ad |  1.0000001e-05 |  1.0000001e-05 | \x3727c5ad | t
- \x38d1b714 |  9.9999976e-05 |  9.9999976e-05 | \x38d1b714 | t
- \x38d1b715 |   9.999998e-05 |   9.999998e-05 | \x38d1b715 | t
- \x38d1b716 |   9.999999e-05 |   9.999999e-05 | \x38d1b716 | t
- \x38d1b717 |         0.0001 |         0.0001 | \x38d1b717 | t
- \x38d1b718 | 0.000100000005 | 0.000100000005 | \x38d1b718 | t
- \x38d1b719 |  0.00010000001 |  0.00010000001 | \x38d1b719 | t
- \x38d1b71a |  0.00010000002 |  0.00010000002 | \x38d1b71a | t
- \x38d1b71b |  0.00010000003 |  0.00010000003 | \x38d1b71b | t
- \x38d1b71c | 0.000100000034 | 0.000100000034 | \x38d1b71c | t
- \x38d1b71d |  0.00010000004 |  0.00010000004 | \x38d1b71d | t
- \x38dffffe |  0.00010681151 |  0.00010681151 | \x38dffffe | t
- \x38dfffff | 0.000106811516 | 0.000106811516 | \x38dfffff | t
- \x38e00000 |  0.00010681152 |  0.00010681152 | \x38e00000 | t
- \x38efffff |  0.00011444091 |  0.00011444091 | \x38efffff | t
- \x38f00000 |  0.00011444092 |  0.00011444092 | \x38f00000 | t
- \x38f00001 | 0.000114440925 | 0.000114440925 | \x38f00001 | t
- \x3a83126e |   0.0009999999 |   0.0009999999 | \x3a83126e | t
- \x3a83126f |          0.001 |          0.001 | \x3a83126f | t
- \x3a831270 |   0.0010000002 |   0.0010000002 | \x3a831270 | t
- \x3c23d709 |    0.009999999 |    0.009999999 | \x3c23d709 | t
- \x3c23d70a |           0.01 |           0.01 | \x3c23d70a | t
- \x3c23d70b |    0.010000001 |    0.010000001 | \x3c23d70b | t
- \x3dcccccc |    0.099999994 |    0.099999994 | \x3dcccccc | t
- \x3dcccccd |            0.1 |            0.1 | \x3dcccccd | t
- \x3dccccce |     0.10000001 |     0.10000001 | \x3dccccce | t
- \x3dcccd6f |     0.10000121 |     0.10000121 | \x3dcccd6f | t
- \x3dcccd70 |    0.100001216 |    0.100001216 | \x3dcccd70 | t
- \x3dcccd71 |     0.10000122 |     0.10000122 | \x3dcccd71 | t
- \x3effffff |     0.49999997 |     0.49999997 | \x3effffff | t
- \x3f000000 |            0.5 |            0.5 | \x3f000000 | t
- \x3f000001 |     0.50000006 |     0.50000006 | \x3f000001 | t
- \x3f333332 |      0.6999999 |      0.6999999 | \x3f333332 | t
- \x3f333333 |            0.7 |            0.7 | \x3f333333 | t
- \x3f333334 |     0.70000005 |     0.70000005 | \x3f333334 | t
- \x3f666665 |      0.8999999 |      0.8999999 | \x3f666665 | t
- \x3f666666 |            0.9 |            0.9 | \x3f666666 | t
- \x3f666667 |     0.90000004 |     0.90000004 | \x3f666667 | t
- \x3f7d70a3 |     0.98999995 |     0.98999995 | \x3f7d70a3 | t
- \x3f7d70a4 |           0.99 |           0.99 | \x3f7d70a4 | t
- \x3f7d70a5 |     0.99000007 |     0.99000007 | \x3f7d70a5 | t
- \x3f7fbe76 |     0.99899995 |     0.99899995 | \x3f7fbe76 | t
- \x3f7fbe77 |          0.999 |          0.999 | \x3f7fbe77 | t
- \x3f7fbe78 |      0.9990001 |      0.9990001 | \x3f7fbe78 | t
- \x3f7ff971 |      0.9998999 |      0.9998999 | \x3f7ff971 | t
- \x3f7ff972 |         0.9999 |         0.9999 | \x3f7ff972 | t
- \x3f7ff973 |     0.99990004 |     0.99990004 | \x3f7ff973 | t
- \x3f7fff57 |      0.9999899 |      0.9999899 | \x3f7fff57 | t
- \x3f7fff58 |        0.99999 |        0.99999 | \x3f7fff58 | t
- \x3f7fff59 |     0.99999005 |     0.99999005 | \x3f7fff59 | t
- \x3f7fffee |      0.9999989 |      0.9999989 | \x3f7fffee | t
- \x3f7fffef |       0.999999 |       0.999999 | \x3f7fffef | t
- \x3f7ffff0 |     0.99999905 |     0.99999905 | \x3f7ffff0 | t
- \x3f7ffff1 |      0.9999991 |      0.9999991 | \x3f7ffff1 | t
- \x3f7ffff2 |     0.99999917 |     0.99999917 | \x3f7ffff2 | t
- \x3f7ffff3 |      0.9999992 |      0.9999992 | \x3f7ffff3 | t
- \x3f7ffff4 |      0.9999993 |      0.9999993 | \x3f7ffff4 | t
- \x3f7ffff5 |     0.99999934 |     0.99999934 | \x3f7ffff5 | t
- \x3f7ffff6 |      0.9999994 |      0.9999994 | \x3f7ffff6 | t
- \x3f7ffff7 |     0.99999946 |     0.99999946 | \x3f7ffff7 | t
- \x3f7ffff8 |      0.9999995 |      0.9999995 | \x3f7ffff8 | t
- \x3f7ffff9 |      0.9999996 |      0.9999996 | \x3f7ffff9 | t
- \x3f7ffffa |     0.99999964 |     0.99999964 | \x3f7ffffa | t
- \x3f7ffffb |      0.9999997 |      0.9999997 | \x3f7ffffb | t
- \x3f7ffffc |     0.99999976 |     0.99999976 | \x3f7ffffc | t
- \x3f7ffffd |      0.9999998 |      0.9999998 | \x3f7ffffd | t
- \x3f7ffffe |      0.9999999 |      0.9999999 | \x3f7ffffe | t
- \x3f7fffff |     0.99999994 |     0.99999994 | \x3f7fffff | t
- \x3f800000 |              1 |              1 | \x3f800000 | t
- \x3f800001 |      1.0000001 |      1.0000001 | \x3f800001 | t
- \x3f800002 |      1.0000002 |      1.0000002 | \x3f800002 | t
- \x3f800003 |      1.0000004 |      1.0000004 | \x3f800003 | t
- \x3f800004 |      1.0000005 |      1.0000005 | \x3f800004 | t
- \x3f800005 |      1.0000006 |      1.0000006 | \x3f800005 | t
- \x3f800006 |      1.0000007 |      1.0000007 | \x3f800006 | t
- \x3f800007 |      1.0000008 |      1.0000008 | \x3f800007 | t
- \x3f800008 |       1.000001 |       1.000001 | \x3f800008 | t
- \x3f800009 |      1.0000011 |      1.0000011 | \x3f800009 | t
- \x3f80000f |      1.0000018 |      1.0000018 | \x3f80000f | t
- \x3f800010 |      1.0000019 |      1.0000019 | \x3f800010 | t
- \x3f800011 |       1.000002 |       1.000002 | \x3f800011 | t
- \x3f800012 |      1.0000021 |      1.0000021 | \x3f800012 | t
- \x3f800013 |      1.0000023 |      1.0000023 | \x3f800013 | t
- \x3f800014 |      1.0000024 |      1.0000024 | \x3f800014 | t
- \x3f800017 |      1.0000027 |      1.0000027 | \x3f800017 | t
- \x3f800018 |      1.0000029 |      1.0000029 | \x3f800018 | t
- \x3f800019 |       1.000003 |       1.000003 | \x3f800019 | t
- \x3f80001a |      1.0000031 |      1.0000031 | \x3f80001a | t
- \x3f80001b |      1.0000032 |      1.0000032 | \x3f80001b | t
- \x3f80001c |      1.0000033 |      1.0000033 | \x3f80001c | t
- \x3f800029 |      1.0000049 |      1.0000049 | \x3f800029 | t
- \x3f80002a |       1.000005 |       1.000005 | \x3f80002a | t
- \x3f80002b |      1.0000051 |      1.0000051 | \x3f80002b | t
- \x3f800053 |      1.0000099 |      1.0000099 | \x3f800053 | t
- \x3f800054 |        1.00001 |        1.00001 | \x3f800054 | t
- \x3f800055 |      1.0000101 |      1.0000101 | \x3f800055 | t
- \x3f800346 |      1.0000999 |      1.0000999 | \x3f800346 | t
- \x3f800347 |         1.0001 |         1.0001 | \x3f800347 | t
- \x3f800348 |      1.0001001 |      1.0001001 | \x3f800348 | t
- \x3f8020c4 |      1.0009999 |      1.0009999 | \x3f8020c4 | t
- \x3f8020c5 |          1.001 |          1.001 | \x3f8020c5 | t
- \x3f8020c6 |      1.0010002 |      1.0010002 | \x3f8020c6 | t
- \x3f8147ad |      1.0099999 |      1.0099999 | \x3f8147ad | t
- \x3f8147ae |           1.01 |           1.01 | \x3f8147ae | t
- \x3f8147af |      1.0100001 |      1.0100001 | \x3f8147af | t
- \x3f8ccccc |      1.0999999 |      1.0999999 | \x3f8ccccc | t
- \x3f8ccccd |            1.1 |            1.1 | \x3f8ccccd | t
- \x3f8cccce |      1.1000001 |      1.1000001 | \x3f8cccce | t
- \x3fc90fdb |      1.5707964 |      1.5707964 | \x3fc90fdb | t
- \x402df854 |      2.7182817 |      2.7182817 | \x402df854 | t
- \x40490fdb |      3.1415927 |      3.1415927 | \x40490fdb | t
- \x409fffff |      4.9999995 |      4.9999995 | \x409fffff | t
- \x40a00000 |              5 |              5 | \x40a00000 | t
- \x40a00001 |      5.0000005 |      5.0000005 | \x40a00001 | t
- \x40afffff |      5.4999995 |      5.4999995 | \x40afffff | t
- \x40b00000 |            5.5 |            5.5 | \x40b00000 | t
- \x40b00001 |      5.5000005 |      5.5000005 | \x40b00001 | t
- \x411fffff |       9.999999 |       9.999999 | \x411fffff | t
- \x41200000 |             10 |             10 | \x41200000 | t
- \x41200001 |      10.000001 |      10.000001 | \x41200001 | t
- \x42c7ffff |       99.99999 |       99.99999 | \x42c7ffff | t
- \x42c80000 |            100 |            100 | \x42c80000 | t
- \x42c80001 |      100.00001 |      100.00001 | \x42c80001 | t
- \x4479ffff |      999.99994 |      999.99994 | \x4479ffff | t
- \x447a0000 |           1000 |           1000 | \x447a0000 | t
- \x447a0001 |     1000.00006 |     1000.00006 | \x447a0001 | t
- \x461c3fff |       9999.999 |       9999.999 | \x461c3fff | t
- \x461c4000 |          10000 |          10000 | \x461c4000 | t
- \x461c4001 |      10000.001 |      10000.001 | \x461c4001 | t
- \x47c34fff |       99999.99 |       99999.99 | \x47c34fff | t
- \x47c35000 |         100000 |         100000 | \x47c35000 | t
- \x47c35001 |      100000.01 |      100000.01 | \x47c35001 | t
- \x497423ff |      999999.94 |      999999.94 | \x497423ff | t
- \x49742400 |          1e+06 |          1e+06 | \x49742400 | t
- \x49742401 | 1.00000006e+06 | 1.00000006e+06 | \x49742401 | t
- \x4b18967f |   9.999999e+06 |   9.999999e+06 | \x4b18967f | t
- \x4b189680 |          1e+07 |          1e+07 | \x4b189680 | t
- \x4b189681 |  1.0000001e+07 |  1.0000001e+07 | \x4b189681 | t
- \x4cbebc1f |   9.999999e+07 |   9.999999e+07 | \x4cbebc1f | t
- \x4cbebc20 |          1e+08 |          1e+08 | \x4cbebc20 | t
- \x4cbebc21 |  1.0000001e+08 |  1.0000001e+08 | \x4cbebc21 | t
- \x4e6e6b27 |  9.9999994e+08 |  9.9999994e+08 | \x4e6e6b27 | t
- \x4e6e6b28 |          1e+09 |          1e+09 | \x4e6e6b28 | t
- \x4e6e6b29 | 1.00000006e+09 | 1.00000006e+09 | \x4e6e6b29 | t
- \x501502f8 |   9.999999e+09 |   9.999999e+09 | \x501502f8 | t
- \x501502f9 |          1e+10 |          1e+10 | \x501502f9 | t
- \x501502fa |  1.0000001e+10 |  1.0000001e+10 | \x501502fa | t
- \x51ba43b6 |   9.999999e+10 |   9.999999e+10 | \x51ba43b6 | t
- \x51ba43b7 |          1e+11 |          1e+11 | \x51ba43b7 | t
- \x51ba43b8 |  1.0000001e+11 |  1.0000001e+11 | \x51ba43b8 | t
- \x1f6c1e4a |          5e-20 |          5e-20 | \x1f6c1e4a | t
- \x59be6cea |        6.7e+15 |        6.7e+15 | \x59be6cea | t
- \x5d5ab6c4 |       9.85e+17 |       9.85e+17 | \x5d5ab6c4 | t
- \x2cc4a9bd |     5.5895e-12 |     5.5895e-12 | \x2cc4a9bd | t
- \x15ae43fd |   7.038531e-26 |   7.038531e-26 | \x15ae43fd | t
- \x2cf757ca |  7.0299088e-12 |  7.0299088e-12 | \x2cf757ca | t
- \x665ba998 |  2.5933168e+23 |  2.5933168e+23 | \x665ba998 | t
- \x743c3324 |  5.9642887e+31 |  5.9642887e+31 | \x743c3324 | t
- \x47f1205a |       123456.7 |       123456.7 | \x47f1205a | t
- \x4640e6ae |       12345.67 |       12345.67 | \x4640e6ae | t
- \x449a5225 |       1234.567 |       1234.567 | \x449a5225 | t
- \x42f6e9d5 |       123.4567 |       123.4567 | \x42f6e9d5 | t
- \x414587dd |       12.34567 |       12.34567 | \x414587dd | t
- \x3f9e064b |       1.234567 |       1.234567 | \x3f9e064b | t
- \x4c000004 |  3.3554448e+07 |  3.3554448e+07 | \x4c000004 | t
- \x50061c46 |   8.999999e+09 |   8.999999e+09 | \x50061c46 | t
- \x510006a8 |  3.4366718e+10 |  3.4366718e+10 | \x510006a8 | t
- \x48951f84 |      305404.12 |      305404.12 | \x48951f84 | t
- \x45fd1840 |      8099.0312 |      8099.0312 | \x45fd1840 | t
- \x39800000 |  0.00024414062 |  0.00024414062 | \x39800000 | t
- \x3b200000 |   0.0024414062 |   0.0024414062 | \x3b200000 | t
- \x3b900000 |   0.0043945312 |   0.0043945312 | \x3b900000 | t
- \x3bd00000 |   0.0063476562 |   0.0063476562 | \x3bd00000 | t
- \x63800000 |  4.7223665e+21 |  4.7223665e+21 | \x63800000 | t
- \x4b000000 |   8.388608e+06 |   8.388608e+06 | \x4b000000 | t
- \x4b800000 |  1.6777216e+07 |  1.6777216e+07 | \x4b800000 | t
- \x4c000001 |  3.3554436e+07 |  3.3554436e+07 | \x4c000001 | t
- \x4c800b0d |  6.7131496e+07 |  6.7131496e+07 | \x4c800b0d | t
- \x00d24584 |  1.9310392e-38 |  1.9310392e-38 | \x00d24584 | t
- \x00d90b88 |   1.993244e-38 |   1.993244e-38 | \x00d90b88 | t
- \x45803f34 |      4103.9004 |      4103.9004 | \x45803f34 | t
- \x4f9f24f7 |  5.3399997e+09 |  5.3399997e+09 | \x4f9f24f7 | t
- \x3a8722c3 |   0.0010310042 |   0.0010310042 | \x3a8722c3 | t
- \x5c800041 |   2.882326e+17 |   2.882326e+17 | \x5c800041 | t
- \x15ae43fd |   7.038531e-26 |   7.038531e-26 | \x15ae43fd | t
- \x5d4cccfb |   9.223404e+17 |   9.223404e+17 | \x5d4cccfb | t
- \x4c800001 |   6.710887e+07 |   6.710887e+07 | \x4c800001 | t
- \x57800ed8 |   2.816025e+14 |   2.816025e+14 | \x57800ed8 | t
- \x5f000000 |   9.223372e+18 |   9.223372e+18 | \x5f000000 | t
- \x700000f0 |  1.5846086e+29 |  1.5846086e+29 | \x700000f0 | t
- \x5f23e9ac |  1.1811161e+19 |  1.1811161e+19 | \x5f23e9ac | t
- \x5e9502f9 |   5.368709e+18 |   5.368709e+18 | \x5e9502f9 | t
- \x5e8012b1 |  4.6143166e+18 |  4.6143166e+18 | \x5e8012b1 | t
- \x3c000028 |    0.007812537 |    0.007812537 | \x3c000028 | t
- \x60cde861 | 1.18697725e+20 | 1.18697725e+20 | \x60cde861 | t
- \x03aa2a50 | 1.00014165e-36 | 1.00014165e-36 | \x03aa2a50 | t
- \x43480000 |            200 |            200 | \x43480000 | t
- \x4c000000 |  3.3554432e+07 |  3.3554432e+07 | \x4c000000 | t
- \x5d1502f9 |  6.7108864e+17 |  6.7108864e+17 | \x5d1502f9 | t
- \x5d9502f9 |  1.3421773e+18 |  1.3421773e+18 | \x5d9502f9 | t
- \x5e1502f9 |  2.6843546e+18 |  2.6843546e+18 | \x5e1502f9 | t
- \x3f99999a |            1.2 |            1.2 | \x3f99999a | t
- \x3f9d70a4 |           1.23 |           1.23 | \x3f9d70a4 | t
- \x3f9df3b6 |          1.234 |          1.234 | \x3f9df3b6 | t
- \x3f9e0419 |         1.2345 |         1.2345 | \x3f9e0419 | t
- \x3f9e0610 |        1.23456 |        1.23456 | \x3f9e0610 | t
- \x3f9e064b |       1.234567 |       1.234567 | \x3f9e064b | t
- \x3f9e0651 |      1.2345678 |      1.2345678 | \x3f9e0651 | t
- \x03d20cfe | 1.23456735e-36 | 1.23456735e-36 | \x03d20cfe | t
-(261 rows)
-
+ERROR:  clapdb doesn't support CTE currently
 -- clean up, lest opr_sanity complain
 drop type xfloat4 cascade;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to function xfloat4in(cstring)
-drop cascades to function xfloat4out(xfloat4)
-drop cascades to cast from xfloat4 to real
-drop cascades to cast from real to xfloat4
-drop cascades to cast from xfloat4 to integer
-drop cascades to cast from integer to xfloat4
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/float8.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/float8.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/float8.out	2024-03-25 11:16:04.670340594 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/float8.out	2024-04-12 10:23:51.151930235 +0800
@@ -6,6 +6,7 @@
 -- (This temporarily hides the table created in test_setup.sql)
 --
 CREATE TEMP TABLE FLOAT8_TBL(f1 float8);
+ERROR:  relation "public.float8_tbl" already exists
 INSERT INTO FLOAT8_TBL(f1) VALUES ('    0.0   ');
 INSERT INTO FLOAT8_TBL(f1) VALUES ('1004.30  ');
 INSERT INTO FLOAT8_TBL(f1) VALUES ('   -34.84');
@@ -13,37 +14,33 @@
 INSERT INTO FLOAT8_TBL(f1) VALUES ('1.2345678901234e-200');
 -- test for underflow and overflow handling
 SELECT '10e400'::float8;
-ERROR:  "10e400" is out of range for type double precision
+ERROR:  value "10e400" is out of range for type floating
 SELECT '-10e400'::float8;
-ERROR:  "-10e400" is out of range for type double precision
+ERROR:  value "-10e400" is out of range for type floating
 SELECT '10e-400'::float8;
-ERROR:  "10e-400" is out of range for type double precision
+ERROR:  value "10e-400" is out of range for type floating
 SELECT '-10e-400'::float8;
-ERROR:  "-10e-400" is out of range for type double precision
+ERROR:  value "-10e-400" is out of range for type floating
 -- test smallest normalized input
 SELECT float8send('2.2250738585072014E-308'::float8);
-     float8send     
---------------------
- \x0010000000000000
-(1 row)
-
+ERROR:  function float8send does not exist
 -- bad input
 INSERT INTO FLOAT8_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for type double precision: ""
+ERROR:  invalid input syntax for type floating: ""
 INSERT INTO FLOAT8_TBL(f1) VALUES ('     ');
-ERROR:  invalid input syntax for type double precision: "     "
+ERROR:  invalid input syntax for type floating: "     "
 INSERT INTO FLOAT8_TBL(f1) VALUES ('xyz');
-ERROR:  invalid input syntax for type double precision: "xyz"
+ERROR:  invalid input syntax for type floating: "xyz"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('5.0.0');
-ERROR:  invalid input syntax for type double precision: "5.0.0"
+ERROR:  invalid input syntax for type floating: "5.0.0"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('5 . 0');
-ERROR:  invalid input syntax for type double precision: "5 . 0"
+ERROR:  invalid input syntax for type floating: "5 . 0"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('5.   0');
-ERROR:  invalid input syntax for type double precision: "5.   0"
+ERROR:  invalid input syntax for type floating: "5.   0"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('    - 3');
-ERROR:  invalid input syntax for type double precision: "    - 3"
+ERROR:  invalid input syntax for type floating: "- 3"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('123           5');
-ERROR:  invalid input syntax for type double precision: "123           5"
+ERROR:  invalid input syntax for type floating: "123           5"
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34.5', 'float8');
  pg_input_is_valid 
@@ -64,59 +61,55 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('1e4000', 'float8');
-                      message                       | detail | hint | sql_error_code 
-----------------------------------------------------+--------+------+----------------
- "1e4000" is out of range for type double precision |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- special inputs
 SELECT 'NaN'::float8;
- float8 
---------
-    NaN
+ ?column? 
+----------
+      nan
 (1 row)
 
 SELECT 'nan'::float8;
- float8 
---------
-    NaN
+ ?column? 
+----------
+      nan
 (1 row)
 
 SELECT '   NAN  '::float8;
- float8 
---------
-    NaN
+ ?column? 
+----------
+      nan
 (1 row)
 
 SELECT 'infinity'::float8;
-  float8  
+ ?column? 
 ----------
- Infinity
+      inf
 (1 row)
 
 SELECT '          -INFINiTY   '::float8;
-  float8   
------------
- -Infinity
+ ?column? 
+----------
+     -inf
 (1 row)
 
 -- bad special inputs
 SELECT 'N A N'::float8;
-ERROR:  invalid input syntax for type double precision: "N A N"
+ERROR:  invalid input syntax for type floating: "N A N"
 SELECT 'NaN x'::float8;
-ERROR:  invalid input syntax for type double precision: "NaN x"
+ERROR:  invalid input syntax for type floating: "NaN x"
 SELECT ' INFINITY    x'::float8;
-ERROR:  invalid input syntax for type double precision: " INFINITY    x"
+ERROR:  invalid input syntax for type floating: "INFINITY    x"
 SELECT 'Infinity'::float8 + 100.0;
  ?column? 
 ----------
- Infinity
+      inf
 (1 row)
 
 SELECT 'Infinity'::float8 / 'Infinity'::float8;
  ?column? 
 ----------
-      NaN
+     -nan
 (1 row)
 
 SELECT '42'::float8 / 'Infinity'::float8;
@@ -128,39 +121,45 @@
 SELECT 'nan'::float8 / 'nan'::float8;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::float8 / '0'::float8;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::numeric::float8;
- float8 
---------
-    NaN
-(1 row)
-
+ERROR:  not implemented type_cast case [to=numeric]
 SELECT * FROM FLOAT8_TBL order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
-               1004.3
- 1.2345678901234e+200
-(5 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+                1004.3
+  1.2345678901234e+200
+(10 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE f.f1 <> '1004.3' order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
- 1.2345678901234e+200
-(4 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+  1.2345678901234e+200
+(9 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE f.f1 = '1004.3' order by 1;
    f1   
@@ -169,38 +168,58 @@
 (1 row)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE '1004.3' > f.f1 order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
-(3 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+(8 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE  f.f1 < '1004.3' order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
-(3 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+(8 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE '1004.3' >= f.f1 order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
-               1004.3
-(4 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+                1004.3
+(9 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE  f.f1 <= '1004.3' order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
-               1004.3
-(4 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+                1004.3
+(9 rows)
 
 SELECT f.f1, f.f1 * '-10' AS x
    FROM FLOAT8_TBL f
@@ -244,526 +263,244 @@
 
 SELECT f.f1 ^ '2.0' AS square_f1
    FROM FLOAT8_TBL f where f.f1 = '1004.3' order by 1;
-     square_f1      
---------------------
- 1008618.4899999999
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 -- absolute value
 SELECT f.f1, @f.f1 AS abs_f1
    FROM FLOAT8_TBL f order by 1;
-          f1          |        abs_f1        
-----------------------+----------------------
-               -34.84 |                34.84
-                    0 |                    0
- 1.2345678901234e-200 | 1.2345678901234e-200
-               1004.3 |               1004.3
- 1.2345678901234e+200 | 1.2345678901234e+200
-(5 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=@]
 -- truncate
 SELECT f.f1, trunc(f.f1) AS trunc_f1
    FROM FLOAT8_TBL f order by 1;
-          f1          |       trunc_f1       
-----------------------+----------------------
-               -34.84 |                  -34
-                    0 |                    0
- 1.2345678901234e-200 |                    0
-               1004.3 |                 1004
- 1.2345678901234e+200 | 1.2345678901234e+200
-(5 rows)
-
+ERROR:  function trunc does not exist
 -- round
 SELECT f.f1, round(f.f1) AS round_f1
    FROM FLOAT8_TBL f order by 1;
-          f1          |       round_f1       
-----------------------+----------------------
-               -34.84 |                  -35
-                    0 |                    0
- 1.2345678901234e-200 |                    0
-               1004.3 |                 1004
- 1.2345678901234e+200 | 1.2345678901234e+200
-(5 rows)
-
+ERROR:  function round does not exist
 -- ceil / ceiling
 select ceil(f1) as ceil_f1 from float8_tbl f order by 1;
-       ceil_f1        
-----------------------
-                  -34
-                    0
-                    1
-                 1005
- 1.2345678901234e+200
-(5 rows)
-
+ERROR:  function ceil does not exist
 select ceiling(f1) as ceiling_f1 from float8_tbl f order by 1;
-      ceiling_f1      
-----------------------
-                  -34
-                    0
-                    1
-                 1005
- 1.2345678901234e+200
-(5 rows)
-
+ERROR:  function ceiling does not exist
 -- floor
 select floor(f1) as floor_f1 from float8_tbl f order by 1;
-       floor_f1       
-----------------------
-                  -35
-                    0
-                    0
-                 1004
- 1.2345678901234e+200
-(5 rows)
-
+ERROR:  function floor does not exist
 -- sign
 select sign(f1) as sign_f1 from float8_tbl f order by 1;
- sign_f1 
----------
-      -1
-       0
-       1
-       1
-       1
-(5 rows)
-
+ERROR:  function sign does not exist
 -- avoid bit-exact output here because operations may not be bit-exact.
 SET extra_float_digits = 0;
+ERROR:  only support select and create table statement
 -- square root
 SELECT sqrt(float8 '64') AS eight;
- eight 
--------
-     8
-(1 row)
-
+ERROR:  function sqrt does not exist
 SELECT |/ float8 '64' AS eight;
- eight 
--------
-     8
-(1 row)
-
+ERROR:  unary_optr only support +/-, [optr_str=|/]
 SELECT f.f1, |/f.f1 AS sqrt_f1
    FROM FLOAT8_TBL f
    WHERE f.f1 > '0.0' order by 1;
-          f1          |        sqrt_f1        
-----------------------+-----------------------
- 1.2345678901234e-200 | 1.11111110611109e-100
-               1004.3 |      31.6906926399535
- 1.2345678901234e+200 | 1.11111110611109e+100
-(3 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=|/]
 -- power
 SELECT power(float8 '144', float8 '0.5');
- power 
--------
-    12
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'NaN', float8 '0.5');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '144', float8 'NaN');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'NaN', float8 'NaN');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1', float8 'NaN');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1', float8 'NaN');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'NaN', float8 '0');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '0');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '0');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0', float8 'inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0', float8 '-inf');
-ERROR:  zero raised to a negative power is undefined
+ERROR:  function power does not exist
 SELECT power(float8 '1', float8 'inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1', float8 '-inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1', float8 'inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1', float8 '-inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0.1', float8 'inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-0.1', float8 'inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1.1', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1.1', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0.1', float8 '-inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-0.1', float8 '-inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1.1', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1.1', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '-2');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '2');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 -- Intel's icc misoptimizes the code that controls the sign of this result,
 -- even with -mp1.  Pending a fix for that, only test for "is it zero".
 SELECT power(float8 '-inf', float8 '-2') = '0';
- ?column? 
-----------
- t
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '-3');
- power 
--------
-    -0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '2');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '3');
-   power   
------------
- -Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '3.5');
-ERROR:  a negative number raised to a non-integer power yields a complex result
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 -- take exp of ln(f.f1)
 SELECT f.f1, exp(ln(f.f1)) AS exp_ln_f1
    FROM FLOAT8_TBL f
    WHERE f.f1 > '0.0' order by 1;
-          f1          |       exp_ln_f1       
-----------------------+-----------------------
- 1.2345678901234e-200 | 1.23456789012339e-200
-               1004.3 |                1004.3
- 1.2345678901234e+200 | 1.23456789012338e+200
-(3 rows)
-
+ERROR:  function exp does not exist
 -- check edge cases for exp
 SELECT exp('inf'::float8), exp('-inf'::float8), exp('nan'::float8);
-   exp    | exp | exp 
-----------+-----+-----
- Infinity |   0 | NaN
-(1 row)
-
+ERROR:  function exp does not exist
 -- cube root
 SELECT ||/ float8 '27' AS three;
- three 
--------
-     3
-(1 row)
-
+ERROR:  unary_optr only support +/-, [optr_str=||/]
 SELECT f.f1, ||/f.f1 AS cbrt_f1 FROM FLOAT8_TBL f order by 1;
-          f1          |       cbrt_f1        
-----------------------+----------------------
-               -34.84 |    -3.26607421344208
-                    0 |                    0
- 1.2345678901234e-200 |  2.3112042409018e-67
-               1004.3 |      10.014312837827
- 1.2345678901234e+200 | 4.97933859234765e+66
-(5 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=||/]
 SELECT * FROM FLOAT8_TBL order by 1;
-          f1          
-----------------------
-               -34.84
-                    0
- 1.2345678901234e-200
-               1004.3
- 1.2345678901234e+200
-(5 rows)
+          f1           
+-----------------------
+ -1.2345678901234e+200
+               -1004.3
+                -34.84
+                -34.84
+ -1.2345678901234e-200
+                     0
+                     0
+  1.2345678901234e-200
+                1004.3
+  1.2345678901234e+200
+(10 rows)
 
 UPDATE FLOAT8_TBL
    SET f1 = FLOAT8_TBL.f1 * '-1'
    WHERE FLOAT8_TBL.f1 > '0.0';
+ERROR:  only support select and create table statement
 SELECT f.f1 * '1e200' from FLOAT8_TBL f order by 1;
-ERROR:  value out of range: overflow
+         ?column?         
+--------------------------
+                     -inf
+ -1.0042999999999999e+203
+              -3.484e+201
+              -3.484e+201
+         -1.2345678901234
+                        0
+                        0
+          1.2345678901234
+  1.0042999999999999e+203
+                      inf
+(10 rows)
+
 SELECT f.f1 ^ '1e200' from FLOAT8_TBL f order by 1;
-ERROR:  value out of range: overflow
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 SELECT 0 ^ 0 + 0 ^ 1 + 0 ^ 0.0 + 0 ^ 0.5;
- ?column? 
-----------
-        2
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 SELECT ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0'  order by 1;
-ERROR:  cannot take logarithm of zero
+ERROR:  function ln does not exist
 SELECT ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0'  order by 1;
-ERROR:  cannot take logarithm of a negative number
+ERROR:  function ln does not exist
 SELECT exp(f.f1) from FLOAT8_TBL f order by 1;
-ERROR:  value out of range: underflow
+ERROR:  function exp does not exist
 SELECT f.f1 / '0.0' from FLOAT8_TBL f order by 1;
-ERROR:  division by zero
+ERROR:  div zero [func=func_14505943978776108846]
 SELECT * FROM FLOAT8_TBL order by 1;
           f1           
 -----------------------
  -1.2345678901234e+200
                -1004.3
                 -34.84
+                -34.84
  -1.2345678901234e-200
                      0
-(5 rows)
+                     0
+  1.2345678901234e-200
+                1004.3
+  1.2345678901234e+200
+(10 rows)
 
 -- hyperbolic functions
 -- we run these with extra_float_digits = 0 too, since different platforms
 -- tend to produce results that vary in the last place.
 SELECT sinh(float8 '1');
-      sinh       
------------------
- 1.1752011936438
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT cosh(float8 '1');
-       cosh       
-------------------
- 1.54308063481524
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT tanh(float8 '1');
-       tanh        
--------------------
- 0.761594155955765
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT asinh(float8 '1');
-       asinh       
--------------------
- 0.881373587019543
-(1 row)
-
+ERROR:  function asinh does not exist
 SELECT acosh(float8 '2');
-      acosh       
-------------------
- 1.31695789692482
-(1 row)
-
+ERROR:  function acosh does not exist
 SELECT atanh(float8 '0.5');
-       atanh       
--------------------
- 0.549306144334055
-(1 row)
-
+ERROR:  function atanh does not exist
 -- test Inf/NaN cases for hyperbolic functions
 SELECT sinh(float8 'infinity');
-   sinh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT sinh(float8 '-infinity');
-   sinh    
------------
- -Infinity
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT sinh(float8 'nan');
- sinh 
-------
-  NaN
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT cosh(float8 'infinity');
-   cosh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT cosh(float8 '-infinity');
-   cosh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT cosh(float8 'nan');
- cosh 
-------
-  NaN
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT tanh(float8 'infinity');
- tanh 
-------
-    1
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT tanh(float8 '-infinity');
- tanh 
-------
-   -1
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT tanh(float8 'nan');
- tanh 
-------
-  NaN
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT asinh(float8 'infinity');
-  asinh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function asinh does not exist
 SELECT asinh(float8 '-infinity');
-   asinh   
------------
- -Infinity
-(1 row)
-
+ERROR:  function asinh does not exist
 SELECT asinh(float8 'nan');
- asinh 
--------
-   NaN
-(1 row)
-
+ERROR:  function asinh does not exist
 -- acosh(Inf) should be Inf, but some mingw versions produce NaN, so skip test
 -- SELECT acosh(float8 'infinity');
 SELECT acosh(float8 '-infinity');
-ERROR:  input is out of range
+ERROR:  function acosh does not exist
 SELECT acosh(float8 'nan');
- acosh 
--------
-   NaN
-(1 row)
-
+ERROR:  function acosh does not exist
 SELECT atanh(float8 'infinity');
-ERROR:  input is out of range
+ERROR:  function atanh does not exist
 SELECT atanh(float8 '-infinity');
-ERROR:  input is out of range
+ERROR:  function atanh does not exist
 SELECT atanh(float8 'nan');
- atanh 
--------
-   NaN
-(1 row)
-
+ERROR:  function atanh does not exist
 -- error functions
 -- we run these with extra_float_digits = -1, to get consistently rounded
 -- results on all platforms.
 SET extra_float_digits = -1;
+ERROR:  only support select and create table statement
 SELECT x,
        erf(x),
        erfc(x)
@@ -773,43 +510,20 @@
       (1.2e-17), (2.3e-13), (1.2e-9),
       (0.45), (1.1), (2.1), (3.4), (6), (28),
       (float8 'infinity'), (float8 'nan')) AS t(x);
-     x     |         erf          |        erfc         
------------+----------------------+---------------------
- -Infinity |                   -1 |                   2
-       -28 |                   -1 |                   2
-        -6 |                   -1 |                   2
-      -3.4 |    -0.99999847800664 |     1.9999984780066
-      -2.1 |    -0.99702053334367 |     1.9970205333437
-      -1.1 |    -0.88020506957408 |     1.8802050695741
-     -0.45 |    -0.47548171978692 |     1.4754817197869
-  -1.2e-09 | -1.3540550005146e-09 |     1.0000000013541
-  -2.3e-13 | -2.5952720843197e-13 |     1.0000000000003
-  -1.2e-17 | -1.3540550005146e-17 |                   1
-         0 |                    0 |                   1
-   1.2e-17 |  1.3540550005146e-17 |                   1
-   2.3e-13 |  2.5952720843197e-13 |    0.99999999999974
-   1.2e-09 |  1.3540550005146e-09 |    0.99999999864595
-      0.45 |     0.47548171978692 |    0.52451828021308
-       1.1 |     0.88020506957408 |    0.11979493042592
-       2.1 |     0.99702053334367 |   0.002979466656333
-       3.4 |     0.99999847800664 | 1.5219933628623e-06
-         6 |                    1 | 2.1519736712499e-17
-        28 |                    1 |                   0
-  Infinity |                    1 |                   0
-       NaN |                  NaN |                 NaN
-(22 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 RESET extra_float_digits;
+ERROR:  only support select and create table statement
 -- test for over- and underflow
 INSERT INTO FLOAT8_TBL(f1) VALUES ('10e400');
-ERROR:  "10e400" is out of range for type double precision
+ERROR:  value "10e400" is out of range for type floating
 INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e400');
-ERROR:  "-10e400" is out of range for type double precision
+ERROR:  value "-10e400" is out of range for type floating
 INSERT INTO FLOAT8_TBL(f1) VALUES ('10e-400');
-ERROR:  "10e-400" is out of range for type double precision
+ERROR:  value "10e-400" is out of range for type floating
 INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e-400');
-ERROR:  "-10e-400" is out of range for type double precision
+ERROR:  value "-10e-400" is out of range for type floating
 DROP TABLE FLOAT8_TBL;
+ERROR:  only support select and create table statement
 -- Check the float8 values exported for use by other tests
 SELECT * FROM FLOAT8_TBL order by 1;
           f1           
@@ -817,96 +531,89 @@
  -1.2345678901234e+200
                -1004.3
                 -34.84
+                -34.84
  -1.2345678901234e-200
                      0
-(5 rows)
+                     0
+  1.2345678901234e-200
+                1004.3
+  1.2345678901234e+200
+(10 rows)
 
 -- test edge-case coercions to integer
 SELECT '32767.4'::float8::int2;
- int2  
--------
- 32767
+ ?column? 
+----------
+    32767
 (1 row)
 
 SELECT '32767.6'::float8::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+    32767
+(1 row)
+
 SELECT '-32768.4'::float8::int2;
-  int2  
---------
- -32768
+ ?column? 
+----------
+   -32768
 (1 row)
 
 SELECT '-32768.6'::float8::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+   -32768
+(1 row)
+
 SELECT '2147483647.4'::float8::int4;
-    int4    
+  ?column?  
 ------------
  2147483647
 (1 row)
 
 SELECT '2147483647.6'::float8::int4;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483647
+(1 row)
+
 SELECT '-2147483648.4'::float8::int4;
-    int4     
+  ?column?   
 -------------
  -2147483648
 (1 row)
 
 SELECT '-2147483648.6'::float8::int4;
-ERROR:  integer out of range
+  ?column?   
+-------------
+ -2147483648
+(1 row)
+
 SELECT '9223372036854773760'::float8::int8;
-        int8         
+      ?column?       
 ---------------------
  9223372036854773760
 (1 row)
 
 SELECT '9223372036854775807'::float8::int8;
-ERROR:  bigint out of range
+ERROR:  long out of range
 SELECT '-9223372036854775808.5'::float8::int8;
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  long out of range
 SELECT '-9223372036854780000'::float8::int8;
-ERROR:  bigint out of range
+ERROR:  long out of range
 -- test exact cases for trigonometric functions in degrees
 SELECT x,
        sind(x),
        sind(x) IN (-1,-0.5,0,0.5,1) AS sind_exact
 FROM (VALUES (0), (30), (90), (150), (180),
       (210), (270), (330), (360)) AS t(x);
-  x  | sind | sind_exact 
------+------+------------
-   0 |    0 | t
-  30 |  0.5 | t
-  90 |    1 | t
- 150 |  0.5 | t
- 180 |    0 | t
- 210 | -0.5 | t
- 270 |   -1 | t
- 330 | -0.5 | t
- 360 |    0 | t
-(9 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT x,
        cosd(x),
        cosd(x) IN (-1,-0.5,0,0.5,1) AS cosd_exact
 FROM (VALUES (0), (60), (90), (120), (180),
       (240), (270), (300), (360)) AS t(x);
-  x  | cosd | cosd_exact 
------+------+------------
-   0 |    1 | t
-  60 |  0.5 | t
-  90 |    0 | t
- 120 | -0.5 | t
- 180 |   -1 | t
- 240 | -0.5 | t
- 270 |    0 | t
- 300 |  0.5 | t
- 360 |    1 | t
-(9 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT x,
        tand(x),
        tand(x) IN ('-Infinity'::float8,-1,0,
@@ -916,79 +623,49 @@
                    1,'Infinity'::float8) AS cotd_exact
 FROM (VALUES (0), (45), (90), (135), (180),
       (225), (270), (315), (360)) AS t(x);
-  x  |   tand    | tand_exact |   cotd    | cotd_exact 
------+-----------+------------+-----------+------------
-   0 |         0 | t          |  Infinity | t
-  45 |         1 | t          |         1 | t
-  90 |  Infinity | t          |         0 | t
- 135 |        -1 | t          |        -1 | t
- 180 |         0 | t          | -Infinity | t
- 225 |         1 | t          |         1 | t
- 270 | -Infinity | t          |         0 | t
- 315 |        -1 | t          |        -1 | t
- 360 |         0 | t          |  Infinity | t
-(9 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT x,
        asind(x),
        asind(x) IN (-90,-30,0,30,90) AS asind_exact,
        acosd(x),
        acosd(x) IN (0,60,90,120,180) AS acosd_exact
 FROM (VALUES (-1), (-0.5), (0), (0.5), (1)) AS t(x);
-  x   | asind | asind_exact | acosd | acosd_exact 
-------+-------+-------------+-------+-------------
-   -1 |   -90 | t           |   180 | t
- -0.5 |   -30 | t           |   120 | t
-    0 |     0 | t           |    90 | t
-  0.5 |    30 | t           |    60 | t
-    1 |    90 | t           |     0 | t
-(5 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT x,
        atand(x),
        atand(x) IN (-90,-45,0,45,90) AS atand_exact
 FROM (VALUES ('-Infinity'::float8), (-1), (0), (1),
       ('Infinity'::float8)) AS t(x);
-     x     | atand | atand_exact 
------------+-------+-------------
- -Infinity |   -90 | t
-        -1 |   -45 | t
-         0 |     0 | t
-         1 |    45 | t
-  Infinity |    90 | t
-(5 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT x, y,
        atan2d(y, x),
        atan2d(y, x) IN (-90,0,90,180) AS atan2d_exact
 FROM (SELECT 10*cosd(a), 10*sind(a)
       FROM generate_series(0, 360, 90) AS t(a)) AS t(x,y);
-  x  |  y  | atan2d | atan2d_exact 
------+-----+--------+--------------
-  10 |   0 |      0 | t
-   0 |  10 |     90 | t
- -10 |   0 |    180 | t
-   0 | -10 |    -90 | t
-  10 |   0 |      0 | t
-(5 rows)
-
+ERROR:  function generate_series does not exist
 --
 -- test output (and round-trip safety) of various values.
 -- To ensure we're testing what we think we're testing, start with
 -- float values specified by bit patterns (as a useful side effect,
 -- this means we'll fail on non-IEEE platforms).
 create type xfloat8;
+ERROR:  only support select and create table statement
 create function xfloat8in(cstring) returns xfloat8 immutable strict
   language internal as 'int8in';
-NOTICE:  return type xfloat8 is only a shell
+ERROR:  only support select and create table statement
 create function xfloat8out(xfloat8) returns cstring immutable strict
   language internal as 'int8out';
-NOTICE:  argument type xfloat8 is only a shell
+ERROR:  only support select and create table statement
 create type xfloat8 (input = xfloat8in, output = xfloat8out, like = float8);
+ERROR:  only support select and create table statement
 create cast (xfloat8 as float8) without function;
+ERROR:  only support select and create table statement
 create cast (float8 as xfloat8) without function;
+ERROR:  only support select and create table statement
 create cast (xfloat8 as bigint) without function;
+ERROR:  only support select and create table statement
 create cast (bigint as xfloat8) without function;
+ERROR:  only support select and create table statement
 -- float8: seeeeeee eeeeeeee eeeeeeee mmmmmmmm mmmmmmmm(x4)
 -- we don't care to assume the platform's strtod() handles subnormals
 -- correctly; those are "use at your own risk". However we do test
@@ -1013,28 +690,7 @@
   from (select bits::bigint::xfloat8::float8 as flt
           from testdata
 	offset 0) s;
-       ibits        |           flt           
---------------------+-------------------------
- \x0000000000000001 |                  5e-324
- \x0000000000000002 |                  1e-323
- \x0000000000000003 |                1.5e-323
- \x0000000000001000 |             2.0237e-320
- \x0000000100000000 |        2.121995791e-314
- \x0000010000000000 |      5.43230922487e-312
- \x0000010100000000 |      5.45352918278e-312
- \x0000400000000000 |    3.4766779039175e-310
- \x0000400100000000 |    3.4768901034966e-310
- \x0000800000000000 |     6.953355807835e-310
- \x0000800000000001 |   6.95335580783505e-310
- \x00000000000f4240 |           4.940656e-318
- \x00000000016e3600 |         1.18575755e-316
- \x0000008cdcdea440 |     2.989102097996e-312
- \x000ffffffffffff0 | 2.2250738585071935e-308
- \x000ffffffffffff1 |  2.225073858507194e-308
- \x000ffffffffffffe | 2.2250738585072004e-308
- \x000fffffffffffff |  2.225073858507201e-308
-(18 rows)
-
+ERROR:  clapdb doesn't support CTE currently
 -- round-trip tests
 with testdata(bits) as (values
   (x'0000000000000000'),
@@ -1182,225 +838,7 @@
   from (select bits::bigint::xfloat8::float8 as flt
           from testdata
 	offset 0) s;
-       ibits        |           flt           |          r_flt          |       obits        | correct 
---------------------+-------------------------+-------------------------+--------------------+---------
- \x0000000000000000 |                       0 |                       0 | \x0000000000000000 | t
- \x0010000000000000 | 2.2250738585072014e-308 | 2.2250738585072014e-308 | \x0010000000000000 | t
- \x0010000000000001 |  2.225073858507202e-308 |  2.225073858507202e-308 | \x0010000000000001 | t
- \x0010000000000002 | 2.2250738585072024e-308 | 2.2250738585072024e-308 | \x0010000000000002 | t
- \x0018000000000000 |  3.337610787760802e-308 |  3.337610787760802e-308 | \x0018000000000000 | t
- \x3ddb7cdfd9d7bdba |   9.999999999999999e-11 |   9.999999999999999e-11 | \x3ddb7cdfd9d7bdba | t
- \x3ddb7cdfd9d7bdbb |                   1e-10 |                   1e-10 | \x3ddb7cdfd9d7bdbb | t
- \x3ddb7cdfd9d7bdbc |  1.0000000000000002e-10 |  1.0000000000000002e-10 | \x3ddb7cdfd9d7bdbc | t
- \x3e112e0be826d694 |   9.999999999999999e-10 |   9.999999999999999e-10 | \x3e112e0be826d694 | t
- \x3e112e0be826d695 |                   1e-09 |                   1e-09 | \x3e112e0be826d695 | t
- \x3e112e0be826d696 |  1.0000000000000003e-09 |  1.0000000000000003e-09 | \x3e112e0be826d696 | t
- \x3e45798ee2308c39 |   9.999999999999999e-09 |   9.999999999999999e-09 | \x3e45798ee2308c39 | t
- \x3e45798ee2308c3a |                   1e-08 |                   1e-08 | \x3e45798ee2308c3a | t
- \x3e45798ee2308c3b |  1.0000000000000002e-08 |  1.0000000000000002e-08 | \x3e45798ee2308c3b | t
- \x3e7ad7f29abcaf47 |   9.999999999999998e-08 |   9.999999999999998e-08 | \x3e7ad7f29abcaf47 | t
- \x3e7ad7f29abcaf48 |                   1e-07 |                   1e-07 | \x3e7ad7f29abcaf48 | t
- \x3e7ad7f29abcaf49 |  1.0000000000000001e-07 |  1.0000000000000001e-07 | \x3e7ad7f29abcaf49 | t
- \x3eb0c6f7a0b5ed8c |   9.999999999999997e-07 |   9.999999999999997e-07 | \x3eb0c6f7a0b5ed8c | t
- \x3eb0c6f7a0b5ed8d |                   1e-06 |                   1e-06 | \x3eb0c6f7a0b5ed8d | t
- \x3eb0c6f7a0b5ed8e |  1.0000000000000002e-06 |  1.0000000000000002e-06 | \x3eb0c6f7a0b5ed8e | t
- \x3ee4f8b588e368ef |   9.999999999999997e-06 |   9.999999999999997e-06 | \x3ee4f8b588e368ef | t
- \x3ee4f8b588e368f0 |   9.999999999999999e-06 |   9.999999999999999e-06 | \x3ee4f8b588e368f0 | t
- \x3ee4f8b588e368f1 |                   1e-05 |                   1e-05 | \x3ee4f8b588e368f1 | t
- \x3f1a36e2eb1c432c |   9.999999999999999e-05 |   9.999999999999999e-05 | \x3f1a36e2eb1c432c | t
- \x3f1a36e2eb1c432d |                  0.0001 |                  0.0001 | \x3f1a36e2eb1c432d | t
- \x3f1a36e2eb1c432e |  0.00010000000000000002 |  0.00010000000000000002 | \x3f1a36e2eb1c432e | t
- \x3f50624dd2f1a9fb |   0.0009999999999999998 |   0.0009999999999999998 | \x3f50624dd2f1a9fb | t
- \x3f50624dd2f1a9fc |                   0.001 |                   0.001 | \x3f50624dd2f1a9fc | t
- \x3f50624dd2f1a9fd |   0.0010000000000000002 |   0.0010000000000000002 | \x3f50624dd2f1a9fd | t
- \x3f847ae147ae147a |    0.009999999999999998 |    0.009999999999999998 | \x3f847ae147ae147a | t
- \x3f847ae147ae147b |                    0.01 |                    0.01 | \x3f847ae147ae147b | t
- \x3f847ae147ae147c |    0.010000000000000002 |    0.010000000000000002 | \x3f847ae147ae147c | t
- \x3fb9999999999999 |     0.09999999999999999 |     0.09999999999999999 | \x3fb9999999999999 | t
- \x3fb999999999999a |                     0.1 |                     0.1 | \x3fb999999999999a | t
- \x3fb999999999999b |     0.10000000000000002 |     0.10000000000000002 | \x3fb999999999999b | t
- \x3feffffffffffff0 |      0.9999999999999982 |      0.9999999999999982 | \x3feffffffffffff0 | t
- \x3feffffffffffff1 |      0.9999999999999983 |      0.9999999999999983 | \x3feffffffffffff1 | t
- \x3feffffffffffff2 |      0.9999999999999984 |      0.9999999999999984 | \x3feffffffffffff2 | t
- \x3feffffffffffff3 |      0.9999999999999986 |      0.9999999999999986 | \x3feffffffffffff3 | t
- \x3feffffffffffff4 |      0.9999999999999987 |      0.9999999999999987 | \x3feffffffffffff4 | t
- \x3feffffffffffff5 |      0.9999999999999988 |      0.9999999999999988 | \x3feffffffffffff5 | t
- \x3feffffffffffff6 |      0.9999999999999989 |      0.9999999999999989 | \x3feffffffffffff6 | t
- \x3feffffffffffff7 |       0.999999999999999 |       0.999999999999999 | \x3feffffffffffff7 | t
- \x3feffffffffffff8 |      0.9999999999999991 |      0.9999999999999991 | \x3feffffffffffff8 | t
- \x3feffffffffffff9 |      0.9999999999999992 |      0.9999999999999992 | \x3feffffffffffff9 | t
- \x3feffffffffffffa |      0.9999999999999993 |      0.9999999999999993 | \x3feffffffffffffa | t
- \x3feffffffffffffb |      0.9999999999999994 |      0.9999999999999994 | \x3feffffffffffffb | t
- \x3feffffffffffffc |      0.9999999999999996 |      0.9999999999999996 | \x3feffffffffffffc | t
- \x3feffffffffffffd |      0.9999999999999997 |      0.9999999999999997 | \x3feffffffffffffd | t
- \x3feffffffffffffe |      0.9999999999999998 |      0.9999999999999998 | \x3feffffffffffffe | t
- \x3fefffffffffffff |      0.9999999999999999 |      0.9999999999999999 | \x3fefffffffffffff | t
- \x3ff0000000000000 |                       1 |                       1 | \x3ff0000000000000 | t
- \x3ff0000000000001 |      1.0000000000000002 |      1.0000000000000002 | \x3ff0000000000001 | t
- \x3ff0000000000002 |      1.0000000000000004 |      1.0000000000000004 | \x3ff0000000000002 | t
- \x3ff0000000000003 |      1.0000000000000007 |      1.0000000000000007 | \x3ff0000000000003 | t
- \x3ff0000000000004 |      1.0000000000000009 |      1.0000000000000009 | \x3ff0000000000004 | t
- \x3ff0000000000005 |       1.000000000000001 |       1.000000000000001 | \x3ff0000000000005 | t
- \x3ff0000000000006 |      1.0000000000000013 |      1.0000000000000013 | \x3ff0000000000006 | t
- \x3ff0000000000007 |      1.0000000000000016 |      1.0000000000000016 | \x3ff0000000000007 | t
- \x3ff0000000000008 |      1.0000000000000018 |      1.0000000000000018 | \x3ff0000000000008 | t
- \x3ff0000000000009 |       1.000000000000002 |       1.000000000000002 | \x3ff0000000000009 | t
- \x3ff921fb54442d18 |      1.5707963267948966 |      1.5707963267948966 | \x3ff921fb54442d18 | t
- \x4005bf0a8b14576a |      2.7182818284590455 |      2.7182818284590455 | \x4005bf0a8b14576a | t
- \x400921fb54442d18 |       3.141592653589793 |       3.141592653589793 | \x400921fb54442d18 | t
- \x4023ffffffffffff |       9.999999999999998 |       9.999999999999998 | \x4023ffffffffffff | t
- \x4024000000000000 |                      10 |                      10 | \x4024000000000000 | t
- \x4024000000000001 |      10.000000000000002 |      10.000000000000002 | \x4024000000000001 | t
- \x4058ffffffffffff |       99.99999999999999 |       99.99999999999999 | \x4058ffffffffffff | t
- \x4059000000000000 |                     100 |                     100 | \x4059000000000000 | t
- \x4059000000000001 |      100.00000000000001 |      100.00000000000001 | \x4059000000000001 | t
- \x408f3fffffffffff |       999.9999999999999 |       999.9999999999999 | \x408f3fffffffffff | t
- \x408f400000000000 |                    1000 |                    1000 | \x408f400000000000 | t
- \x408f400000000001 |      1000.0000000000001 |      1000.0000000000001 | \x408f400000000001 | t
- \x40c387ffffffffff |       9999.999999999998 |       9999.999999999998 | \x40c387ffffffffff | t
- \x40c3880000000000 |                   10000 |                   10000 | \x40c3880000000000 | t
- \x40c3880000000001 |      10000.000000000002 |      10000.000000000002 | \x40c3880000000001 | t
- \x40f869ffffffffff |       99999.99999999999 |       99999.99999999999 | \x40f869ffffffffff | t
- \x40f86a0000000000 |                  100000 |                  100000 | \x40f86a0000000000 | t
- \x40f86a0000000001 |      100000.00000000001 |      100000.00000000001 | \x40f86a0000000001 | t
- \x412e847fffffffff |       999999.9999999999 |       999999.9999999999 | \x412e847fffffffff | t
- \x412e848000000000 |                 1000000 |                 1000000 | \x412e848000000000 | t
- \x412e848000000001 |      1000000.0000000001 |      1000000.0000000001 | \x412e848000000001 | t
- \x416312cfffffffff |       9999999.999999998 |       9999999.999999998 | \x416312cfffffffff | t
- \x416312d000000000 |                10000000 |                10000000 | \x416312d000000000 | t
- \x416312d000000001 |      10000000.000000002 |      10000000.000000002 | \x416312d000000001 | t
- \x4197d783ffffffff |       99999999.99999999 |       99999999.99999999 | \x4197d783ffffffff | t
- \x4197d78400000000 |               100000000 |               100000000 | \x4197d78400000000 | t
- \x4197d78400000001 |      100000000.00000001 |      100000000.00000001 | \x4197d78400000001 | t
- \x41cdcd64ffffffff |       999999999.9999999 |       999999999.9999999 | \x41cdcd64ffffffff | t
- \x41cdcd6500000000 |              1000000000 |              1000000000 | \x41cdcd6500000000 | t
- \x41cdcd6500000001 |      1000000000.0000001 |      1000000000.0000001 | \x41cdcd6500000001 | t
- \x4202a05f1fffffff |       9999999999.999998 |       9999999999.999998 | \x4202a05f1fffffff | t
- \x4202a05f20000000 |             10000000000 |             10000000000 | \x4202a05f20000000 | t
- \x4202a05f20000001 |      10000000000.000002 |      10000000000.000002 | \x4202a05f20000001 | t
- \x42374876e7ffffff |       99999999999.99998 |       99999999999.99998 | \x42374876e7ffffff | t
- \x42374876e8000000 |            100000000000 |            100000000000 | \x42374876e8000000 | t
- \x42374876e8000001 |      100000000000.00002 |      100000000000.00002 | \x42374876e8000001 | t
- \x426d1a94a1ffffff |       999999999999.9999 |       999999999999.9999 | \x426d1a94a1ffffff | t
- \x426d1a94a2000000 |           1000000000000 |           1000000000000 | \x426d1a94a2000000 | t
- \x426d1a94a2000001 |      1000000000000.0001 |      1000000000000.0001 | \x426d1a94a2000001 | t
- \x42a2309ce53fffff |       9999999999999.998 |       9999999999999.998 | \x42a2309ce53fffff | t
- \x42a2309ce5400000 |          10000000000000 |          10000000000000 | \x42a2309ce5400000 | t
- \x42a2309ce5400001 |      10000000000000.002 |      10000000000000.002 | \x42a2309ce5400001 | t
- \x42d6bcc41e8fffff |       99999999999999.98 |       99999999999999.98 | \x42d6bcc41e8fffff | t
- \x42d6bcc41e900000 |         100000000000000 |         100000000000000 | \x42d6bcc41e900000 | t
- \x42d6bcc41e900001 |      100000000000000.02 |      100000000000000.02 | \x42d6bcc41e900001 | t
- \x430c6bf52633ffff |       999999999999999.9 |       999999999999999.9 | \x430c6bf52633ffff | t
- \x430c6bf526340000 |                   1e+15 |                   1e+15 | \x430c6bf526340000 | t
- \x430c6bf526340001 |  1.0000000000000001e+15 |  1.0000000000000001e+15 | \x430c6bf526340001 | t
- \x4341c37937e07fff |   9.999999999999998e+15 |   9.999999999999998e+15 | \x4341c37937e07fff | t
- \x4341c37937e08000 |                   1e+16 |                   1e+16 | \x4341c37937e08000 | t
- \x4341c37937e08001 |  1.0000000000000002e+16 |  1.0000000000000002e+16 | \x4341c37937e08001 | t
- \x4376345785d89fff |   9.999999999999998e+16 |   9.999999999999998e+16 | \x4376345785d89fff | t
- \x4376345785d8a000 |                   1e+17 |                   1e+17 | \x4376345785d8a000 | t
- \x4376345785d8a001 |  1.0000000000000002e+17 |  1.0000000000000002e+17 | \x4376345785d8a001 | t
- \x43abc16d674ec7ff |   9.999999999999999e+17 |   9.999999999999999e+17 | \x43abc16d674ec7ff | t
- \x43abc16d674ec800 |                   1e+18 |                   1e+18 | \x43abc16d674ec800 | t
- \x43abc16d674ec801 |  1.0000000000000001e+18 |  1.0000000000000001e+18 | \x43abc16d674ec801 | t
- \x43e158e460913cff |   9.999999999999998e+18 |   9.999999999999998e+18 | \x43e158e460913cff | t
- \x43e158e460913d00 |                   1e+19 |                   1e+19 | \x43e158e460913d00 | t
- \x43e158e460913d01 |  1.0000000000000002e+19 |  1.0000000000000002e+19 | \x43e158e460913d01 | t
- \x4415af1d78b58c3f |   9.999999999999998e+19 |   9.999999999999998e+19 | \x4415af1d78b58c3f | t
- \x4415af1d78b58c40 |                   1e+20 |                   1e+20 | \x4415af1d78b58c40 | t
- \x4415af1d78b58c41 |  1.0000000000000002e+20 |  1.0000000000000002e+20 | \x4415af1d78b58c41 | t
- \x444b1ae4d6e2ef4f |   9.999999999999999e+20 |   9.999999999999999e+20 | \x444b1ae4d6e2ef4f | t
- \x444b1ae4d6e2ef50 |                   1e+21 |                   1e+21 | \x444b1ae4d6e2ef50 | t
- \x444b1ae4d6e2ef51 |  1.0000000000000001e+21 |  1.0000000000000001e+21 | \x444b1ae4d6e2ef51 | t
- \x4480f0cf064dd591 |   9.999999999999998e+21 |   9.999999999999998e+21 | \x4480f0cf064dd591 | t
- \x4480f0cf064dd592 |                   1e+22 |                   1e+22 | \x4480f0cf064dd592 | t
- \x4480f0cf064dd593 |  1.0000000000000002e+22 |  1.0000000000000002e+22 | \x4480f0cf064dd593 | t
- \x44b52d02c7e14af5 |   9.999999999999997e+22 |   9.999999999999997e+22 | \x44b52d02c7e14af5 | t
- \x44b52d02c7e14af6 |   9.999999999999999e+22 |   9.999999999999999e+22 | \x44b52d02c7e14af6 | t
- \x44b52d02c7e14af7 |  1.0000000000000001e+23 |  1.0000000000000001e+23 | \x44b52d02c7e14af7 | t
- \x44ea784379d99db3 |   9.999999999999998e+23 |   9.999999999999998e+23 | \x44ea784379d99db3 | t
- \x44ea784379d99db4 |                   1e+24 |                   1e+24 | \x44ea784379d99db4 | t
- \x44ea784379d99db5 |  1.0000000000000001e+24 |  1.0000000000000001e+24 | \x44ea784379d99db5 | t
- \x45208b2a2c280290 |   9.999999999999999e+24 |   9.999999999999999e+24 | \x45208b2a2c280290 | t
- \x45208b2a2c280291 |                   1e+25 |                   1e+25 | \x45208b2a2c280291 | t
- \x45208b2a2c280292 |  1.0000000000000003e+25 |  1.0000000000000003e+25 | \x45208b2a2c280292 | t
- \x7feffffffffffffe | 1.7976931348623155e+308 | 1.7976931348623155e+308 | \x7feffffffffffffe | t
- \x7fefffffffffffff | 1.7976931348623157e+308 | 1.7976931348623157e+308 | \x7fefffffffffffff | t
- \x4350000000000002 |  1.8014398509481992e+16 |  1.8014398509481992e+16 | \x4350000000000002 | t
- \x4350000000002e06 |  1.8014398509529112e+16 |  1.8014398509529112e+16 | \x4350000000002e06 | t
- \x4352000000000003 |  2.0266198323167244e+16 |  2.0266198323167244e+16 | \x4352000000000003 | t
- \x4352000000000004 |  2.0266198323167248e+16 |  2.0266198323167248e+16 | \x4352000000000004 | t
- \x4358000000000003 |  2.7021597764222988e+16 |  2.7021597764222988e+16 | \x4358000000000003 | t
- \x4358000000000004 |  2.7021597764222992e+16 |  2.7021597764222992e+16 | \x4358000000000004 | t
- \x435f000000000020 |  3.4902897112121472e+16 |  3.4902897112121472e+16 | \x435f000000000020 | t
- \xc350000000000002 | -1.8014398509481992e+16 | -1.8014398509481992e+16 | \xc350000000000002 | t
- \xc350000000002e06 | -1.8014398509529112e+16 | -1.8014398509529112e+16 | \xc350000000002e06 | t
- \xc352000000000003 | -2.0266198323167244e+16 | -2.0266198323167244e+16 | \xc352000000000003 | t
- \xc352000000000004 | -2.0266198323167248e+16 | -2.0266198323167248e+16 | \xc352000000000004 | t
- \xc358000000000003 | -2.7021597764222988e+16 | -2.7021597764222988e+16 | \xc358000000000003 | t
- \xc358000000000004 | -2.7021597764222992e+16 | -2.7021597764222992e+16 | \xc358000000000004 | t
- \xc35f000000000020 | -3.4902897112121472e+16 | -3.4902897112121472e+16 | \xc35f000000000020 | t
- \x42dc12218377de66 |       123456789012345.6 |       123456789012345.6 | \x42dc12218377de66 | t
- \x42a674e79c5fe51f |       12345678901234.56 |       12345678901234.56 | \x42a674e79c5fe51f | t
- \x4271f71fb04cb74c |       1234567890123.456 |       1234567890123.456 | \x4271f71fb04cb74c | t
- \x423cbe991a145879 |       123456789012.3456 |       123456789012.3456 | \x423cbe991a145879 | t
- \x4206fee0e1a9e061 |       12345678901.23456 |       12345678901.23456 | \x4206fee0e1a9e061 | t
- \x41d26580b487e6b4 |       1234567890.123456 |       1234567890.123456 | \x41d26580b487e6b4 | t
- \x419d6f34540ca453 |       123456789.0123456 |       123456789.0123456 | \x419d6f34540ca453 | t
- \x41678c29dcd6e9dc |       12345678.90123456 |       12345678.90123456 | \x41678c29dcd6e9dc | t
- \x4132d687e3df217d |       1234567.890123456 |       1234567.890123456 | \x4132d687e3df217d | t
- \x40fe240c9fcb68c8 |       123456.7890123456 |       123456.7890123456 | \x40fe240c9fcb68c8 | t
- \x40c81cd6e63c53d3 |       12345.67890123456 |       12345.67890123456 | \x40c81cd6e63c53d3 | t
- \x40934a4584fd0fdc |       1234.567890123456 |       1234.567890123456 | \x40934a4584fd0fdc | t
- \x405edd3c07fb4c93 |       123.4567890123456 |       123.4567890123456 | \x405edd3c07fb4c93 | t
- \x4028b0fcd32f7076 |       12.34567890123456 |       12.34567890123456 | \x4028b0fcd32f7076 | t
- \x3ff3c0ca428c59f8 |       1.234567890123456 |       1.234567890123456 | \x3ff3c0ca428c59f8 | t
- \x3e60000000000000 |  2.9802322387695312e-08 |  2.9802322387695312e-08 | \x3e60000000000000 | t
- \xc352bd2668e077c4 | -2.1098088986959632e+16 | -2.1098088986959632e+16 | \xc352bd2668e077c4 | t
- \x434018601510c000 |     9.0608011534336e+15 |     9.0608011534336e+15 | \x434018601510c000 | t
- \x43d055dc36f24000 |   4.708356024711512e+18 |   4.708356024711512e+18 | \x43d055dc36f24000 | t
- \x43e052961c6f8000 |   9.409340012568248e+18 |   9.409340012568248e+18 | \x43e052961c6f8000 | t
- \x3ff3c0ca2a5b1d5d |               1.2345678 |               1.2345678 | \x3ff3c0ca2a5b1d5d | t
- \x4830f0cf064dd592 |   5.764607523034235e+39 |   5.764607523034235e+39 | \x4830f0cf064dd592 | t
- \x4840f0cf064dd592 |   1.152921504606847e+40 |   1.152921504606847e+40 | \x4840f0cf064dd592 | t
- \x4850f0cf064dd592 |   2.305843009213694e+40 |   2.305843009213694e+40 | \x4850f0cf064dd592 | t
- \x3ff3333333333333 |                     1.2 |                     1.2 | \x3ff3333333333333 | t
- \x3ff3ae147ae147ae |                    1.23 |                    1.23 | \x3ff3ae147ae147ae | t
- \x3ff3be76c8b43958 |                   1.234 |                   1.234 | \x3ff3be76c8b43958 | t
- \x3ff3c083126e978d |                  1.2345 |                  1.2345 | \x3ff3c083126e978d | t
- \x3ff3c0c1fc8f3238 |                 1.23456 |                 1.23456 | \x3ff3c0c1fc8f3238 | t
- \x3ff3c0c9539b8887 |                1.234567 |                1.234567 | \x3ff3c0c9539b8887 | t
- \x3ff3c0ca2a5b1d5d |               1.2345678 |               1.2345678 | \x3ff3c0ca2a5b1d5d | t
- \x3ff3c0ca4283de1b |              1.23456789 |              1.23456789 | \x3ff3c0ca4283de1b | t
- \x3ff3c0ca43db770a |             1.234567895 |             1.234567895 | \x3ff3c0ca43db770a | t
- \x3ff3c0ca428abd53 |            1.2345678901 |            1.2345678901 | \x3ff3c0ca428abd53 | t
- \x3ff3c0ca428c1d2b |           1.23456789012 |           1.23456789012 | \x3ff3c0ca428c1d2b | t
- \x3ff3c0ca428c51f2 |          1.234567890123 |          1.234567890123 | \x3ff3c0ca428c51f2 | t
- \x3ff3c0ca428c58fc |         1.2345678901234 |         1.2345678901234 | \x3ff3c0ca428c58fc | t
- \x3ff3c0ca428c59dd |        1.23456789012345 |        1.23456789012345 | \x3ff3c0ca428c59dd | t
- \x3ff3c0ca428c59f8 |       1.234567890123456 |       1.234567890123456 | \x3ff3c0ca428c59f8 | t
- \x3ff3c0ca428c59fb |      1.2345678901234567 |      1.2345678901234567 | \x3ff3c0ca428c59fb | t
- \x40112e0be8047a7d |             4.294967294 |             4.294967294 | \x40112e0be8047a7d | t
- \x40112e0be815a889 |             4.294967295 |             4.294967295 | \x40112e0be815a889 | t
- \x40112e0be826d695 |             4.294967296 |             4.294967296 | \x40112e0be826d695 | t
- \x40112e0be83804a1 |             4.294967297 |             4.294967297 | \x40112e0be83804a1 | t
- \x40112e0be84932ad |             4.294967298 |             4.294967298 | \x40112e0be84932ad | t
- \x0040000000000000 | 1.7800590868057611e-307 | 1.7800590868057611e-307 | \x0040000000000000 | t
- \x007fffffffffffff | 2.8480945388892175e-306 | 2.8480945388892175e-306 | \x007fffffffffffff | t
- \x0290000000000000 |  2.446494580089078e-296 |  2.446494580089078e-296 | \x0290000000000000 | t
- \x029fffffffffffff | 4.8929891601781557e-296 | 4.8929891601781557e-296 | \x029fffffffffffff | t
- \x4350000000000000 |  1.8014398509481984e+16 |  1.8014398509481984e+16 | \x4350000000000000 | t
- \x435fffffffffffff |  3.6028797018963964e+16 |  3.6028797018963964e+16 | \x435fffffffffffff | t
- \x1330000000000000 |  2.900835519859558e-216 |  2.900835519859558e-216 | \x1330000000000000 | t
- \x133fffffffffffff |  5.801671039719115e-216 |  5.801671039719115e-216 | \x133fffffffffffff | t
- \x3a6fa7161a4d6e0c |   3.196104012172126e-27 |   3.196104012172126e-27 | \x3a6fa7161a4d6e0c | t
-(209 rows)
-
+ERROR:  clapdb doesn't support CTE currently
 -- clean up, lest opr_sanity complain
 drop type xfloat8 cascade;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to function xfloat8in(cstring)
-drop cascades to function xfloat8out(xfloat8)
-drop cascades to cast from xfloat8 to double precision
-drop cascades to cast from double precision to xfloat8
-drop cascades to cast from xfloat8 to bigint
-drop cascades to cast from bigint to xfloat8
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/date.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/date.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/date.out	2024-03-25 11:16:04.668340592 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/date.out	2024-04-12 10:24:16.631947662 +0800
@@ -10,7 +10,7 @@
 INSERT INTO DATE_TBL VALUES ('1996-03-02');
 INSERT INTO DATE_TBL VALUES ('1997-02-28');
 INSERT INTO DATE_TBL VALUES ('1997-02-29');
-ERROR:  date/time field value out of range: "1997-02-29"
+ERROR:  invalid input syntax for type date: "1997-02-29"
 INSERT INTO DATE_TBL VALUES ('1997-03-01');
 INSERT INTO DATE_TBL VALUES ('1997-03-02');
 INSERT INTO DATE_TBL VALUES ('2000-04-01');
@@ -21,6 +21,7 @@
 INSERT INTO DATE_TBL VALUES ('2040-04-10');
 INSERT INTO DATE_TBL VALUES ('2040-04-10 BC');
 SET datestyle TO iso;  -- display results in ISO
+ERROR:  only support select and create table statement
 SELECT f1 FROM DATE_TBL order by 1;
       f1       
 ---------------
@@ -70,93 +71,73 @@
 -- Check all the documented input formats
 --
 SET datestyle TO iso;  -- display results in ISO
+ERROR:  only support select and create table statement
 SET datestyle TO ymd;
+ERROR:  only support select and create table statement
 SELECT date 'January 8, 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "January 8, 1999"
 SELECT date '1999-01-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '1999-01-18';
-    date    
+  ?column?  
 ------------
  1999-01-18
 (1 row)
 
 SELECT date '1/8/1999';
-ERROR:  date/time field value out of range: "1/8/1999"
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '1/18/1999';
-ERROR:  date/time field value out of range: "1/18/1999"
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '18/1/1999';
-ERROR:  date/time field value out of range: "18/1/1999"
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '01/02/03';
-    date    
-------------
- 2001-02-03
-(1 row)
-
-SELECT date '19990108';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
-SELECT date '990108';
-    date    
+SELECT date '1/18/1999';
+  ?column?  
 ------------
- 1999-01-08
+ 1999-01-18
 (1 row)
 
-SELECT date '1999.008';
-    date    
+SELECT date '18/1/1999';
+  ?column?  
 ------------
- 1999-01-08
+ 1999-01-18
 (1 row)
 
+SELECT date '01/02/03';
+ERROR:  invalid input syntax for type date: "01/02/03"
+SELECT date '19990108';
+ERROR:  invalid input syntax for type date: "19990108"
+SELECT date '990108';
+ERROR:  invalid input syntax for type date: "990108"
+SELECT date '1999.008';
+ERROR:  invalid input syntax for type date: "1999.008"
 SELECT date 'J2451187';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "J2451187"
 SELECT date 'January 8, 99 BC';
-ERROR:  date/time field value out of range: "January 8, 99 BC"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "January 8, 99 BC"
 SELECT date '99-Jan-08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "99-Jan-08"
 SELECT date '1999-Jan-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '08-Jan-99';
-ERROR:  date/time field value out of range: "08-Jan-99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "08-Jan-99"
 SELECT date '08-Jan-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date 'Jan-08-99';
-ERROR:  date/time field value out of range: "Jan-08-99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "Jan-08-99"
 SELECT date 'Jan-08-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
@@ -166,218 +147,135 @@
 SELECT date '1999-08-Jan';
 ERROR:  invalid input syntax for type date: "1999-08-Jan"
 SELECT date '99 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "99 Jan 08"
 SELECT date '1999 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 Jan 08"
 SELECT date '08 Jan 99';
-ERROR:  date/time field value out of range: "08 Jan 99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "08 Jan 99"
 SELECT date '08 Jan 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 Jan 1999"
 SELECT date 'Jan 08 99';
-ERROR:  date/time field value out of range: "Jan 08 99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "Jan 08 99"
 SELECT date 'Jan 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan 08 1999"
 SELECT date '99 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "99 08 Jan"
 SELECT date '1999 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 08 Jan"
 SELECT date '99-01-08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "99-01-08"
 SELECT date '1999-01-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '08-01-99';
-ERROR:  date/time field value out of range: "08-01-99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "08-01-99"
 SELECT date '08-01-1999';
-ERROR:  date/time field value out of range: "08-01-1999"
-HINT:  Perhaps you need a different "datestyle" setting.
+  ?column?  
+------------
+ 1999-08-01
+(1 row)
+
 SELECT date '01-08-99';
-ERROR:  date/time field value out of range: "01-08-99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "01-08-99"
 SELECT date '01-08-1999';
-ERROR:  date/time field value out of range: "01-08-1999"
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '99-08-01';
-    date    
+  ?column?  
 ------------
- 1999-08-01
+ 1999-01-08
 (1 row)
 
+SELECT date '99-08-01';
+ERROR:  invalid input syntax for type date: "99-08-01"
 SELECT date '1999-08-01';
-    date    
+  ?column?  
 ------------
  1999-08-01
 (1 row)
 
 SELECT date '99 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "99 01 08"
 SELECT date '1999 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 01 08"
 SELECT date '08 01 99';
-ERROR:  date/time field value out of range: "08 01 99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "08 01 99"
 SELECT date '08 01 1999';
-ERROR:  date/time field value out of range: "08 01 1999"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "08 01 1999"
 SELECT date '01 08 99';
-ERROR:  date/time field value out of range: "01 08 99"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "01 08 99"
 SELECT date '01 08 1999';
-ERROR:  date/time field value out of range: "01 08 1999"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "01 08 1999"
 SELECT date '99 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "99 08 01"
 SELECT date '1999 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 08 01"
 SET datestyle TO dmy;
+ERROR:  only support select and create table statement
 SELECT date 'January 8, 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "January 8, 1999"
 SELECT date '1999-01-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '1999-01-18';
-    date    
+  ?column?  
 ------------
  1999-01-18
 (1 row)
 
 SELECT date '1/8/1999';
-    date    
+  ?column?  
 ------------
- 1999-08-01
+ 1999-01-08
 (1 row)
 
 SELECT date '1/18/1999';
-ERROR:  date/time field value out of range: "1/18/1999"
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '18/1/1999';
-    date    
+  ?column?  
 ------------
  1999-01-18
 (1 row)
 
-SELECT date '01/02/03';
-    date    
+SELECT date '18/1/1999';
+  ?column?  
 ------------
- 2003-02-01
+ 1999-01-18
 (1 row)
 
+SELECT date '01/02/03';
+ERROR:  invalid input syntax for type date: "01/02/03"
 SELECT date '19990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "19990108"
 SELECT date '990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "990108"
 SELECT date '1999.008';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999.008"
 SELECT date 'J2451187';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "J2451187"
 SELECT date 'January 8, 99 BC';
-     date      
----------------
- 0099-01-08 BC
-(1 row)
-
+ERROR:  invalid input syntax for type date: "January 8, 99 BC"
 SELECT date '99-Jan-08';
-ERROR:  date/time field value out of range: "99-Jan-08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99-Jan-08"
 SELECT date '1999-Jan-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '08-Jan-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08-Jan-99"
 SELECT date '08-Jan-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date 'Jan-08-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan-08-99"
 SELECT date 'Jan-08-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
@@ -387,229 +285,135 @@
 SELECT date '1999-08-Jan';
 ERROR:  invalid input syntax for type date: "1999-08-Jan"
 SELECT date '99 Jan 08';
-ERROR:  date/time field value out of range: "99 Jan 08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99 Jan 08"
 SELECT date '1999 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 Jan 08"
 SELECT date '08 Jan 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 Jan 99"
 SELECT date '08 Jan 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 Jan 1999"
 SELECT date 'Jan 08 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan 08 99"
 SELECT date 'Jan 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan 08 1999"
 SELECT date '99 08 Jan';
 ERROR:  invalid input syntax for type date: "99 08 Jan"
 SELECT date '1999 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 08 Jan"
 SELECT date '99-01-08';
-ERROR:  date/time field value out of range: "99-01-08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99-01-08"
 SELECT date '1999-01-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '08-01-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08-01-99"
 SELECT date '08-01-1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
-SELECT date '01-08-99';
-    date    
+  ?column?  
 ------------
  1999-08-01
 (1 row)
 
+SELECT date '01-08-99';
+ERROR:  invalid input syntax for type date: "01-08-99"
 SELECT date '01-08-1999';
-    date    
+  ?column?  
 ------------
- 1999-08-01
+ 1999-01-08
 (1 row)
 
 SELECT date '99-08-01';
-ERROR:  date/time field value out of range: "99-08-01"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99-08-01"
 SELECT date '1999-08-01';
-    date    
+  ?column?  
 ------------
  1999-08-01
 (1 row)
 
 SELECT date '99 01 08';
-ERROR:  date/time field value out of range: "99 01 08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99 01 08"
 SELECT date '1999 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 01 08"
 SELECT date '08 01 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 01 99"
 SELECT date '08 01 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 01 1999"
 SELECT date '01 08 99';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "01 08 99"
 SELECT date '01 08 1999';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "01 08 1999"
 SELECT date '99 08 01';
-ERROR:  date/time field value out of range: "99 08 01"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99 08 01"
 SELECT date '1999 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 08 01"
 SET datestyle TO mdy;
+ERROR:  only support select and create table statement
 SELECT date 'January 8, 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "January 8, 1999"
 SELECT date '1999-01-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '1999-01-18';
-    date    
+  ?column?  
 ------------
  1999-01-18
 (1 row)
 
 SELECT date '1/8/1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '1/18/1999';
-    date    
+  ?column?  
 ------------
  1999-01-18
 (1 row)
 
 SELECT date '18/1/1999';
-ERROR:  date/time field value out of range: "18/1/1999"
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '01/02/03';
-    date    
+  ?column?  
 ------------
- 2003-01-02
+ 1999-01-18
 (1 row)
 
+SELECT date '01/02/03';
+ERROR:  invalid input syntax for type date: "01/02/03"
 SELECT date '19990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "19990108"
 SELECT date '990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "990108"
 SELECT date '1999.008';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999.008"
 SELECT date 'J2451187';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "J2451187"
 SELECT date 'January 8, 99 BC';
-     date      
----------------
- 0099-01-08 BC
-(1 row)
-
+ERROR:  invalid input syntax for type date: "January 8, 99 BC"
 SELECT date '99-Jan-08';
-ERROR:  date/time field value out of range: "99-Jan-08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99-Jan-08"
 SELECT date '1999-Jan-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '08-Jan-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08-Jan-99"
 SELECT date '08-Jan-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date 'Jan-08-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan-08-99"
 SELECT date 'Jan-08-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
@@ -621,149 +425,89 @@
 SELECT date '99 Jan 08';
 ERROR:  invalid input syntax for type date: "99 Jan 08"
 SELECT date '1999 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 Jan 08"
 SELECT date '08 Jan 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 Jan 99"
 SELECT date '08 Jan 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 Jan 1999"
 SELECT date 'Jan 08 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan 08 99"
 SELECT date 'Jan 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "Jan 08 1999"
 SELECT date '99 08 Jan';
 ERROR:  invalid input syntax for type date: "99 08 Jan"
 SELECT date '1999 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 08 Jan"
 SELECT date '99-01-08';
-ERROR:  date/time field value out of range: "99-01-08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99-01-08"
 SELECT date '1999-01-08';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '08-01-99';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08-01-99"
 SELECT date '08-01-1999';
-    date    
+  ?column?  
 ------------
  1999-08-01
 (1 row)
 
 SELECT date '01-08-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "01-08-99"
 SELECT date '01-08-1999';
-    date    
+  ?column?  
 ------------
  1999-01-08
 (1 row)
 
 SELECT date '99-08-01';
-ERROR:  date/time field value out of range: "99-08-01"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99-08-01"
 SELECT date '1999-08-01';
-    date    
+  ?column?  
 ------------
  1999-08-01
 (1 row)
 
 SELECT date '99 01 08';
-ERROR:  date/time field value out of range: "99 01 08"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99 01 08"
 SELECT date '1999 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 01 08"
 SELECT date '08 01 99';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 01 99"
 SELECT date '08 01 1999';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "08 01 1999"
 SELECT date '01 08 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "01 08 99"
 SELECT date '01 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid input syntax for type date: "01 08 1999"
 SELECT date '99 08 01';
-ERROR:  date/time field value out of range: "99 08 01"
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid input syntax for type date: "99 08 01"
 SELECT date '1999 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid input syntax for type date: "1999 08 01"
 -- Check upper and lower limits of date range
 SELECT date '4714-11-24 BC';
-     date      
+   ?column?    
 ---------------
  4714-11-24 BC
 (1 row)
 
 SELECT date '4714-11-23 BC';  -- out of range
-ERROR:  date out of range: "4714-11-23 BC"
-SELECT date '5874897-12-31';
-     date      
+   ?column?    
 ---------------
- 5874897-12-31
+ 4714-11-23 BC
 (1 row)
 
+SELECT date '5874897-12-31';
+ERROR:  invalid input syntax for type date: "5874897-12-31"
 SELECT date '5874898-01-01';  -- out of range
-ERROR:  date out of range: "5874898-01-01"
+ERROR:  invalid input syntax for type date: "5874898-01-01"
 -- Test non-error-throwing API
 SELECT pg_input_is_valid('now', 'date');
  pg_input_is_valid 
 -------------------
- t
+ f
 (1 row)
 
 SELECT pg_input_is_valid('garbage', 'date');
@@ -779,100 +523,50 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('garbage', 'date');
-                    message                    | detail | hint | sql_error_code 
------------------------------------------------+--------+------+----------------
- invalid input syntax for type date: "garbage" |        |      | 22007
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('6874898-01-01', 'date');
-              message               | detail | hint | sql_error_code 
-------------------------------------+--------+------+----------------
- date out of range: "6874898-01-01" |        |      | 22008
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SET datestyle TO iso;  -- display results in ISO
+ERROR:  only support select and create table statement
 --
 -- Simple math
 -- Leave most of it for the horology tests
 --
 SELECT f1 - date '2000-01-01' AS "Days From 2K" FROM DATE_TBL order by 1;
- Days From 2K 
---------------
-     -1475115
-       -15607
-       -15542
-        -1403
-        -1402
-        -1401
-        -1400
-        -1037
-        -1036
-        -1035
-           91
-           92
-           93
-        13977
-        14343
-        14710
+ Days From 2K  
+---------------
+ -1475115 days
+ -15607 days
+ -15542 days
+ -1403 days
+ -1402 days
+ -1401 days
+ -1400 days
+ -1037 days
+ -1036 days
+ -1035 days
+ 91 days
+ 92 days
+ 93 days
+ 13977 days
+ 14343 days
+ 14710 days
 (16 rows)
 
 SELECT f1 - date 'epoch' AS "Days From Epoch" FROM DATE_TBL order by 1;
- Days From Epoch 
------------------
-        -1464158
-           -4650
-           -4585
-            9554
-            9555
-            9556
-            9557
-            9920
-            9921
-            9922
-           11048
-           11049
-           11050
-           24934
-           25300
-           25667
-(16 rows)
-
+ERROR:  invalid input syntax for type date: "epoch"
 SELECT date 'yesterday' - date 'today' AS "One day";
- One day 
----------
-      -1
-(1 row)
-
+ERROR:  invalid input syntax for type date: "yesterday"
 SELECT date 'today' - date 'tomorrow' AS "One day";
- One day 
----------
-      -1
-(1 row)
-
+ERROR:  invalid input syntax for type date: "today"
 SELECT date 'yesterday' - date 'tomorrow' AS "Two days";
- Two days 
-----------
-       -2
-(1 row)
-
+ERROR:  invalid input syntax for type date: "yesterday"
 SELECT date 'tomorrow' - date 'today' AS "One day";
- One day 
----------
-       1
-(1 row)
-
+ERROR:  invalid input syntax for type date: "tomorrow"
 SELECT date 'today' - date 'yesterday' AS "One day";
- One day 
----------
-       1
-(1 row)
-
+ERROR:  invalid input syntax for type date: "today"
 SELECT date 'tomorrow' - date 'yesterday' AS "Two days";
- Two days 
-----------
-        2
-(1 row)
-
+ERROR:  invalid input syntax for type date: "tomorrow"
 --
 -- test extract!
 --
@@ -892,90 +586,67 @@
     date_part('julian', f1) AS julian,
     date_part('epoch', f1) AS epoch
     FROM date_tbl order by 1;
-     date      | year  | month | day | quarter | decade | century | millennium | isoyear | week | dow | isodow | doy | julian  |     epoch     
----------------+-------+-------+-----+---------+--------+---------+------------+---------+------+-----+--------+-----+---------+---------------
- 2040-04-10 BC | -2040 |     4 |  10 |       2 |   -204 |     -21 |         -3 |   -2040 |   15 |   1 |      1 | 100 |  976430 | -126503251200
- 1957-04-09    |  1957 |     4 |   9 |       2 |    195 |      20 |          2 |    1957 |   15 |   2 |      2 |  99 | 2435938 |    -401760000
- 1957-06-13    |  1957 |     6 |  13 |       2 |    195 |      20 |          2 |    1957 |   24 |   4 |      4 | 164 | 2436003 |    -396144000
- 1996-02-28    |  1996 |     2 |  28 |       1 |    199 |      20 |          2 |    1996 |    9 |   3 |      3 |  59 | 2450142 |     825465600
- 1996-02-29    |  1996 |     2 |  29 |       1 |    199 |      20 |          2 |    1996 |    9 |   4 |      4 |  60 | 2450143 |     825552000
- 1996-03-01    |  1996 |     3 |   1 |       1 |    199 |      20 |          2 |    1996 |    9 |   5 |      5 |  61 | 2450144 |     825638400
- 1996-03-02    |  1996 |     3 |   2 |       1 |    199 |      20 |          2 |    1996 |    9 |   6 |      6 |  62 | 2450145 |     825724800
- 1997-02-28    |  1997 |     2 |  28 |       1 |    199 |      20 |          2 |    1997 |    9 |   5 |      5 |  59 | 2450508 |     857088000
- 1997-03-01    |  1997 |     3 |   1 |       1 |    199 |      20 |          2 |    1997 |    9 |   6 |      6 |  60 | 2450509 |     857174400
- 1997-03-02    |  1997 |     3 |   2 |       1 |    199 |      20 |          2 |    1997 |    9 |   0 |      7 |  61 | 2450510 |     857260800
- 2000-04-01    |  2000 |     4 |   1 |       2 |    200 |      20 |          2 |    2000 |   13 |   6 |      6 |  92 | 2451636 |     954547200
- 2000-04-02    |  2000 |     4 |   2 |       2 |    200 |      20 |          2 |    2000 |   13 |   0 |      7 |  93 | 2451637 |     954633600
- 2000-04-03    |  2000 |     4 |   3 |       2 |    200 |      20 |          2 |    2000 |   14 |   1 |      1 |  94 | 2451638 |     954720000
- 2038-04-08    |  2038 |     4 |   8 |       2 |    203 |      21 |          3 |    2038 |   14 |   4 |      4 |  98 | 2465522 |    2154297600
- 2039-04-09    |  2039 |     4 |   9 |       2 |    203 |      21 |          3 |    2039 |   14 |   6 |      6 |  99 | 2465888 |    2185920000
- 2040-04-10    |  2040 |     4 |  10 |       2 |    204 |      21 |          3 |    2040 |   15 |   2 |      2 | 101 | 2466255 |    2217628800
-(16 rows)
-
+ERROR:  timestamp units "quarter" not recognized
 --
 -- epoch
 --
 SELECT EXTRACT(EPOCH FROM DATE        '1970-01-01');     --  0
- extract 
----------
-       0
-(1 row)
-
+ERROR:  timestamp units "epoch" not recognized
 --
 -- century
 --
 SELECT EXTRACT(CENTURY FROM DATE '0101-12-31 BC'); -- -2
- extract 
----------
-      -2
+ date_part 
+-----------
+        -2
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '0100-12-31 BC'); -- -1
- extract 
----------
-      -1
+ date_part 
+-----------
+        -1
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC'); -- -1
- extract 
----------
-      -1
+ date_part 
+-----------
+        -1
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '0001-01-01');    --  1
- extract 
----------
-       1
+ date_part 
+-----------
+         1
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD'); --  1
- extract 
----------
-       1
+ date_part 
+-----------
+         1
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '1900-12-31');    -- 19
- extract 
----------
-      19
+ date_part 
+-----------
+        19
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '1901-01-01');    -- 20
- extract 
----------
-      20
+ date_part 
+-----------
+        20
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '2000-12-31');    -- 20
- extract 
----------
-      20
+ date_part 
+-----------
+        20
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM DATE '2001-01-01');    -- 21
- extract 
----------
-      21
+ date_part 
+-----------
+        21
 (1 row)
 
 SELECT EXTRACT(CENTURY FROM CURRENT_DATE)>=21 AS True;     -- true
@@ -988,220 +659,196 @@
 -- millennium
 --
 SELECT EXTRACT(MILLENNIUM FROM DATE '0001-12-31 BC'); -- -1
- extract 
----------
-      -1
+ date_part 
+-----------
+        -1
 (1 row)
 
 SELECT EXTRACT(MILLENNIUM FROM DATE '0001-01-01 AD'); --  1
- extract 
----------
-       1
+ date_part 
+-----------
+         1
 (1 row)
 
 SELECT EXTRACT(MILLENNIUM FROM DATE '1000-12-31');    --  1
- extract 
----------
-       1
+ date_part 
+-----------
+         1
 (1 row)
 
 SELECT EXTRACT(MILLENNIUM FROM DATE '1001-01-01');    --  2
- extract 
----------
-       2
+ date_part 
+-----------
+         2
 (1 row)
 
 SELECT EXTRACT(MILLENNIUM FROM DATE '2000-12-31');    --  2
- extract 
----------
-       2
+ date_part 
+-----------
+         2
 (1 row)
 
 SELECT EXTRACT(MILLENNIUM FROM DATE '2001-01-01');    --  3
- extract 
----------
-       3
+ date_part 
+-----------
+         3
 (1 row)
 
 -- next test to be fixed on the turn of the next millennium;-)
 SELECT EXTRACT(MILLENNIUM FROM CURRENT_DATE);         --  3
- extract 
----------
-       3
+ date_part 
+-----------
+         3
 (1 row)
 
 --
 -- decade
 --
 SELECT EXTRACT(DECADE FROM DATE '1994-12-25');    -- 199
- extract 
----------
-     199
+ date_part 
+-----------
+       199
 (1 row)
 
 SELECT EXTRACT(DECADE FROM DATE '0010-01-01');    --   1
- extract 
----------
-       1
+ date_part 
+-----------
+         1
 (1 row)
 
 SELECT EXTRACT(DECADE FROM DATE '0009-12-31');    --   0
- extract 
----------
-       0
+ date_part 
+-----------
+         0
 (1 row)
 
 SELECT EXTRACT(DECADE FROM DATE '0001-01-01 BC'); --   0
- extract 
----------
-       0
+ date_part 
+-----------
+         0
 (1 row)
 
 SELECT EXTRACT(DECADE FROM DATE '0002-12-31 BC'); --  -1
- extract 
----------
-      -1
+ date_part 
+-----------
+        -1
 (1 row)
 
 SELECT EXTRACT(DECADE FROM DATE '0011-01-01 BC'); --  -1
- extract 
----------
-      -1
+ date_part 
+-----------
+        -1
 (1 row)
 
 SELECT EXTRACT(DECADE FROM DATE '0012-12-31 BC'); --  -2
- extract 
----------
-      -2
+ date_part 
+-----------
+        -2
 (1 row)
 
 --
 -- all possible fields
 --
 SELECT EXTRACT(MICROSECONDS  FROM DATE '2020-08-11');
-ERROR:  unit "microseconds" not supported for type date
+ date_part 
+-----------
+         0
+(1 row)
+
 SELECT EXTRACT(MILLISECONDS  FROM DATE '2020-08-11');
-ERROR:  unit "milliseconds" not supported for type date
+ date_part 
+-----------
+         0
+(1 row)
+
 SELECT EXTRACT(SECOND        FROM DATE '2020-08-11');
-ERROR:  unit "second" not supported for type date
+ date_part 
+-----------
+         0
+(1 row)
+
 SELECT EXTRACT(MINUTE        FROM DATE '2020-08-11');
-ERROR:  unit "minute" not supported for type date
+ date_part 
+-----------
+         0
+(1 row)
+
 SELECT EXTRACT(HOUR          FROM DATE '2020-08-11');
-ERROR:  unit "hour" not supported for type date
+ date_part 
+-----------
+         0
+(1 row)
+
 SELECT EXTRACT(DAY           FROM DATE '2020-08-11');
- extract 
----------
-      11
+ date_part 
+-----------
+        11
 (1 row)
 
 SELECT EXTRACT(MONTH         FROM DATE '2020-08-11');
- extract 
----------
-       8
+ date_part 
+-----------
+         8
 (1 row)
 
 SELECT EXTRACT(YEAR          FROM DATE '2020-08-11');
- extract 
----------
-    2020
+ date_part 
+-----------
+      2020
 (1 row)
 
 SELECT EXTRACT(YEAR          FROM DATE '2020-08-11 BC');
- extract 
----------
-   -2020
+ date_part 
+-----------
+     -2020
 (1 row)
 
 SELECT EXTRACT(DECADE        FROM DATE '2020-08-11');
- extract 
----------
-     202
+ date_part 
+-----------
+       202
 (1 row)
 
 SELECT EXTRACT(CENTURY       FROM DATE '2020-08-11');
- extract 
----------
-      21
+ date_part 
+-----------
+        21
 (1 row)
 
 SELECT EXTRACT(MILLENNIUM    FROM DATE '2020-08-11');
- extract 
----------
-       3
+ date_part 
+-----------
+         3
 (1 row)
 
 SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11');
- extract 
----------
-    2020
-(1 row)
-
+ERROR:  timestamp units "isoyear" not recognized
 SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11 BC');
- extract 
----------
-   -2020
-(1 row)
-
+ERROR:  timestamp units "isoyear" not recognized
 SELECT EXTRACT(QUARTER       FROM DATE '2020-08-11');
- extract 
----------
-       3
-(1 row)
-
+ERROR:  timestamp units "quarter" not recognized
 SELECT EXTRACT(WEEK          FROM DATE '2020-08-11');
- extract 
----------
-      33
-(1 row)
-
+ERROR:  timestamp units "week" not recognized
 SELECT EXTRACT(DOW           FROM DATE '2020-08-11');
- extract 
----------
-       2
-(1 row)
-
+ERROR:  timestamp units "dow" not recognized
 SELECT EXTRACT(DOW           FROM DATE '2020-08-16');
- extract 
----------
-       0
-(1 row)
-
+ERROR:  timestamp units "dow" not recognized
 SELECT EXTRACT(ISODOW        FROM DATE '2020-08-11');
- extract 
----------
-       2
-(1 row)
-
+ERROR:  timestamp units "isodow" not recognized
 SELECT EXTRACT(ISODOW        FROM DATE '2020-08-16');
- extract 
----------
-       7
-(1 row)
-
+ERROR:  timestamp units "isodow" not recognized
 SELECT EXTRACT(DOY           FROM DATE '2020-08-11');
- extract 
----------
-     224
-(1 row)
-
+ERROR:  timestamp units "doy" not recognized
 SELECT EXTRACT(TIMEZONE      FROM DATE '2020-08-11');
-ERROR:  unit "timezone" not supported for type date
+ERROR:  timestamp units "timezone" not recognized
 SELECT EXTRACT(TIMEZONE_M    FROM DATE '2020-08-11');
-ERROR:  unit "timezone_m" not supported for type date
+ERROR:  timestamp units "timezone_m" not recognized
 SELECT EXTRACT(TIMEZONE_H    FROM DATE '2020-08-11');
-ERROR:  unit "timezone_h" not supported for type date
+ERROR:  timestamp units "timezone_h" not recognized
 SELECT EXTRACT(EPOCH         FROM DATE '2020-08-11');
-  extract   
-------------
- 1597104000
-(1 row)
-
+ERROR:  timestamp units "epoch" not recognized
 SELECT EXTRACT(JULIAN        FROM DATE '2020-08-11');
- extract 
----------
- 2459073
-(1 row)
-
+ERROR:  timestamp units "julian" not recognized
 --
 -- test trunc function!
 --
@@ -1212,9 +859,9 @@
 (1 row)
 
 SELECT DATE_TRUNC('MILLENNIUM', DATE '1970-03-20'); -- 1001-01-01
-       date_trunc       
-------------------------
- 1001-01-01 00:00:00-08
+     date_trunc      
+---------------------
+ 1001-01-01 00:00:00
 (1 row)
 
 SELECT DATE_TRUNC('CENTURY', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1901
@@ -1224,201 +871,109 @@
 (1 row)
 
 SELECT DATE_TRUNC('CENTURY', DATE '1970-03-20'); -- 1901
-       date_trunc       
-------------------------
- 1901-01-01 00:00:00-08
+     date_trunc      
+---------------------
+ 1901-01-01 00:00:00
 (1 row)
 
 SELECT DATE_TRUNC('CENTURY', DATE '2004-08-10'); -- 2001-01-01
-       date_trunc       
-------------------------
- 2001-01-01 00:00:00-08
+     date_trunc      
+---------------------
+ 2001-01-01 00:00:00
 (1 row)
 
 SELECT DATE_TRUNC('CENTURY', DATE '0002-02-04'); -- 0001-01-01
-       date_trunc       
-------------------------
- 0001-01-01 00:00:00-08
+     date_trunc      
+---------------------
+ 0001-01-01 00:00:00
 (1 row)
 
 SELECT DATE_TRUNC('CENTURY', DATE '0055-08-10 BC'); -- 0100-01-01 BC
-        date_trunc         
----------------------------
- 0100-01-01 00:00:00-08 BC
+       date_trunc       
+------------------------
+ 0100-01-01 00:00:00 BC
 (1 row)
 
 SELECT DATE_TRUNC('DECADE', DATE '1993-12-25'); -- 1990-01-01
-       date_trunc       
-------------------------
- 1990-01-01 00:00:00-08
+     date_trunc      
+---------------------
+ 1990-01-01 00:00:00
 (1 row)
 
 SELECT DATE_TRUNC('DECADE', DATE '0004-12-25'); -- 0001-01-01 BC
-        date_trunc         
----------------------------
- 0001-01-01 00:00:00-08 BC
+       date_trunc       
+------------------------
+ 0001-01-01 00:00:00 BC
 (1 row)
 
 SELECT DATE_TRUNC('DECADE', DATE '0002-12-31 BC'); -- 0011-01-01 BC
-        date_trunc         
----------------------------
- 0011-01-01 00:00:00-08 BC
+       date_trunc       
+------------------------
+ 0011-01-01 00:00:00 BC
 (1 row)
 
 --
 -- test infinity
 --
 select 'infinity'::date, '-infinity'::date;
-   date   |   date    
-----------+-----------
- infinity | -infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 select 'infinity'::date > 'today'::date as t;
- t 
----
- t
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 select '-infinity'::date < 'today'::date as t;
- t 
----
- t
-(1 row)
-
+ERROR:  invalid input syntax for type date: "-infinity"
 select isfinite('infinity'::date), isfinite('-infinity'::date), isfinite('today'::date);
- isfinite | isfinite | isfinite 
-----------+----------+----------
- f        | f        | t
-(1 row)
-
+ERROR:  function isfinite does not exist
 select 'infinity'::date = '+infinity'::date as t;
- t 
----
- t
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 --
 -- oscillating fields from non-finite date:
 --
 SELECT EXTRACT(DAY FROM DATE 'infinity');      -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(DAY FROM DATE '-infinity');     -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "-infinity"
 -- all supported fields
 SELECT EXTRACT(DAY           FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(MONTH         FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(QUARTER       FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(WEEK          FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(DOW           FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(ISODOW        FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(DOY           FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 --
 -- monotonic fields from non-finite date:
 --
 SELECT EXTRACT(EPOCH FROM DATE 'infinity');         --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(EPOCH FROM DATE '-infinity');        -- -Infinity
-  extract  
------------
- -Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "-infinity"
 -- all supported fields
 SELECT EXTRACT(YEAR       FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(DECADE     FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(CENTURY    FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(MILLENNIUM FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(JULIAN     FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(ISOYEAR    FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 SELECT EXTRACT(EPOCH      FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  invalid input syntax for type date: "infinity"
 --
 -- wrong fields from non-finite date:
 --
 SELECT EXTRACT(MICROSEC  FROM DATE 'infinity');     -- error
-ERROR:  unit "microsec" not recognized for type date
+ERROR:  invalid input syntax for type date: "infinity"
 -- test constructors
 select make_date(2013, 7, 15);
  make_date  
@@ -1440,14 +995,18 @@
 
 -- should fail
 select make_date(0, 7, 15);
-ERROR:  date field value out of range: 0-07-15
+ERROR:  out of range
 select make_date(2013, 2, 30);
-ERROR:  date field value out of range: 2013-02-30
+ERROR:  out of range
 select make_date(2013, 13, 1);
-ERROR:  date field value out of range: 2013-13-01
+ERROR:  out of range
 select make_date(2013, 11, -1);
-ERROR:  date field value out of range: 2013-11--1
+ERROR:  out of range
 select make_time(10, 55, 100.1);
-ERROR:  time field value out of range: 10:55:100.1
+ make_time  
+------------
+ 10:56:40.1
+(1 row)
+
 select make_time(24, 0, 2.1);
-ERROR:  time field value out of range: 24:00:2.1
+ERROR:  out of range
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/time.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/time.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/time.out	2024-03-25 11:16:04.689340612 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/time.out	2024-04-12 10:24:59.491976981 +0800
@@ -73,37 +73,29 @@
 
 -- Check edge cases
 SELECT '23:59:59.999999'::time;
-      time       
+    ?column?     
 -----------------
  23:59:59.999999
 (1 row)
 
 SELECT '23:59:59.9999999'::time;  -- rounds up
-   time   
-----------
- 24:00:00
+    ?column?     
+-----------------
+ 23:59:59.999999
 (1 row)
 
 SELECT '23:59:60'::time;  -- rounds up
-   time   
-----------
- 24:00:00
-(1 row)
-
+ERROR:  invalid input syntax for type time: "23:59:60"
 SELECT '24:00:00'::time;  -- allowed
-   time   
-----------
- 24:00:00
-(1 row)
-
+ERROR:  invalid input syntax for type time: "24:00:00"
 SELECT '24:00:00.01'::time;  -- not allowed
-ERROR:  date/time field value out of range: "24:00:00.01"
+ERROR:  invalid input syntax for type time: "24:00:00.01"
 SELECT '23:59:60.01'::time;  -- not allowed
-ERROR:  date/time field value out of range: "23:59:60.01"
+ERROR:  invalid input syntax for type time: "23:59:60.01"
 SELECT '24:01:00'::time;  -- not allowed
-ERROR:  date/time field value out of range: "24:01:00"
+ERROR:  invalid input syntax for type time: "24:01:00"
 SELECT '25:00:00'::time;  -- not allowed
-ERROR:  date/time field value out of range: "25:00:00"
+ERROR:  invalid input syntax for type time: "25:00:00"
 -- Test non-error-throwing API
 SELECT pg_input_is_valid('12:00:00', 'time');
  pg_input_is_valid 
@@ -124,17 +116,9 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('25:00:00', 'time');
-                    message                     | detail | hint | sql_error_code 
-------------------------------------------------+--------+------+----------------
- date/time field value out of range: "25:00:00" |        |      | 22008
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('15:36:39 America/New_York', 'time');
-                             message                             | detail | hint | sql_error_code 
------------------------------------------------------------------+--------+------+----------------
- invalid input syntax for type time: "15:36:39 America/New_York" |        |      | 22007
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 --
 -- TIME simple math
 --
@@ -144,53 +128,52 @@
 -- and do the rest of the testing in horology.sql
 -- where we do mixed-type arithmetic. - thomas 2000-12-02
 SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL order by 1;
-ERROR:  operator is not unique: time without time zone + time without time zone
-HINT:  Could not choose a best candidate operator. You might need to add explicit type casts.
+ERROR:  IRGenerator:lookup failed, native function not found: [cast_time_datetime]
 --
 -- test EXTRACT
 --
 SELECT EXTRACT(MICROSECOND FROM TIME '2020-05-26 13:30:25.575401');
- extract  
-----------
- 25575401
+ date_part 
+-----------
+  25575401
 (1 row)
 
 SELECT EXTRACT(MILLISECOND FROM TIME '2020-05-26 13:30:25.575401');
-  extract  
+ date_part 
 -----------
  25575.401
 (1 row)
 
 SELECT EXTRACT(SECOND      FROM TIME '2020-05-26 13:30:25.575401');
-  extract  
+ date_part 
 -----------
  25.575401
 (1 row)
 
 SELECT EXTRACT(MINUTE      FROM TIME '2020-05-26 13:30:25.575401');
- extract 
----------
-      30
+ date_part 
+-----------
+        30
 (1 row)
 
 SELECT EXTRACT(HOUR        FROM TIME '2020-05-26 13:30:25.575401');
- extract 
----------
-      13
+ date_part 
+-----------
+        13
 (1 row)
 
 SELECT EXTRACT(DAY         FROM TIME '2020-05-26 13:30:25.575401');  -- error
-ERROR:  unit "day" not supported for type time without time zone
+ date_part 
+-----------
+         0
+(1 row)
+
 SELECT EXTRACT(FORTNIGHT   FROM TIME '2020-05-26 13:30:25.575401');  -- error
-ERROR:  unit "fortnight" not recognized for type time without time zone
+ERROR:  timestamp units "fortnight" not recognized
 SELECT EXTRACT(TIMEZONE    FROM TIME '2020-05-26 13:30:25.575401');  -- error
-ERROR:  unit "timezone" not supported for type time without time zone
+ERROR:  timestamp units "timezone" not recognized
 SELECT EXTRACT(EPOCH       FROM TIME '2020-05-26 13:30:25.575401');
-   extract    
---------------
- 48625.575401
-(1 row)
-
+ERROR:  timestamp units "epoch" not recognized
 -- date_part implementation is mostly the same as extract, so only
 -- test a few cases for additional coverage.
 SELECT date_part('microsecond', TIME '2020-05-26 13:30:25.575401');
@@ -212,8 +195,4 @@
 (1 row)
 
 SELECT date_part('epoch',       TIME '2020-05-26 13:30:25.575401');
-  date_part   
---------------
- 48625.575401
-(1 row)
-
+ERROR:  timestamp units "epoch" not recognized
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/interval.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/interval.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/interval.out	2024-03-29 11:02:48.915179683 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/interval.out	2024-04-12 10:25:45.716008598 +0800
@@ -2,7 +2,9 @@
 -- INTERVAL
 --
 SET DATESTYLE = 'ISO';
+ERROR:  only support select and create table statement
 SET IntervalStyle to postgres;
+ERROR:  only support select and create table statement
 -- check acceptance of "time zone style"
 SELECT INTERVAL '01:00' AS "One hour";
  One hour 
@@ -53,17 +55,9 @@
 (1 row)
 
 SELECT INTERVAL 'infinity' AS "eternity";
- eternity 
-----------
- infinity
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "infinity"
 SELECT INTERVAL '-infinity' AS "beginning of time";
- beginning of time 
--------------------
- -infinity
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-infinity"
 CREATE TABLE INTERVAL_TBL (f1 interval);
 INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 1 minute');
 INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 5 hour');
@@ -102,17 +96,9 @@
 (1 row)
 
 SELECT * FROM pg_input_error_info('garbage', 'interval');
-                      message                      | detail | hint | sql_error_code 
----------------------------------------------------+--------+------+----------------
- invalid input syntax for type interval: "garbage" |        |      | 22007
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('@ 30 eons ago', 'interval');
-                         message                         | detail | hint | sql_error_code 
----------------------------------------------------------+--------+------+----------------
- invalid input syntax for type interval: "@ 30 eons ago" |        |      | 22007
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- test interval operators
 SELECT * FROM INTERVAL_TBL order by 1;
        f1        
@@ -199,97 +185,24 @@
    FROM INTERVAL_TBL r1, INTERVAL_TBL r2
    WHERE r1.f1 > r2.f1
    ORDER BY r1.f1, r2.f1;
-       f1        |       f1        
------------------+-----------------
- 00:01:00        | -00:00:14
- 05:00:00        | -00:00:14
- 05:00:00        | 00:01:00
- 1 day 02:03:04  | -00:00:14
- 1 day 02:03:04  | 00:01:00
- 1 day 02:03:04  | 05:00:00
- 10 days         | -00:00:14
- 10 days         | 00:01:00
- 10 days         | 05:00:00
- 10 days         | 1 day 02:03:04
- 3 mons          | -00:00:14
- 3 mons          | 00:01:00
- 3 mons          | 05:00:00
- 3 mons          | 1 day 02:03:04
- 3 mons          | 10 days
- 5 mons          | -00:00:14
- 5 mons          | 00:01:00
- 5 mons          | 05:00:00
- 5 mons          | 1 day 02:03:04
- 5 mons          | 10 days
- 5 mons          | 3 mons
- 5 mons 12:00:00 | -00:00:14
- 5 mons 12:00:00 | 00:01:00
- 5 mons 12:00:00 | 05:00:00
- 5 mons 12:00:00 | 1 day 02:03:04
- 5 mons 12:00:00 | 10 days
- 5 mons 12:00:00 | 3 mons
- 5 mons 12:00:00 | 5 mons
- 6 years         | -00:00:14
- 6 years         | 00:01:00
- 6 years         | 05:00:00
- 6 years         | 1 day 02:03:04
- 6 years         | 10 days
- 6 years         | 3 mons
- 6 years         | 5 mons
- 6 years         | 5 mons 12:00:00
- 34 years        | -00:00:14
- 34 years        | 00:01:00
- 34 years        | 05:00:00
- 34 years        | 1 day 02:03:04
- 34 years        | 10 days
- 34 years        | 3 mons
- 34 years        | 5 mons
- 34 years        | 5 mons 12:00:00
- 34 years        | 6 years
-(45 rows)
-
+ERROR:  clapdb doesn't support join currently
 -- test unary minus
 SELECT f1, -f1 FROM INTERVAL_TBL order by 1;
-       f1        |     ?column?      
------------------+-------------------
- -00:00:14       | 00:00:14
- 00:01:00        | -00:01:00
- 05:00:00        | -05:00:00
- 1 day 02:03:04  | -1 days -02:03:04
- 10 days         | -10 days
- 3 mons          | -3 mons
- 5 mons          | -5 mons
- 5 mons 12:00:00 | -5 mons -12:00:00
- 6 years         | -6 years
- 34 years        | -34 years
-(10 rows)
-
+ERROR:  operator does not exist: NEG Interval
 SELECT -('-2147483648 months'::interval); -- should fail
-ERROR:  interval out of range
+ERROR:  operator does not exist: NEG Interval
 SELECT -('-2147483647 months'::interval); -- ok
-        ?column?        
-------------------------
- 178956970 years 7 mons
-(1 row)
-
+ERROR:  operator does not exist: NEG Interval
 SELECT -('-2147483648 days'::interval); -- should fail
-ERROR:  interval out of range
+ERROR:  operator does not exist: NEG Interval
 SELECT -('-2147483647 days'::interval); -- ok
-    ?column?     
------------------
- 2147483647 days
-(1 row)
-
+ERROR:  operator does not exist: NEG Interval
 SELECT -('-9223372036854775808 us'::interval); -- should fail
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-9223372036854775808 us"
 SELECT -('-9223372036854775807 us'::interval); -- ok
-        ?column?         
--------------------------
- 2562047788:00:54.775807
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-9223372036854775807 us"
 SELECT -('-2147483647 months -2147483647 days -9223372036854775807 us'::interval); -- should fail
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483647 days -9223372036854775807 us"
 -- Test intervals that are large enough to overflow 64 bits in comparisons
 CREATE TEMP TABLE INTERVAL_TBL_OF (f1 interval);
 INSERT INTO INTERVAL_TBL_OF (f1) VALUES
@@ -298,68 +211,56 @@
   ('1 year'),
   ('-2147483648 days 2147483647 months'),
   ('-2147483648 days -2147483648 months');
+ERROR:  invalid input syntax for type interval: "2147483647 days 2147483647 months"
 -- these should fail as out-of-range
 INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483648 days');
-ERROR:  interval field value out of range: "2147483648 days"
 INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483649 days');
-ERROR:  interval field value out of range: "-2147483649 days"
 INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483647 years');
-ERROR:  interval out of range
 INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483648 years');
-ERROR:  interval out of range
 -- Test edge-case overflow detection in interval multiplication
 select extract(epoch from '256 microseconds'::interval * (2^55)::float8);
-ERROR:  interval out of range
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 SELECT r1.*, r2.*
    FROM INTERVAL_TBL_OF r1, INTERVAL_TBL_OF r2
    WHERE r1.f1 > r2.f1
    ORDER BY r1.f1, r2.f1;
-                    f1                     |                    f1                     
--------------------------------------------+-------------------------------------------
- -178956970 years -8 mons +2147483647 days | -178956970 years -8 mons -2147483648 days
- 1 year                                    | -178956970 years -8 mons -2147483648 days
- 1 year                                    | -178956970 years -8 mons +2147483647 days
- 178956970 years 7 mons -2147483648 days   | -178956970 years -8 mons -2147483648 days
- 178956970 years 7 mons -2147483648 days   | -178956970 years -8 mons +2147483647 days
- 178956970 years 7 mons -2147483648 days   | 1 year
- 178956970 years 7 mons 2147483647 days    | -178956970 years -8 mons -2147483648 days
- 178956970 years 7 mons 2147483647 days    | -178956970 years -8 mons +2147483647 days
- 178956970 years 7 mons 2147483647 days    | 1 year
- 178956970 years 7 mons 2147483647 days    | 178956970 years 7 mons -2147483648 days
-(10 rows)
-
+ERROR:  clapdb doesn't support join currently
 CREATE INDEX ON INTERVAL_TBL_OF USING btree (f1);
+ERROR:  only support select and create table statement
 SET enable_seqscan TO false;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT f1 FROM INTERVAL_TBL_OF r1 ORDER BY f1;
-                             QUERY PLAN                             
---------------------------------------------------------------------
- Index Only Scan using interval_tbl_of_f1_idx on interval_tbl_of r1
-(1 row)
+                                          QUERY PLAN                                          
+----------------------------------------------------------------------------------------------
+ tuple(table_0) = parallel: [tuple(table_0) = IndexScan([column(f1)]), return tuple(table_0)]
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(3 rows)
 
 SELECT f1 FROM INTERVAL_TBL_OF r1 ORDER BY f1;
-                    f1                     
--------------------------------------------
- -178956970 years -8 mons -2147483648 days
- -178956970 years -8 mons +2147483647 days
- 1 year
- 178956970 years 7 mons -2147483648 days
- 178956970 years 7 mons 2147483647 days
-(5 rows)
+                        f1                        
+--------------------------------------------------
+ -33211803 years -6 mons -16 days -20:22:14.62016
+ -33211803 years -6 mons -16 days -20:22:14.62016
+ -4744905 years -8 mons -19:37:59.683072
+ -4744905 years -7 mons -29 days -19:37:59.683072
+(4 rows)
 
 RESET enable_seqscan;
+ERROR:  only support select and create table statement
 -- subtracting about-to-overflow values should result in 0
 SELECT f1 - f1 FROM INTERVAL_TBL_OF order by 1;
  ?column? 
 ----------
- 00:00:00
- 00:00:00
- 00:00:00
- 00:00:00
- 00:00:00
-(5 rows)
+ 0
+ 0
+ 0
+ 0
+(4 rows)
 
 DROP TABLE INTERVAL_TBL_OF;
+ERROR:  only support select and create table statement
 -- Test multiplication and division with intervals.
 -- Floating point arithmetic rounding errors can lead to unexpected results,
 -- though the code attempts to do the right thing and round up to days and
@@ -369,64 +270,33 @@
 -- stored internally.
 CREATE TABLE INTERVAL_MULDIV_TBL (span interval);
 COPY INTERVAL_MULDIV_TBL FROM STDIN;
+ERROR:  Can not open file "" because "No such file or directory".
+41 mon 12 days 360:00
+-41 mon -12 days +360:00
+-12 days
+9 mon -27 days 12:34:56
+-3 years 482 days 76:54:32.189
+4 mon
+14 mon
+999 mon 999 days
+\.
+invalid command \.
 SELECT span * 0.3 AS product
 FROM INTERVAL_MULDIV_TBL;
-              product               
-------------------------------------
- 1 year 12 days 122:24:00
- -1 years -12 days +93:36:00
- -3 days -14:24:00
- 2 mons 13 days 01:22:28.8
- -10 mons +120 days 37:28:21.6567
- 1 mon 6 days
- 4 mons 6 days
- 24 years 11 mons 320 days 16:48:00
-(8 rows)
-
+ERROR:  syntax error at or near "41"
 SELECT span * 8.2 AS product
 FROM INTERVAL_MULDIV_TBL;
-                   product                   
----------------------------------------------
- 28 years 104 days 2961:36:00
- -28 years -104 days +2942:24:00
- -98 days -09:36:00
- 6 years 1 mon -197 days +93:34:27.2
- -24 years -7 mons +3946 days 640:15:11.9498
- 2 years 8 mons 24 days
- 9 years 6 mons 24 days
- 682 years 7 mons 8215 days 19:12:00
-(8 rows)
-
+ERROR:  operator does not exist: Interval MUL Numeric
 SELECT span / 10 AS quotient
 FROM INTERVAL_MULDIV_TBL;
-             quotient             
-----------------------------------
- 4 mons 4 days 40:48:00
- -4 mons -4 days +31:12:00
- -1 days -04:48:00
- 25 days -15:32:30.4
- -3 mons +30 days 12:29:27.2189
- 12 days
- 1 mon 12 days
- 8 years 3 mons 126 days 21:36:00
-(8 rows)
-
+ERROR:  operator does not exist: Interval DIV Int32
 SELECT span / 100 AS quotient
 FROM INTERVAL_MULDIV_TBL;
-        quotient         
--------------------------
- 12 days 13:40:48
- -12 days -06:28:48
- -02:52:48
- 2 days 10:26:44.96
- -6 days +01:14:56.72189
- 1 day 04:48:00
- 4 days 04:48:00
- 9 mons 39 days 16:33:36
-(8 rows)
-
+ERROR:  operator does not exist: Interval DIV Int32
 DROP TABLE INTERVAL_MULDIV_TBL;
+ERROR:  only support select and create table statement
 SET DATESTYLE = 'postgres';
+ERROR:  only support select and create table statement
 --SET IntervalStyle to postgres_verbose;
 SELECT * FROM INTERVAL_TBL order by 1;
        f1        
@@ -445,111 +315,73 @@
 
 -- multiplication and division overflow test cases
 SELECT '3000000 months'::interval * 1000;
-ERROR:  interval out of range
+ERROR:  operator does not exist: Interval MUL Int32
 SELECT '3000000 months'::interval / 0.001;
-ERROR:  interval out of range
+ERROR:  operator does not exist: Interval DIV Numeric
 SELECT '3000000 days'::interval * 1000;
-ERROR:  interval out of range
+ERROR:  operator does not exist: Interval MUL Int32
 SELECT '3000000 days'::interval / 0.001;
-ERROR:  interval out of range
+ERROR:  operator does not exist: Interval DIV Numeric
 SELECT '1 month 2146410 days'::interval * 1000.5002;
-ERROR:  interval out of range
+ERROR:  operator does not exist: Interval MUL Numeric
 SELECT '4611686018427387904 usec'::interval / 0.1;
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "4611686018427387904 usec"
 -- test avg(interval), which is somewhat fragile since people have been
 -- known to change the allowed input syntax for type interval without
 -- updating pg_aggregate.agginitval
 select avg(f1) from interval_tbl where isfinite(f1);
-              avg               
---------------------------------
- 4 years 1 mon 10 days 04:18:23
-(1 row)
-
+ERROR:  function isfinite does not exist
 -- test long interval input
 select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;
-             interval              
------------------------------------
- 4541 years 4 mons 4 days 00:17:31
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds"
 -- test long interval output
 -- Note: the actual maximum length of the interval output is longer,
 -- but we need the test to work for both integer and floating-point
 -- timestamps.
 select '100000000y 10mon -1000000000d -100000h -10min -10.000001s ago'::interval;
-                            interval                            
-----------------------------------------------------------------
- -100000000 years -10 mons +1000000000 days 100000:10:10.000001
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "100000000y 10mon -1000000000d -100000h -10min -10.000001s ago"
 -- test justify_hours() and justify_days()
 SELECT justify_hours(interval '6 months 3 days 52 hours 3 minutes 2 seconds') as "6 mons 5 days 4 hours 3 mins 2 seconds";
- 6 mons 5 days 4 hours 3 mins 2 seconds 
-----------------------------------------
- 6 mons 5 days 04:03:02
-(1 row)
-
+ERROR:  function justify_hours does not exist
 SELECT justify_days(interval '6 months 36 days 5 hours 4 minutes 3 seconds') as "7 mons 6 days 5 hours 4 mins 3 seconds";
- 7 mons 6 days 5 hours 4 mins 3 seconds 
-----------------------------------------
- 7 mons 6 days 05:04:03
-(1 row)
-
+ERROR:  function justify_days does not exist
 SELECT justify_hours(interval '2147483647 days 24 hrs');
-ERROR:  interval out of range
+ERROR:  function justify_hours does not exist
 SELECT justify_days(interval '2147483647 months 30 days');
-ERROR:  interval out of range
+ERROR:  function justify_days does not exist
 -- test justify_interval()
 SELECT justify_interval(interval '1 month -1 hour') as "1 month -1 hour";
- 1 month -1 hour  
-------------------
- 29 days 23:00:00
-(1 row)
-
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '2147483647 days 24 hrs');
-      justify_interval       
------------------------------
- 5965232 years 4 mons 8 days
-(1 row)
-
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '-2147483648 days -24 hrs');
-        justify_interval        
---------------------------------
- -5965232 years -4 mons -9 days
-(1 row)
-
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '2147483647 months 30 days');
-ERROR:  interval out of range
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '-2147483648 months -30 days');
-ERROR:  interval out of range
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '2147483647 months 30 days -24 hrs');
-        justify_interval        
---------------------------------
- 178956970 years 7 mons 29 days
-(1 row)
-
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '-2147483648 months -30 days 24 hrs');
-         justify_interval          
------------------------------------
- -178956970 years -8 mons -29 days
-(1 row)
-
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '2147483647 months -30 days 1440 hrs');
-ERROR:  interval out of range
+ERROR:  function justify_interval does not exist
 SELECT justify_interval(interval '-2147483648 months 30 days -1440 hrs');
-ERROR:  interval out of range
+ERROR:  function justify_interval does not exist
 -- test fractional second input, and detection of duplicate units
 SET DATESTYLE = 'ISO';
+ERROR:  only support select and create table statement
 SET IntervalStyle TO postgres;
+ERROR:  only support select and create table statement
 SELECT '1 millisecond'::interval, '1 microsecond'::interval,
        '500 seconds 99 milliseconds 51 microseconds'::interval;
-   interval   |    interval     |    interval     
+   ?column?   |    ?column?     |    ?column?     
 --------------+-----------------+-----------------
  00:00:00.001 | 00:00:00.000001 | 00:08:20.099051
 (1 row)
 
 SELECT '3 days 5 milliseconds'::interval;
-      interval       
+      ?column?       
 ---------------------
  3 days 00:00:00.005
 (1 row)
@@ -559,340 +391,377 @@
 SELECT '10 milliseconds 20 milliseconds'::interval; -- error
 ERROR:  invalid input syntax for type interval: "10 milliseconds 20 milliseconds"
 SELECT '5.5 seconds 3 milliseconds'::interval;      -- error
-ERROR:  invalid input syntax for type interval: "5.5 seconds 3 milliseconds"
+   ?column?   
+--------------
+ 00:00:05.503
+(1 row)
+
 SELECT '1:20:05 5 microseconds'::interval;          -- error
 ERROR:  invalid input syntax for type interval: "1:20:05 5 microseconds"
 SELECT '1 day 1 day'::interval;                     -- error
 ERROR:  invalid input syntax for type interval: "1 day 1 day"
 SELECT interval '1-2';  -- SQL year-month literal
-   interval    
+   ?column?    
 ---------------
  1 year 2 mons
 (1 row)
 
 SELECT interval '999' second;  -- oversize leading field is ok
- interval 
+ ?column? 
 ----------
  00:16:39
 (1 row)
 
 SELECT interval '999' minute;
- interval 
+ ?column? 
 ----------
- 16:39:00
+ 00:16:39
 (1 row)
 
 SELECT interval '999' hour;
- interval  
------------
- 999:00:00
+ ?column? 
+----------
+ 00:16:39
 (1 row)
 
 SELECT interval '999' day;
- interval 
+ ?column? 
 ----------
- 999 days
+ 00:16:39
 (1 row)
 
 SELECT interval '999' month;
-    interval     
------------------
- 83 years 3 mons
+ ?column? 
+----------
+ 00:16:39
 (1 row)
 
 -- test SQL-spec syntaxes for restricted field sets
 SELECT interval '1' year;
- interval 
+ ?column? 
 ----------
- 1 year
+ 00:00:01
 (1 row)
 
 SELECT interval '2' month;
- interval 
+ ?column? 
 ----------
- 2 mons
+ 00:00:02
 (1 row)
 
 SELECT interval '3' day;
- interval 
+ ?column? 
 ----------
- 3 days
+ 00:00:03
 (1 row)
 
 SELECT interval '4' hour;
- interval 
+ ?column? 
 ----------
- 04:00:00
+ 00:00:04
 (1 row)
 
 SELECT interval '5' minute;
- interval 
+ ?column? 
 ----------
- 00:05:00
+ 00:00:05
 (1 row)
 
 SELECT interval '6' second;
- interval 
+ ?column? 
 ----------
  00:00:06
 (1 row)
 
 SELECT interval '1' year to month;
- interval 
+ ?column? 
 ----------
- 1 mon
+ 00:00:01
 (1 row)
 
 SELECT interval '1-2' year to month;
-   interval    
+   ?column?    
 ---------------
  1 year 2 mons
 (1 row)
 
 SELECT interval '1 2' day to hour;
-    interval    
+    ?column?    
 ----------------
- 1 day 02:00:00
+ 1 day 00:00:02
 (1 row)
 
 SELECT interval '1 2:03' day to hour;
-    interval    
+    ?column?    
 ----------------
- 1 day 02:00:00
+ 1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03:04' day to hour;
-    interval    
+    ?column?    
 ----------------
- 1 day 02:00:00
+ 1 day 02:03:04
 (1 row)
 
 SELECT interval '1 2' day to minute;
-ERROR:  invalid input syntax for type interval: "1 2"
+    ?column?    
+----------------
+ 1 day 00:00:02
+(1 row)
+
 SELECT interval '1 2:03' day to minute;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03:04' day to minute;
-    interval    
+    ?column?    
 ----------------
- 1 day 02:03:00
+ 1 day 02:03:04
 (1 row)
 
 SELECT interval '1 2' day to second;
-ERROR:  invalid input syntax for type interval: "1 2"
+    ?column?    
+----------------
+ 1 day 00:00:02
+(1 row)
+
 SELECT interval '1 2:03' day to second;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03:04' day to second;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:04
 (1 row)
 
 SELECT interval '1 2' hour to minute;
-ERROR:  invalid input syntax for type interval: "1 2"
+    ?column?    
+----------------
+ 1 day 00:00:02
+(1 row)
+
 SELECT interval '1 2:03' hour to minute;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03:04' hour to minute;
-    interval    
+    ?column?    
 ----------------
- 1 day 02:03:00
+ 1 day 02:03:04
 (1 row)
 
 SELECT interval '1 2' hour to second;
-ERROR:  invalid input syntax for type interval: "1 2"
+    ?column?    
+----------------
+ 1 day 00:00:02
+(1 row)
+
 SELECT interval '1 2:03' hour to second;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03:04' hour to second;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:04
 (1 row)
 
 SELECT interval '1 2' minute to second;
-ERROR:  invalid input syntax for type interval: "1 2"
+    ?column?    
+----------------
+ 1 day 00:00:02
+(1 row)
+
 SELECT interval '1 2:03' minute to second;
-    interval    
+    ?column?    
 ----------------
- 1 day 00:02:03
+ 1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03:04' minute to second;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:04
 (1 row)
 
 SELECT interval '1 +2:03' minute to second;
-    interval    
+    ?column?    
 ----------------
- 1 day 00:02:03
+ 1 day 02:03:00
 (1 row)
 
 SELECT interval '1 +2:03:04' minute to second;
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:04
 (1 row)
 
 SELECT interval '1 -2:03' minute to second;
-    interval     
+    ?column?     
 -----------------
- 1 day -00:02:03
+ 1 day -02:03:00
 (1 row)
 
 SELECT interval '1 -2:03:04' minute to second;
-    interval     
+    ?column?     
 -----------------
  1 day -02:03:04
 (1 row)
 
 SELECT interval '123 11' day to hour; -- ok
-     interval      
+     ?column?      
 -------------------
- 123 days 11:00:00
+ 123 days 00:00:11
 (1 row)
 
 SELECT interval '123 11' day; -- not ok
-ERROR:  invalid input syntax for type interval: "123 11"
+     ?column?      
+-------------------
+ 123 days 00:00:11
+(1 row)
+
 SELECT interval '123 11'; -- not ok, too ambiguous
-ERROR:  invalid input syntax for type interval: "123 11"
+     ?column?      
+-------------------
+ 123 days 00:00:11
+(1 row)
+
 SELECT interval '123 2:03 -2:04'; -- not ok, redundant hh:mm fields
 ERROR:  invalid input syntax for type interval: "123 2:03 -2:04"
 -- test syntaxes for restricted precision
 SELECT interval(0) '1 day 01:23:45.6789';
-    interval    
-----------------
- 1 day 01:23:46
+      ?column?       
+---------------------
+ 1 day 01:23:45.6789
 (1 row)
 
 SELECT interval(2) '1 day 01:23:45.6789';
-     interval      
--------------------
- 1 day 01:23:45.68
+      ?column?       
+---------------------
+ 1 day 01:23:45.6789
 (1 row)
 
 SELECT interval '12:34.5678' minute to second(2);  -- per SQL spec
-  interval   
--------------
- 00:12:34.57
+   ?column?   
+--------------
+ 12:34:34.068
 (1 row)
 
 SELECT interval '1.234' second;
-   interval   
+   ?column?   
 --------------
  00:00:01.234
 (1 row)
 
 SELECT interval '1.234' second(2);
-  interval   
--------------
- 00:00:01.23
+   ?column?   
+--------------
+ 00:00:01.234
 (1 row)
 
 SELECT interval '1 2.345' day to second(2);
-ERROR:  invalid input syntax for type interval: "1 2.345"
+      ?column?      
+--------------------
+ 1 day 00:00:02.345
+(1 row)
+
 SELECT interval '1 2:03' day to second(2);
-    interval    
+    ?column?    
 ----------------
  1 day 02:03:00
 (1 row)
 
 SELECT interval '1 2:03.4567' day to second(2);
-     interval      
--------------------
- 1 day 00:02:03.46
+      ?column?      
+--------------------
+ 1 day 02:03:27.402
 (1 row)
 
 SELECT interval '1 2:03:04.5678' day to second(2);
-     interval      
--------------------
- 1 day 02:03:04.57
+      ?column?       
+---------------------
+ 1 day 02:03:04.5678
 (1 row)
 
 SELECT interval '1 2.345' hour to second(2);
-ERROR:  invalid input syntax for type interval: "1 2.345"
+      ?column?      
+--------------------
+ 1 day 00:00:02.345
+(1 row)
+
 SELECT interval '1 2:03.45678' hour to second(2);
-     interval      
--------------------
- 1 day 00:02:03.46
+      ?column?       
+---------------------
+ 1 day 02:03:27.4068
 (1 row)
 
 SELECT interval '1 2:03:04.5678' hour to second(2);
-     interval      
--------------------
- 1 day 02:03:04.57
+      ?column?       
+---------------------
+ 1 day 02:03:04.5678
 (1 row)
 
 SELECT interval '1 2.3456' minute to second(2);
-ERROR:  invalid input syntax for type interval: "1 2.3456"
+      ?column?       
+---------------------
+ 1 day 00:00:02.3456
+(1 row)
+
 SELECT interval '1 2:03.5678' minute to second(2);
-     interval      
--------------------
- 1 day 00:02:03.57
+      ?column?      
+--------------------
+ 1 day 02:03:34.068
 (1 row)
 
 SELECT interval '1 2:03:04.5678' minute to second(2);
-     interval      
--------------------
- 1 day 02:03:04.57
+      ?column?       
+---------------------
+ 1 day 02:03:04.5678
 (1 row)
 
 SELECT interval '2562047788:00:54.775807' second(2);  -- out of range
-ERROR:  interval out of range
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 SELECT interval '-2562047788:00:54.775807' second(2);  -- out of range
-ERROR:  interval out of range
+         ?column?         
+--------------------------
+ -2562047788:00:54.775806
+(1 row)
+
 -- test casting to restricted precision (bug #14479)
 SELECT f1, f1::INTERVAL DAY TO MINUTE AS "minutes",
   (f1 + INTERVAL '1 month')::INTERVAL MONTH::INTERVAL YEAR AS "years"
   FROM interval_tbl order by 1;
-       f1        |     minutes     |  years   
------------------+-----------------+----------
- -00:00:14       | 00:00:00        | 00:00:00
- 00:01:00        | 00:01:00        | 00:00:00
- 05:00:00        | 05:00:00        | 00:00:00
- 1 day 02:03:04  | 1 day 02:03:00  | 00:00:00
- 10 days         | 10 days         | 00:00:00
- 3 mons          | 3 mons          | 00:00:00
- 5 mons          | 5 mons          | 00:00:00
- 5 mons 12:00:00 | 5 mons 12:00:00 | 00:00:00
- 6 years         | 6 years         | 6 years
- 34 years        | 34 years        | 34 years
-(10 rows)
-
+ERROR:  IRGenerator:lookup failed, native function not found: [cast_interval_interval]
 -- test inputting and outputting SQL standard interval literals
 SET IntervalStyle TO sql_standard;
+ERROR:  only support select and create table statement
 SELECT  interval '0'                       AS "zero",
         interval '1-2' year to month       AS "year-month",
         interval '1 2:03:04' day to second AS "day-time",
         - interval '1-2'                   AS "negative year-month",
         - interval '1 2:03:04'             AS "negative day-time";
- zero | year-month | day-time  | negative year-month | negative day-time 
-------+------------+-----------+---------------------+-------------------
- 0    | 1-2        | 1 2:03:04 | -1-2                | -1 2:03:04
-(1 row)
-
+ERROR:  operator does not exist: NEG Interval
 -- test input of some not-quite-standard interval values in the sql style
 SET IntervalStyle TO postgres;
+ERROR:  only support select and create table statement
 SELECT  interval '+1 -1:00:00',
         interval '-1 +1:00:00',
         interval '+1-2 -3 +4:05:06.789',
         interval '-1-2 +3 -4:05:06.789';
-    interval     |     interval      |              interval               |                interval                
+    ?column?     |     ?column?      |              ?column?               |                ?column?                
 -----------------+-------------------+-------------------------------------+----------------------------------------
  1 day -01:00:00 | -1 days +01:00:00 | 1 year 2 mons -3 days +04:05:06.789 | -1 years -2 mons +3 days -04:05:06.789
 (1 row)
@@ -902,37 +771,39 @@
         interval '-1 day 23 hours 45 min 12.34 sec',
         interval '-1 year 2 months 1 day 23 hours 45 min 12.34 sec',
         interval '-1 year 2 months 1 day 23 hours 45 min +12.34 sec';
-   interval   |       interval       |          interval           |          interval           
+   ?column?   |       ?column?       |          ?column?           |          ?column?           
 --------------+----------------------+-----------------------------+-----------------------------
  -22:14:47.66 | -1 days +23:45:12.34 | -10 mons +1 day 23:45:12.34 | -10 mons +1 day 23:45:12.34
 (1 row)
 
 -- test output of couple non-standard interval values in the sql style
 SET IntervalStyle TO sql_standard;
+ERROR:  only support select and create table statement
 SELECT  interval '1 day -1 hours',
         interval '-1 days +1 hours',
         interval '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds',
         - interval '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds';
-     interval     |     interval     |       interval       |       ?column?       
-------------------+------------------+----------------------+----------------------
- +0-0 +1 -1:00:00 | +0-0 -1 +1:00:00 | +1-2 -3 +4:05:06.789 | -1-2 +3 -4:05:06.789
-(1 row)
-
+ERROR:  operator does not exist: NEG Interval
 -- cases that trigger sign-matching rules in the sql style
 SELECT  interval '-23 hours 45 min 12.34 sec',
         interval '-1 day 23 hours 45 min 12.34 sec',
         interval '-1 year 2 months 1 day 23 hours 45 min 12.34 sec',
         interval '-1 year 2 months 1 day 23 hours 45 min +12.34 sec';
-   interval   |    interval    |       interval       |       interval        
---------------+----------------+----------------------+-----------------------
- -23:45:12.34 | -1 23:45:12.34 | -1-2 -1 -23:45:12.34 | -0-10 +1 +23:45:12.34
+   ?column?   |       ?column?       |          ?column?           |          ?column?           
+--------------+----------------------+-----------------------------+-----------------------------
+ -22:14:47.66 | -1 days +23:45:12.34 | -10 mons +1 day 23:45:12.34 | -10 mons +1 day 23:45:12.34
 (1 row)
 
 -- edge case for sign-matching rules
 SELECT  interval '';  -- error
-ERROR:  invalid input syntax for type interval: ""
+ ?column? 
+----------
+ 0
+(1 row)
+
 -- test outputting iso8601 intervals
 SET IntervalStyle to iso_8601;
+ERROR:  only support select and create table statement
 select  interval '0'                                AS "zero",
         interval '1-2'                              AS "a year 2 months",
         interval '1 2:03:04'                        AS "a bit over a day",
@@ -940,13 +811,10 @@
         (interval '1-2' + interval '3 4:05:06.7')   AS "all fields",
         (interval '1-2' - interval '3 4:05:06.7')   AS "mixed sign",
         (- interval '1-2' + interval '3 4:05:06.7') AS "negative";
- zero | a year 2 months | a bit over a day | a bit over 2 hours |    all fields    |      mixed sign      |      negative      
-------+-----------------+------------------+--------------------+------------------+----------------------+--------------------
- PT0S | P1Y2M           | P1DT2H3M4S       | PT2H3M4.45679S     | P1Y2M3DT4H5M6.7S | P1Y2M-3DT-4H-5M-6.7S | P-1Y-2M3DT4H5M6.7S
-(1 row)
-
+ERROR:  operator does not exist: NEG Interval
 -- test inputting ISO 8601 4.4.2.1 "Format With Time Unit Designators"
 SET IntervalStyle to sql_standard;
+ERROR:  only support select and create table statement
 select  interval 'P0Y'                    AS "zero",
         interval 'P1Y2M'                  AS "a year 2 months",
         interval 'P1W'                    AS "a week",
@@ -954,20 +822,13 @@
         interval 'P1Y2M3DT4H5M6.7S'       AS "all fields",
         interval 'P-1Y-2M-3DT-4H-5M-6.7S' AS "negative",
         interval 'PT-0.1S'                AS "fractional second";
- zero | a year 2 months |  a week   | a bit over a day |     all fields     |      negative      | fractional second 
-------+-----------------+-----------+------------------+--------------------+--------------------+-------------------
- 0    | 1-2             | 7 0:00:00 | 1 2:03:04        | +1-2 +3 +4:05:06.7 | -1-2 -3 -4:05:06.7 | -0:00:00.1
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P0Y"
 -- test inputting ISO 8601 4.4.2.2 "Alternative Format"
 SET IntervalStyle to postgres;
+ERROR:  only support select and create table statement
 select  interval 'P00021015T103020'       AS "ISO8601 Basic Format",
         interval 'P0002-10-15T10:30:20'   AS "ISO8601 Extended Format";
-       ISO8601 Basic Format       |     ISO8601 Extended Format      
-----------------------------------+----------------------------------
- 2 years 10 mons 15 days 10:30:20 | 2 years 10 mons 15 days 10:30:20
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P00021015T103020"
 -- Make sure optional ISO8601 alternative format fields are optional.
 select  interval 'P0002'                  AS "year only",
         interval 'P0002-10'               AS "year month",
@@ -977,466 +838,537 @@
         interval 'P0002-10-15T1S'         AS "year month day plus time",
         interval 'PT10'                   AS "hour only",
         interval 'PT10:30'                AS "hour minute";
- year only |   year month    |     year month day      | year only plus time |   year month plus time   |     year month day plus time     | hour only | hour minute 
------------+-----------------+-------------------------+---------------------+--------------------------+----------------------------------+-----------+-------------
- 2 years   | 2 years 10 mons | 2 years 10 mons 15 days | 2 years 00:00:01    | 2 years 10 mons 00:00:01 | 2 years 10 mons 15 days 00:00:01 | 10:00:00  | 10:30:00
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P0002"
 -- Check handling of fractional fields in ISO8601 format.
 select interval 'P1Y0M3DT4H5M6S';
-        interval        
-------------------------
- 1 year 3 days 04:05:06
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P1Y0M3DT4H5M6S"
 select interval 'P1.0Y0M3DT4H5M6S';
-        interval        
-------------------------
- 1 year 3 days 04:05:06
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P1.0Y0M3DT4H5M6S"
 select interval 'P1.1Y0M3DT4H5M6S';
-           interval           
-------------------------------
- 1 year 1 mon 3 days 04:05:06
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P1.1Y0M3DT4H5M6S"
 select interval 'P1.Y0M3DT4H5M6S';
-        interval        
-------------------------
- 1 year 3 days 04:05:06
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P1.Y0M3DT4H5M6S"
 select interval 'P.1Y0M3DT4H5M6S';
-       interval        
------------------------
- 1 mon 3 days 04:05:06
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P.1Y0M3DT4H5M6S"
 select interval 'P10.5e4Y';  -- not per spec, but we've historically taken it
-   interval   
---------------
- 105000 years
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "P10.5e4Y"
 select interval 'P.Y0M3DT4H5M6S';  -- error
 ERROR:  invalid input syntax for type interval: "P.Y0M3DT4H5M6S"
 -- test a couple rounding cases that changed since 8.3 w/ HAVE_INT64_TIMESTAMP.
 --SET IntervalStyle to postgres_verbose;
 select interval '-10 mons -3 days +03:55:06.70';
-           interval           
+           ?column?           
 ------------------------------
  -10 mons -3 days +03:55:06.7
 (1 row)
 
 select interval '1 year 2 mons 3 days 04:05:06.699999';
-               interval               
+               ?column?               
 --------------------------------------
  1 year 2 mons 3 days 04:05:06.699999
 (1 row)
 
 select interval '0:0:0.7', interval '@ 0.70 secs', interval '0.7 seconds';
-  interval  |  interval  |  interval  
+  ?column?  |  ?column?  |  ?column?  
 ------------+------------+------------
  00:00:00.7 | 00:00:00.7 | 00:00:00.7
 (1 row)
 
 -- test time fields using entire 64 bit microseconds range
 select interval '2562047788.01521550194 hours';
-        interval         
--------------------------
- 2562047788:00:54.775807
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
 (1 row)
 
 select interval '-2562047788.01521550222 hours';
-         interval         
+         ?column?         
 --------------------------
- -2562047788:00:54.775808
+ -2562047788:00:54.775807
 (1 row)
 
 select interval '153722867280.912930117 minutes';
-        interval         
--------------------------
- 2562047788:00:54.775807
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
 (1 row)
 
 select interval '-153722867280.912930133 minutes';
-         interval         
+         ?column?         
 --------------------------
- -2562047788:00:54.775808
+ -2562047788:00:54.775807
 (1 row)
 
 select interval '9223372036854.775807 seconds';
-        interval         
--------------------------
- 2562047788:00:54.775807
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
 (1 row)
 
 select interval '-9223372036854.775808 seconds';
-         interval         
+         ?column?         
 --------------------------
- -2562047788:00:54.775808
+ -2562047788:00:54.775807
 (1 row)
 
 select interval '9223372036854775.807 milliseconds';
-        interval         
--------------------------
- 2562047788:00:54.775807
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
 (1 row)
 
 select interval '-9223372036854775.808 milliseconds';
-         interval         
+         ?column?         
 --------------------------
- -2562047788:00:54.775808
+ -2562047788:00:54.775807
 (1 row)
 
 select interval '9223372036854775807 microseconds';
-        interval         
--------------------------
- 2562047788:00:54.775807
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
 (1 row)
 
 select interval '-9223372036854775808 microseconds';
-         interval         
+         ?column?         
 --------------------------
- -2562047788:00:54.775808
+ -2562047788:00:54.775807
 (1 row)
 
 select interval 'PT2562047788H54.775807S';
-        interval         
--------------------------
- 2562047788:00:54.775807
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "PT2562047788H54.775807S"
 select interval 'PT-2562047788H-54.775808S';
-         interval         
---------------------------
- -2562047788:00:54.775808
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "PT-2562047788H-54.775808S"
 select interval 'PT2562047788:00:54.775807';
-        interval         
--------------------------
- 2562047788:00:54.775807
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "PT2562047788:00:54.775807"
 select interval 'PT2562047788.0152155019444';
-        interval         
--------------------------
- 2562047788:00:54.775429
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "PT2562047788.0152155019444"
 select interval 'PT-2562047788.0152155022222';
-         interval         
---------------------------
- -2562047788:00:54.775429
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "PT-2562047788.0152155022222"
 -- overflow each date/time field
 select interval '2147483648 years';
-ERROR:  interval field value out of range: "2147483648 years"
+                              ?column?                              
+--------------------------------------------------------------------
+ -178956970 years -8 mons -2147483648 days -2562047788:00:54.775808
+(1 row)
+
 select interval '-2147483649 years';
-ERROR:  interval field value out of range: "-2147483649 years"
+                              ?column?                              
+--------------------------------------------------------------------
+ -178956970 years -8 mons -2147483648 days -2562047788:00:54.775808
+(1 row)
+
 select interval '2147483648 months';
-ERROR:  interval field value out of range: "2147483648 months"
+                              ?column?                              
+--------------------------------------------------------------------
+ -178956970 years -8 mons -2147483648 days -2562047788:00:54.775808
+(1 row)
+
 select interval '-2147483649 months';
-ERROR:  interval field value out of range: "-2147483649 months"
+             ?column?              
+-----------------------------------
+ -178956970 years -8 mons -30 days
+(1 row)
+
 select interval '2147483648 days';
-ERROR:  interval field value out of range: "2147483648 days"
+                 ?column?                  
+-------------------------------------------
+ -2147483648 days -2562047788:00:54.775808
+(1 row)
+
 select interval '-2147483649 days';
-ERROR:  interval field value out of range: "-2147483649 days"
+          ?column?          
+----------------------------
+ -2147483648 days -24:00:00
+(1 row)
+
 select interval '2562047789 hours';
-ERROR:  interval field value out of range: "2562047789 hours"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '-2562047789 hours';
-ERROR:  interval field value out of range: "-2562047789 hours"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '153722867281 minutes';
-ERROR:  interval field value out of range: "153722867281 minutes"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '-153722867281 minutes';
-ERROR:  interval field value out of range: "-153722867281 minutes"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '9223372036855 seconds';
-ERROR:  interval field value out of range: "9223372036855 seconds"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '-9223372036855 seconds';
-ERROR:  interval field value out of range: "-9223372036855 seconds"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '9223372036854777 millisecond';
-ERROR:  interval field value out of range: "9223372036854777 millisecond"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '-9223372036854777 millisecond';
-ERROR:  interval field value out of range: "-9223372036854777 millisecond"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775807
+(1 row)
+
 select interval '9223372036854775808 microsecond';
-ERROR:  interval field value out of range: "9223372036854775808 microsecond"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775808
+(1 row)
+
 select interval '-9223372036854775809 microsecond';
-ERROR:  interval field value out of range: "-9223372036854775809 microsecond"
+         ?column?         
+--------------------------
+ -2562047788:00:54.775807
+(1 row)
+
 select interval 'P2147483648';
-ERROR:  interval field value out of range: "P2147483648"
+ERROR:  invalid input syntax for type interval: "P2147483648"
 select interval 'P-2147483649';
-ERROR:  interval field value out of range: "P-2147483649"
+ERROR:  invalid input syntax for type interval: "P-2147483649"
 select interval 'P1-2147483647-2147483647';
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "P1-2147483647-2147483647"
 select interval 'PT2562047789';
-ERROR:  interval field value out of range: "PT2562047789"
+ERROR:  invalid input syntax for type interval: "PT2562047789"
 select interval 'PT-2562047789';
-ERROR:  interval field value out of range: "PT-2562047789"
+ERROR:  invalid input syntax for type interval: "PT-2562047789"
 -- overflow with date/time unit aliases
 select interval '2147483647 weeks';
-ERROR:  interval field value out of range: "2147483647 weeks"
+                 ?column?                  
+-------------------------------------------
+ -2147483648 days -2562047788:00:54.775808
+(1 row)
+
 select interval '-2147483648 weeks';
-ERROR:  interval field value out of range: "-2147483648 weeks"
+                 ?column?                  
+-------------------------------------------
+ -2147483648 days -2562047788:00:54.775808
+(1 row)
+
 select interval '2147483647 decades';
-ERROR:  interval field value out of range: "2147483647 decades"
+ERROR:  invalid input syntax for type interval: "2147483647 decades"
 select interval '-2147483648 decades';
-ERROR:  interval field value out of range: "-2147483648 decades"
+ERROR:  invalid input syntax for type interval: "-2147483648 decades"
 select interval '2147483647 centuries';
-ERROR:  interval field value out of range: "2147483647 centuries"
+ERROR:  invalid input syntax for type interval: "2147483647 centuries"
 select interval '-2147483648 centuries';
-ERROR:  interval field value out of range: "-2147483648 centuries"
+ERROR:  invalid input syntax for type interval: "-2147483648 centuries"
 select interval '2147483647 millennium';
-ERROR:  interval field value out of range: "2147483647 millennium"
+ERROR:  invalid input syntax for type interval: "2147483647 millennium"
 select interval '-2147483648 millennium';
-ERROR:  interval field value out of range: "-2147483648 millennium"
+ERROR:  invalid input syntax for type interval: "-2147483648 millennium"
 select interval '1 week 2147483647 days';
-ERROR:  interval field value out of range: "1 week 2147483647 days"
+     ?column?     
+------------------
+ -2147483642 days
+(1 row)
+
 select interval '-1 week -2147483648 days';
-ERROR:  interval field value out of range: "-1 week -2147483648 days"
+    ?column?     
+-----------------
+ 2147483641 days
+(1 row)
+
 select interval '2147483647 days 1 week';
-ERROR:  interval field value out of range: "2147483647 days 1 week"
+ERROR:  invalid input syntax for type interval: "2147483647 days 1 week"
 select interval '-2147483648 days -1 week';
-ERROR:  interval field value out of range: "-2147483648 days -1 week"
+ERROR:  invalid input syntax for type interval: "-2147483648 days -1 week"
 select interval 'P1W2147483647D';
-ERROR:  interval field value out of range: "P1W2147483647D"
+ERROR:  invalid input syntax for type interval: "P1W2147483647D"
 select interval 'P-1W-2147483648D';
-ERROR:  interval field value out of range: "P-1W-2147483648D"
+ERROR:  invalid input syntax for type interval: "P-1W-2147483648D"
 select interval 'P2147483647D1W';
-ERROR:  interval field value out of range: "P2147483647D1W"
+ERROR:  invalid input syntax for type interval: "P2147483647D1W"
 select interval 'P-2147483648D-1W';
-ERROR:  interval field value out of range: "P-2147483648D-1W"
+ERROR:  invalid input syntax for type interval: "P-2147483648D-1W"
 select interval '1 decade 2147483647 years';
-ERROR:  interval field value out of range: "1 decade 2147483647 years"
+ERROR:  invalid input syntax for type interval: "1 decade 2147483647 years"
 select interval '1 century 2147483647 years';
-ERROR:  interval field value out of range: "1 century 2147483647 years"
+ERROR:  invalid input syntax for type interval: "1 century 2147483647 years"
 select interval '1 millennium 2147483647 years';
-ERROR:  interval field value out of range: "1 millennium 2147483647 years"
+ERROR:  invalid input syntax for type interval: "1 millennium 2147483647 years"
 select interval '-1 decade -2147483648 years';
-ERROR:  interval field value out of range: "-1 decade -2147483648 years"
+ERROR:  invalid input syntax for type interval: "-1 decade -2147483648 years"
 select interval '-1 century -2147483648 years';
-ERROR:  interval field value out of range: "-1 century -2147483648 years"
+ERROR:  invalid input syntax for type interval: "-1 century -2147483648 years"
 select interval '-1 millennium -2147483648 years';
-ERROR:  interval field value out of range: "-1 millennium -2147483648 years"
+ERROR:  invalid input syntax for type interval: "-1 millennium -2147483648 years"
 select interval '2147483647 years 1 decade';
-ERROR:  interval field value out of range: "2147483647 years 1 decade"
+ERROR:  invalid input syntax for type interval: "2147483647 years 1 decade"
 select interval '2147483647 years 1 century';
-ERROR:  interval field value out of range: "2147483647 years 1 century"
+ERROR:  invalid input syntax for type interval: "2147483647 years 1 century"
 select interval '2147483647 years 1 millennium';
-ERROR:  interval field value out of range: "2147483647 years 1 millennium"
+ERROR:  invalid input syntax for type interval: "2147483647 years 1 millennium"
 select interval '-2147483648 years -1 decade';
-ERROR:  interval field value out of range: "-2147483648 years -1 decade"
+ERROR:  invalid input syntax for type interval: "-2147483648 years -1 decade"
 select interval '-2147483648 years -1 century';
-ERROR:  interval field value out of range: "-2147483648 years -1 century"
+ERROR:  invalid input syntax for type interval: "-2147483648 years -1 century"
 select interval '-2147483648 years -1 millennium';
-ERROR:  interval field value out of range: "-2147483648 years -1 millennium"
+ERROR:  invalid input syntax for type interval: "-2147483648 years -1 millennium"
 -- overflowing with fractional fields - postgres format
 select interval '0.1 millennium 2147483647 months';
-ERROR:  interval field value out of range: "0.1 millennium 2147483647 months"
+ERROR:  invalid input syntax for type interval: "0.1 millennium 2147483647 months"
 select interval '0.1 centuries 2147483647 months';
-ERROR:  interval field value out of range: "0.1 centuries 2147483647 months"
+ERROR:  invalid input syntax for type interval: "0.1 centuries 2147483647 months"
 select interval '0.1 decades 2147483647 months';
-ERROR:  interval field value out of range: "0.1 decades 2147483647 months"
+ERROR:  invalid input syntax for type interval: "0.1 decades 2147483647 months"
 select interval '0.1 yrs 2147483647 months';
-ERROR:  interval field value out of range: "0.1 yrs 2147483647 months"
+ERROR:  invalid input syntax for type interval: "0.1 yrs 2147483647 months"
 select interval '-0.1 millennium -2147483648 months';
-ERROR:  interval field value out of range: "-0.1 millennium -2147483648 months"
+ERROR:  invalid input syntax for type interval: "-0.1 millennium -2147483648 months"
 select interval '-0.1 centuries -2147483648 months';
-ERROR:  interval field value out of range: "-0.1 centuries -2147483648 months"
+ERROR:  invalid input syntax for type interval: "-0.1 centuries -2147483648 months"
 select interval '-0.1 decades -2147483648 months';
-ERROR:  interval field value out of range: "-0.1 decades -2147483648 months"
+ERROR:  invalid input syntax for type interval: "-0.1 decades -2147483648 months"
 select interval '-0.1 yrs -2147483648 months';
-ERROR:  interval field value out of range: "-0.1 yrs -2147483648 months"
+ERROR:  invalid input syntax for type interval: "-0.1 yrs -2147483648 months"
 select interval '2147483647 months 0.1 millennium';
-ERROR:  interval field value out of range: "2147483647 months 0.1 millennium"
+ERROR:  invalid input syntax for type interval: "2147483647 months 0.1 millennium"
 select interval '2147483647 months 0.1 centuries';
-ERROR:  interval field value out of range: "2147483647 months 0.1 centuries"
+ERROR:  invalid input syntax for type interval: "2147483647 months 0.1 centuries"
 select interval '2147483647 months 0.1 decades';
-ERROR:  interval field value out of range: "2147483647 months 0.1 decades"
+ERROR:  invalid input syntax for type interval: "2147483647 months 0.1 decades"
 select interval '2147483647 months 0.1 yrs';
-ERROR:  interval field value out of range: "2147483647 months 0.1 yrs"
+ERROR:  invalid input syntax for type interval: "2147483647 months 0.1 yrs"
 select interval '-2147483648 months -0.1 millennium';
-ERROR:  interval field value out of range: "-2147483648 months -0.1 millennium"
+ERROR:  invalid input syntax for type interval: "-2147483648 months -0.1 millennium"
 select interval '-2147483648 months -0.1 centuries';
-ERROR:  interval field value out of range: "-2147483648 months -0.1 centuries"
+ERROR:  invalid input syntax for type interval: "-2147483648 months -0.1 centuries"
 select interval '-2147483648 months -0.1 decades';
-ERROR:  interval field value out of range: "-2147483648 months -0.1 decades"
+ERROR:  invalid input syntax for type interval: "-2147483648 months -0.1 decades"
 select interval '-2147483648 months -0.1 yrs';
-ERROR:  interval field value out of range: "-2147483648 months -0.1 yrs"
+ERROR:  invalid input syntax for type interval: "-2147483648 months -0.1 yrs"
 select interval '0.1 months 2147483647 days';
-ERROR:  interval field value out of range: "0.1 months 2147483647 days"
+     ?column?     
+------------------
+ -2147483646 days
+(1 row)
+
 select interval '-0.1 months -2147483648 days';
-ERROR:  interval field value out of range: "-0.1 months -2147483648 days"
+    ?column?     
+-----------------
+ 2147483645 days
+(1 row)
+
 select interval '2147483647 days 0.1 months';
-ERROR:  interval field value out of range: "2147483647 days 0.1 months"
+ERROR:  invalid input syntax for type interval: "2147483647 days 0.1 months"
 select interval '-2147483648 days -0.1 months';
-ERROR:  interval field value out of range: "-2147483648 days -0.1 months"
+ERROR:  invalid input syntax for type interval: "-2147483648 days -0.1 months"
 select interval '0.5 weeks 2147483647 days';
-ERROR:  interval field value out of range: "0.5 weeks 2147483647 days"
+          ?column?          
+----------------------------
+ -2147483646 days +12:00:00
+(1 row)
+
 select interval '-0.5 weeks -2147483648 days';
-ERROR:  interval field value out of range: "-0.5 weeks -2147483648 days"
+         ?column?          
+---------------------------
+ 2147483645 days -12:00:00
+(1 row)
+
 select interval '2147483647 days 0.5 weeks';
-ERROR:  interval field value out of range: "2147483647 days 0.5 weeks"
+ERROR:  invalid input syntax for type interval: "2147483647 days 0.5 weeks"
 select interval '-2147483648 days -0.5 weeks';
-ERROR:  interval field value out of range: "-2147483648 days -0.5 weeks"
+ERROR:  invalid input syntax for type interval: "-2147483648 days -0.5 weeks"
 select interval '0.01 months 9223372036854775807 microseconds';
-ERROR:  interval field value out of range: "0.01 months 9223372036854775807 microseconds"
+         ?column?         
+--------------------------
+ -2562047780:48:54.775808
+(1 row)
+
 select interval '-0.01 months -9223372036854775808 microseconds';
-ERROR:  interval field value out of range: "-0.01 months -9223372036854775808 microseconds"
+        ?column?         
+-------------------------
+ 2562047780:48:54.775809
+(1 row)
+
 select interval '9223372036854775807 microseconds 0.01 months';
-ERROR:  interval field value out of range: "9223372036854775807 microseconds 0.01 months"
+ERROR:  invalid input syntax for type interval: "9223372036854775807 microseconds 0.01 months"
 select interval '-9223372036854775808 microseconds -0.01 months';
-ERROR:  interval field value out of range: "-9223372036854775808 microseconds -0.01 months"
+ERROR:  invalid input syntax for type interval: "-9223372036854775808 microseconds -0.01 months"
 select interval '0.1 weeks 9223372036854775807 microseconds';
-ERROR:  interval field value out of range: "0.1 weeks 9223372036854775807 microseconds"
+         ?column?         
+--------------------------
+ -2562047771:12:54.775808
+(1 row)
+
 select interval '-0.1 weeks -9223372036854775808 microseconds';
-ERROR:  interval field value out of range: "-0.1 weeks -9223372036854775808 microseconds"
+        ?column?         
+-------------------------
+ 2562047771:12:54.775809
+(1 row)
+
 select interval '9223372036854775807 microseconds 0.1 weeks';
-ERROR:  interval field value out of range: "9223372036854775807 microseconds 0.1 weeks"
+ERROR:  invalid input syntax for type interval: "9223372036854775807 microseconds 0.1 weeks"
 select interval '-9223372036854775808 microseconds -0.1 weeks';
-ERROR:  interval field value out of range: "-9223372036854775808 microseconds -0.1 weeks"
+ERROR:  invalid input syntax for type interval: "-9223372036854775808 microseconds -0.1 weeks"
 select interval '0.1 days 9223372036854775807 microseconds';
-ERROR:  interval field value out of range: "0.1 days 9223372036854775807 microseconds"
+         ?column?         
+--------------------------
+ -2562047785:36:54.775808
+(1 row)
+
 select interval '-0.1 days -9223372036854775808 microseconds';
-ERROR:  interval field value out of range: "-0.1 days -9223372036854775808 microseconds"
+        ?column?         
+-------------------------
+ 2562047785:36:54.775809
+(1 row)
+
 select interval '9223372036854775807 microseconds 0.1 days';
-ERROR:  interval field value out of range: "9223372036854775807 microseconds 0.1 days"
+ERROR:  invalid input syntax for type interval: "9223372036854775807 microseconds 0.1 days"
 select interval '-9223372036854775808 microseconds -0.1 days';
-ERROR:  interval field value out of range: "-9223372036854775808 microseconds -0.1 days"
+ERROR:  invalid input syntax for type interval: "-9223372036854775808 microseconds -0.1 days"
 -- overflowing with fractional fields - ISO8601 format
 select interval 'P0.1Y2147483647M';
-ERROR:  interval field value out of range: "P0.1Y2147483647M"
+ERROR:  invalid input syntax for type interval: "P0.1Y2147483647M"
 select interval 'P-0.1Y-2147483648M';
-ERROR:  interval field value out of range: "P-0.1Y-2147483648M"
+ERROR:  invalid input syntax for type interval: "P-0.1Y-2147483648M"
 select interval 'P2147483647M0.1Y';
-ERROR:  interval field value out of range: "P2147483647M0.1Y"
+ERROR:  invalid input syntax for type interval: "P2147483647M0.1Y"
 select interval 'P-2147483648M-0.1Y';
-ERROR:  interval field value out of range: "P-2147483648M-0.1Y"
+ERROR:  invalid input syntax for type interval: "P-2147483648M-0.1Y"
 select interval 'P0.1M2147483647D';
-ERROR:  interval field value out of range: "P0.1M2147483647D"
+ERROR:  invalid input syntax for type interval: "P0.1M2147483647D"
 select interval 'P-0.1M-2147483648D';
-ERROR:  interval field value out of range: "P-0.1M-2147483648D"
+ERROR:  invalid input syntax for type interval: "P-0.1M-2147483648D"
 select interval 'P2147483647D0.1M';
-ERROR:  interval field value out of range: "P2147483647D0.1M"
+ERROR:  invalid input syntax for type interval: "P2147483647D0.1M"
 select interval 'P-2147483648D-0.1M';
-ERROR:  interval field value out of range: "P-2147483648D-0.1M"
+ERROR:  invalid input syntax for type interval: "P-2147483648D-0.1M"
 select interval 'P0.5W2147483647D';
-ERROR:  interval field value out of range: "P0.5W2147483647D"
+ERROR:  invalid input syntax for type interval: "P0.5W2147483647D"
 select interval 'P-0.5W-2147483648D';
-ERROR:  interval field value out of range: "P-0.5W-2147483648D"
+ERROR:  invalid input syntax for type interval: "P-0.5W-2147483648D"
 select interval 'P2147483647D0.5W';
-ERROR:  interval field value out of range: "P2147483647D0.5W"
+ERROR:  invalid input syntax for type interval: "P2147483647D0.5W"
 select interval 'P-2147483648D-0.5W';
-ERROR:  interval field value out of range: "P-2147483648D-0.5W"
+ERROR:  invalid input syntax for type interval: "P-2147483648D-0.5W"
 select interval 'P0.01MT2562047788H54.775807S';
-ERROR:  interval field value out of range: "P0.01MT2562047788H54.775807S"
+ERROR:  invalid input syntax for type interval: "P0.01MT2562047788H54.775807S"
 select interval 'P-0.01MT-2562047788H-54.775808S';
-ERROR:  interval field value out of range: "P-0.01MT-2562047788H-54.775808S"
+ERROR:  invalid input syntax for type interval: "P-0.01MT-2562047788H-54.775808S"
 select interval 'P0.1DT2562047788H54.775807S';
-ERROR:  interval field value out of range: "P0.1DT2562047788H54.775807S"
+ERROR:  invalid input syntax for type interval: "P0.1DT2562047788H54.775807S"
 select interval 'P-0.1DT-2562047788H-54.775808S';
-ERROR:  interval field value out of range: "P-0.1DT-2562047788H-54.775808S"
+ERROR:  invalid input syntax for type interval: "P-0.1DT-2562047788H-54.775808S"
 select interval 'PT2562047788.1H54.775807S';
-ERROR:  interval field value out of range: "PT2562047788.1H54.775807S"
+ERROR:  invalid input syntax for type interval: "PT2562047788.1H54.775807S"
 select interval 'PT-2562047788.1H-54.775808S';
-ERROR:  interval field value out of range: "PT-2562047788.1H-54.775808S"
+ERROR:  invalid input syntax for type interval: "PT-2562047788.1H-54.775808S"
 select interval 'PT2562047788H0.1M54.775807S';
-ERROR:  interval field value out of range: "PT2562047788H0.1M54.775807S"
+ERROR:  invalid input syntax for type interval: "PT2562047788H0.1M54.775807S"
 select interval 'PT-2562047788H-0.1M-54.775808S';
-ERROR:  interval field value out of range: "PT-2562047788H-0.1M-54.775808S"
+ERROR:  invalid input syntax for type interval: "PT-2562047788H-0.1M-54.775808S"
 -- overflowing with fractional fields - ISO8601 alternative format
 select interval 'P0.1-2147483647-00';
-ERROR:  interval field value out of range: "P0.1-2147483647-00"
+ERROR:  invalid input syntax for type interval: "P0.1-2147483647-00"
 select interval 'P00-0.1-2147483647';
-ERROR:  interval field value out of range: "P00-0.1-2147483647"
+ERROR:  invalid input syntax for type interval: "P00-0.1-2147483647"
 select interval 'P00-0.01-00T2562047788:00:54.775807';
-ERROR:  interval field value out of range: "P00-0.01-00T2562047788:00:54.775807"
+ERROR:  invalid input syntax for type interval: "P00-0.01-00T2562047788:00:54.775807"
 select interval 'P00-00-0.1T2562047788:00:54.775807';
-ERROR:  interval field value out of range: "P00-00-0.1T2562047788:00:54.775807"
+ERROR:  invalid input syntax for type interval: "P00-00-0.1T2562047788:00:54.775807"
 select interval 'PT2562047788.1:00:54.775807';
-ERROR:  interval field value out of range: "PT2562047788.1:00:54.775807"
+ERROR:  invalid input syntax for type interval: "PT2562047788.1:00:54.775807"
 select interval 'PT2562047788:01.:54.775807';
-ERROR:  interval field value out of range: "PT2562047788:01.:54.775807"
+ERROR:  invalid input syntax for type interval: "PT2562047788:01.:54.775807"
 -- overflowing with fractional fields - SQL standard format
 select interval '0.1 2562047788:0:54.775807';
-ERROR:  interval field value out of range: "0.1 2562047788:0:54.775807"
+         ?column?         
+--------------------------
+ -2562047785:36:54.775808
+(1 row)
+
 select interval '0.1 2562047788:0:54.775808 ago';
-ERROR:  interval field value out of range: "0.1 2562047788:0:54.775808 ago"
+ERROR:  invalid input syntax for type interval: "0.1 2562047788:0:54.775808 ago"
 select interval '2562047788.1:0:54.775807';
-ERROR:  interval field value out of range: "2562047788.1:0:54.775807"
+         ?column?         
+--------------------------
+ -2562047788:00:00.000001
+(1 row)
+
 select interval '2562047788.1:0:54.775808 ago';
-ERROR:  interval field value out of range: "2562047788.1:0:54.775808 ago"
+ERROR:  invalid input syntax for type interval: "2562047788.1:0:54.775808 ago"
 select interval '2562047788:0.1:54.775807';
-ERROR:  invalid input syntax for type interval: "2562047788:0.1:54.775807"
+         ?column?         
+--------------------------
+ -2562047788:00:48.775808
+(1 row)
+
 select interval '2562047788:0.1:54.775808 ago';
 ERROR:  invalid input syntax for type interval: "2562047788:0.1:54.775808 ago"
 -- overflowing using AGO with INT_MIN
 select interval '-2147483648 months ago';
-ERROR:  interval field value out of range: "-2147483648 months ago"
+ERROR:  invalid input syntax for type interval: "-2147483648 months ago"
 select interval '-2147483648 days ago';
-ERROR:  interval field value out of range: "-2147483648 days ago"
+ERROR:  invalid input syntax for type interval: "-2147483648 days ago"
 select interval '-9223372036854775808 microseconds ago';
-ERROR:  interval field value out of range: "-9223372036854775808 microseconds ago"
+ERROR:  invalid input syntax for type interval: "-9223372036854775808 microseconds ago"
 select interval '-2147483648 months -2147483648 days -9223372036854775808 microseconds ago';
-ERROR:  interval field value out of range: "-2147483648 months -2147483648 days -9223372036854775808 microseconds ago"
+ERROR:  invalid input syntax for type interval: "-2147483648 months -2147483648 days -9223372036854775808 microseconds ago"
 -- overflowing using make_interval
 select make_interval(years := 178956971);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(years := -178956971);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(years := 1, months := 2147483647);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(years := -1, months := -2147483648);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(weeks := 306783379);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(weeks := -306783379);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(weeks := 1, days := 2147483647);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(weeks := -1, days := -2147483648);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(secs := 1e308);
-ERROR:  value out of range: overflow
+ERROR:  function make_interval does not exist
 select make_interval(secs := 1e18);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(secs := -1e18);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(mins := 1, secs := 9223372036800.0);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(mins := -1, secs := -9223372036800.0);
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 -- test that INT_MIN number is formatted properly
 SET IntervalStyle to postgres;
+ERROR:  only support select and create table statement
 select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
-                              interval                              
---------------------------------------------------------------------
- -178956970 years -7 mons -2147483648 days -2562047788:00:54.775808
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483648 days -9223372036854775808 us"
 SET IntervalStyle to sql_standard;
+ERROR:  only support select and create table statement
 select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
-                     interval                      
----------------------------------------------------
- -178956970-7 -2147483648 -2562047788:00:54.775808
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483648 days -9223372036854775808 us"
 SET IntervalStyle to iso_8601;
+ERROR:  only support select and create table statement
 select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
-                      interval                       
------------------------------------------------------
- P-178956970Y-7M-2147483648DT-2562047788H-54.775808S
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483648 days -9223372036854775808 us"
 --SET IntervalStyle to postgres_verbose;
 select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
-                      interval                       
------------------------------------------------------
- P-178956970Y-7M-2147483648DT-2562047788H-54.775808S
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483648 days -9223372036854775808 us"
 -- check that '30 days' equals '1 month' according to the hash function
 select '30 days'::interval = '1 month'::interval as t;
  t 
@@ -1445,56 +1377,28 @@
 (1 row)
 
 select interval_hash('30 days'::interval) = interval_hash('1 month'::interval) as t;
- t 
----
- t
-(1 row)
-
+ERROR:  function interval_hash does not exist
 -- numeric constructor
 select make_interval(years := 2);
- make_interval 
----------------
- P2Y
-(1 row)
-
+ERROR:  function make_interval does not exist
 select make_interval(years := 1, months := 6);
- make_interval 
----------------
- P1Y6M
-(1 row)
-
+ERROR:  function make_interval does not exist
 select make_interval(years := 1, months := -1, weeks := 5, days := -7, hours := 25, mins := -180);
- make_interval 
----------------
- P11M28DT22H
-(1 row)
-
+ERROR:  function make_interval does not exist
 select make_interval() = make_interval(years := 0, months := 0, weeks := 0, days := 0, mins := 0, secs := 0.0);
- ?column? 
-----------
- t
-(1 row)
-
+ERROR:  function make_interval does not exist
 select make_interval(hours := -2, mins := -10, secs := -25.3);
-  make_interval  
------------------
- PT-2H-10M-25.3S
-(1 row)
-
+ERROR:  function make_interval does not exist
 select make_interval(years := 'inf'::float::int);
-ERROR:  integer out of range
+ERROR:  function make_interval does not exist
 select make_interval(months := 'NaN'::float::int);
-ERROR:  integer out of range
+ERROR:  function make_interval does not exist
 select make_interval(secs := 'inf');
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(secs := 'NaN');
-ERROR:  interval out of range
+ERROR:  function make_interval does not exist
 select make_interval(secs := 7e12);
-    make_interval    
----------------------
- PT1944444444H26M40S
-(1 row)
-
+ERROR:  function make_interval does not exist
 --
 -- test EXTRACT
 --
@@ -1513,72 +1417,27 @@
     EXTRACT(MILLENNIUM FROM f1) AS MILLENNIUM,
     EXTRACT(EPOCH FROM f1) AS EPOCH
     FROM INTERVAL_TBL order by 1;
-     f1     | microsecond | millisecond |   second   | minute | hour | day | month | quarter | year | decade | century | millennium |       epoch       
-------------+-------------+-------------+------------+--------+------+-----+-------+---------+------+--------+---------+------------+-------------------
- PT-14S     |   -14000000 |  -14000.000 | -14.000000 |      0 |    0 |   0 |     0 |       1 |    0 |      0 |       0 |          0 |        -14.000000
- PT1M       |           0 |       0.000 |   0.000000 |      1 |    0 |   0 |     0 |       1 |    0 |      0 |       0 |          0 |         60.000000
- PT5H       |           0 |       0.000 |   0.000000 |      0 |    5 |   0 |     0 |       1 |    0 |      0 |       0 |          0 |      18000.000000
- P1DT2H3M4S |     4000000 |    4000.000 |   4.000000 |      3 |    2 |   1 |     0 |       1 |    0 |      0 |       0 |          0 |      93784.000000
- P10D       |           0 |       0.000 |   0.000000 |      0 |    0 |  10 |     0 |       1 |    0 |      0 |       0 |          0 |     864000.000000
- P3M        |           0 |       0.000 |   0.000000 |      0 |    0 |   0 |     3 |       2 |    0 |      0 |       0 |          0 |    7776000.000000
- P5M        |           0 |       0.000 |   0.000000 |      0 |    0 |   0 |     5 |       2 |    0 |      0 |       0 |          0 |   12960000.000000
- P5MT12H    |           0 |       0.000 |   0.000000 |      0 |   12 |   0 |     5 |       2 |    0 |      0 |       0 |          0 |   13003200.000000
- P6Y        |           0 |       0.000 |   0.000000 |      0 |    0 |   0 |     0 |       1 |    6 |      0 |       0 |          0 |  189345600.000000
- P34Y       |           0 |       0.000 |   0.000000 |      0 |    0 |   0 |     0 |       1 |   34 |      3 |       0 |          0 | 1072958400.000000
-(10 rows)
-
+ERROR:  function DATE_PART(Unknown, Interval) does not exist
 SELECT EXTRACT(FORTNIGHT FROM INTERVAL '2 days');  -- error
-ERROR:  unit "fortnight" not recognized for type interval
+ERROR:  timestamp units "fortnight" not recognized
 SELECT EXTRACT(TIMEZONE FROM INTERVAL '2 days');  -- error
-ERROR:  unit "timezone" not supported for type interval
+ERROR:  timestamp units "timezone" not recognized
 SELECT EXTRACT(DECADE FROM INTERVAL '100 y');
- extract 
----------
-      10
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "100 y"
 SELECT EXTRACT(DECADE FROM INTERVAL '99 y');
- extract 
----------
-       9
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "99 y"
 SELECT EXTRACT(DECADE FROM INTERVAL '-99 y');
- extract 
----------
-      -9
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-99 y"
 SELECT EXTRACT(DECADE FROM INTERVAL '-100 y');
- extract 
----------
-     -10
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-100 y"
 SELECT EXTRACT(CENTURY FROM INTERVAL '100 y');
- extract 
----------
-       1
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "100 y"
 SELECT EXTRACT(CENTURY FROM INTERVAL '99 y');
- extract 
----------
-       0
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "99 y"
 SELECT EXTRACT(CENTURY FROM INTERVAL '-99 y');
- extract 
----------
-       0
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-99 y"
 SELECT EXTRACT(CENTURY FROM INTERVAL '-100 y');
- extract 
----------
-      -1
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-100 y"
 -- date_part implementation is mostly the same as extract, so only
 -- test a few cases for additional coverage.
 SELECT f1,
@@ -1587,56 +1446,23 @@
     date_part('second', f1) AS second,
     date_part('epoch', f1) AS epoch
     FROM INTERVAL_TBL order by 1;
-     f1     | microsecond | millisecond | second |   epoch    
-------------+-------------+-------------+--------+------------
- PT-14S     |   -14000000 |      -14000 |    -14 |        -14
- PT1M       |           0 |           0 |      0 |         60
- PT5H       |           0 |           0 |      0 |      18000
- P1DT2H3M4S |     4000000 |        4000 |      4 |      93784
- P10D       |           0 |           0 |      0 |     864000
- P3M        |           0 |           0 |      0 |    7776000
- P5M        |           0 |           0 |      0 |   12960000
- P5MT12H    |           0 |           0 |      0 |   13003200
- P6Y        |           0 |           0 |      0 |  189345600
- P34Y       |           0 |           0 |      0 | 1072958400
-(10 rows)
-
+ERROR:  function DATE_PART(Unknown, Interval) does not exist
 -- internal overflow test case
 SELECT extract(epoch from interval '1000000000 days');
-        extract        
------------------------
- 86400000000000.000000
-(1 row)
-
+ERROR:  timestamp units "epoch" not recognized
 --
 -- test infinite intervals
 --
 -- largest finite intervals
 SELECT interval '-2147483648 months -2147483648 days -9223372036854775807 us';
-                      interval                       
------------------------------------------------------
- P-178956970Y-8M-2147483648DT-2562047788H-54.775807S
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-2147483648 months -2147483648 days -9223372036854775807 us"
 SELECT interval '2147483647 months 2147483647 days 9223372036854775806 us';
-                    interval                    
-------------------------------------------------
- P178956970Y7M2147483647DT2562047788H54.775806S
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "2147483647 months 2147483647 days 9223372036854775806 us"
 -- infinite intervals
 SELECT interval '-2147483648 months -2147483648 days -9223372036854775808 us';
- interval  
------------
- -infinity
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "-2147483648 months -2147483648 days -9223372036854775808 us"
 SELECT interval '2147483647 months 2147483647 days 9223372036854775807 us';
- interval 
-----------
- infinity
-(1 row)
-
+ERROR:  invalid input syntax for type interval: "2147483647 months 2147483647 days 9223372036854775807 us"
 CREATE TABLE INFINITE_INTERVAL_TBL (i interval);
 --INSERT INTO INFINITE_INTERVAL_TBL VALUES ('infinity'), ('-infinity'), ('1 year 2 days 3 hours');
 --SELECT i, isfinite(i) FROM INFINITE_INTERVAL_TBL;
@@ -1654,6 +1480,7 @@
 END
 $$
 LANGUAGE plpgsql;
+ERROR:  only support select and create table statement
 SELECT d AS date, i AS interval,
        eval(format('date %L + interval %L', d, i)) AS plus,
        eval(format('date %L - interval %L', d, i)) AS minus
@@ -1662,16 +1489,7 @@
              (date 'infinity')) AS t1(d),
      (VALUES (interval '-infinity'),
              (interval 'infinity')) AS t2(i);
-    date    | interval  |          plus          |         minus          
-------------+-----------+------------------------+------------------------
- -infinity  | -infinity | -infinity              | timestamp out of range
- -infinity  | infinity  | timestamp out of range | -infinity
- 1995-08-06 | -infinity | -infinity              | infinity
- 1995-08-06 | infinity  | infinity               | -infinity
- infinity   | -infinity | timestamp out of range | infinity
- infinity   | infinity  | infinity               | timestamp out of range
-(6 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT i1 AS interval1, i2 AS interval2,
        eval(format('interval %L + interval %L', i1, i2)) AS plus,
        eval(format('interval %L - interval %L', i1, i2)) AS minus
@@ -1681,27 +1499,15 @@
      (VALUES (interval '-infinity'),
              (interval '10 days'),
              (interval 'infinity')) AS t2(i2);
- interval1 | interval2 |         plus          |         minus         
------------+-----------+-----------------------+-----------------------
- -infinity | -infinity | -infinity             | interval out of range
- -infinity | P10D      | -infinity             | -infinity
- -infinity | infinity  | interval out of range | -infinity
- P2M       | -infinity | -infinity             | infinity
- P2M       | P10D      | P2M10D                | P2M-10D
- P2M       | infinity  | infinity              | -infinity
- infinity  | -infinity | interval out of range | infinity
- infinity  | P10D      | infinity              | infinity
- infinity  | infinity  | infinity              | interval out of range
-(9 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT interval '2147483646 months 2147483646 days 9223372036854775806 us' + interval '1 month 1 day 1 us';
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "2147483646 months 2147483646 days 9223372036854775806 us"
 SELECT interval '-2147483647 months -2147483647 days -9223372036854775807 us' + interval '-1 month -1 day -1 us';
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483647 days -9223372036854775807 us"
 SELECT interval '2147483646 months 2147483646 days 9223372036854775806 us' - interval '-1 month -1 day -1 us';
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "2147483646 months 2147483646 days 9223372036854775806 us"
 SELECT interval '-2147483647 months -2147483647 days -9223372036854775807 us' - interval '1 month 1 day 1 us';
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483647 days -9223372036854775807 us"
 SELECT t AS timestamp, i AS interval,
        eval(format('timestamp %L + interval %L', t, i)) AS plus,
        eval(format('timestamp %L - interval %L', t, i)) AS minus
@@ -1710,16 +1516,7 @@
              (timestamp 'infinity')) AS t1(t),
      (VALUES (interval '-infinity'),
              (interval 'infinity')) AS t2(i);
-      timestamp      | interval  |          plus          |         minus          
----------------------+-----------+------------------------+------------------------
- -infinity           | -infinity | -infinity              | timestamp out of range
- -infinity           | infinity  | timestamp out of range | -infinity
- 1995-08-06 12:30:15 | -infinity | -infinity              | infinity
- 1995-08-06 12:30:15 | infinity  | infinity               | -infinity
- infinity            | -infinity | timestamp out of range | infinity
- infinity            | infinity  | infinity               | timestamp out of range
-(6 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT t AT TIME ZONE 'GMT' AS timestamptz, i AS interval,
        eval(format('timestamptz %L + interval %L', t, i)) AS plus,
        eval(format('timestamptz %L - interval %L', t, i)) AS minus
@@ -1728,16 +1525,7 @@
              (timestamptz 'infinity')) AS t1(t),
      (VALUES (interval '-infinity'),
              (interval 'infinity')) AS t2(i);
-     timestamptz     | interval  |          plus          |         minus          
----------------------+-----------+------------------------+------------------------
- -infinity           | -infinity | -infinity              | timestamp out of range
- -infinity           | infinity  | timestamp out of range | -infinity
- 1995-08-06 12:30:15 | -infinity | -infinity              | infinity
- 1995-08-06 12:30:15 | infinity  | infinity               | -infinity
- infinity            | -infinity | timestamp out of range | infinity
- infinity            | infinity  | infinity               | timestamp out of range
-(6 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- time +/- infinite interval not supported
 --SELECT time '11:27:42' + interval 'infinity';
 --SELECT time '11:27:42' + interval '-infinity';
@@ -1757,10 +1545,7 @@
     lhst.i <> rhst.i AS ne
     FROM INFINITE_INTERVAL_TBL lhst CROSS JOIN INFINITE_INTERVAL_TBL rhst
     WHERE NOT isfinite(lhst.i);
- lhs | rhs | lt | le | eq | gt | ge | ne 
------+-----+----+----+----+----+----+----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 SELECT i AS interval,
     -i AS um,
     i * 2.0 AS mul,
@@ -1771,16 +1556,13 @@
     i / -3.0 AS div_neg
     FROM INFINITE_INTERVAL_TBL
     WHERE NOT isfinite(i);
- interval | um | mul | mul_neg | mul_inf | mul_inf_neg | div | div_neg 
-----------+----+-----+---------+---------+-------------+-----+---------
-(0 rows)
-
+ERROR:  function isfinite does not exist
 SELECT -interval '-2147483647 months -2147483647 days -9223372036854775807 us';
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-2147483647 months -2147483647 days -9223372036854775807 us"
 --SELECT interval 'infinity' * 'nan';
 --SELECT interval '-infinity' * 'nan';
 SELECT interval '-1073741824 months -1073741824 days -4611686018427387904 us' * 2;
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-1073741824 months -1073741824 days -4611686018427387904 us"
 --SELECT interval 'infinity' * 0;
 --SELECT interval '-infinity' * 0;
 --SELECT interval '0 days' * 'infinity'::float;
@@ -1794,23 +1576,17 @@
 --SELECT interval '-infinity' / '-infinity';
 --SELECT interval '-infinity' / 'nan';
 SELECT interval '-1073741824 months -1073741824 days -4611686018427387904 us' / 0.5;
-ERROR:  interval out of range
+ERROR:  invalid input syntax for type interval: "-1073741824 months -1073741824 days -4611686018427387904 us"
 --SELECT date_bin('infinity', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00');
 --SELECT date_bin('-infinity', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00');
 SELECT i AS interval, date_trunc('hour', i)
     FROM INFINITE_INTERVAL_TBL
     WHERE NOT isfinite(i);
- interval | date_trunc 
-----------+------------
-(0 rows)
-
+ERROR:  function isfinite does not exist
 SELECT i AS interval, justify_days(i), justify_hours(i), justify_interval(i)
     FROM INFINITE_INTERVAL_TBL
     WHERE NOT isfinite(i);
- interval | justify_days | justify_hours | justify_interval 
-----------+--------------+---------------+------------------
-(0 rows)
-
+ERROR:  function justify_days does not exist
 --SELECT timezone('infinity'::interval, '1995-08-06 12:12:12'::timestamp);
 --SELECT timezone('-infinity'::interval, '1995-08-06 12:12:12'::timestamp);
 --SELECT timezone('infinity'::interval, '1995-08-06 12:12:12'::timestamptz);
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/select.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/select.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/select.out	2024-03-25 11:16:04.687340610 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/select.out	2024-04-12 10:25:55.578015343 +0800
@@ -219,16 +219,16 @@
 SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;
  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
 ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-       0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
+       9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
-       4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
-       6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
-       9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
+       4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
+       6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
+       0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
 (10 rows)
 
 --
@@ -268,25 +268,25 @@
    WHERE onek2.unique1 > 980;
  unique1 | stringu1 
 ---------+----------
-     981 | TLAAAA
-     982 | ULAAAA
+     997 | JMAAAA
+     995 | HMAAAA
+     999 | LMAAAA
      983 | VLAAAA
-     984 | WLAAAA
-     985 | XLAAAA
-     986 | YLAAAA
-     987 | ZLAAAA
-     988 | AMAAAA
      989 | BMAAAA
+     986 | YLAAAA
+     996 | IMAAAA
+     982 | ULAAAA
+     992 | EMAAAA
      990 | CMAAAA
      991 | DMAAAA
-     992 | EMAAAA
+     984 | WLAAAA
+     981 | TLAAAA
+     998 | KMAAAA
      993 | FMAAAA
      994 | GMAAAA
-     995 | HMAAAA
-     996 | IMAAAA
-     997 | JMAAAA
-     998 | KMAAAA
-     999 | LMAAAA
+     988 | AMAAAA
+     987 | ZLAAAA
+     985 | XLAAAA
 (19 rows)
 
 --RESET enable_seqscan;
@@ -300,68 +300,7 @@
 --
 -- SELECT name, age FROM person*; ??? check if different
 SELECT p.name, p.age FROM person* p;
-  name   | age 
----------+-----
- mike    |  40
- joe     |  20
- sally   |  34
- sandra  |  19
- alex    |  30
- sue     |  50
- denise  |  24
- sarah   |  88
- teresa  |  38
- nan     |  28
- leah    |  68
- wendy   |  78
- melissa |  28
- joan    |  18
- mary    |   8
- jane    |  58
- liza    |  38
- jean    |  28
- jenifer |  38
- juanita |  58
- susan   |  78
- zena    |  98
- martie  |  88
- chris   |  78
- pat     |  18
- zola    |  58
- louise  |  98
- edna    |  18
- bertha  |  88
- sumi    |  38
- koko    |  88
- gina    |  18
- rean    |  48
- sharon  |  78
- paula   |  68
- julie   |  68
- belinda |  38
- karen   |  48
- carina  |  58
- diane   |  18
- esther  |  98
- trudy   |  88
- fanny   |   8
- carmen  |  78
- lita    |  25
- pamela  |  48
- sandy   |  38
- trisha  |  88
- uma     |  78
- velma   |  68
- sharon  |  25
- sam     |  30
- bill    |  20
- fred    |  28
- larry   |  60
- jeff    |  23
- cim     |  30
- linda   |  19
-(58 rows)
-
+ERROR:  relation "public.person" does not exist
 --
 -- awk '{print $1,$2;}' person.data |
 -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
@@ -370,100 +309,22 @@
 -- sort +1nr -2
 --
 SELECT p.name, p.age FROM person* p ORDER BY age DESC, name;
-  name   | age 
----------+-----
- esther  |  98
- louise  |  98
- zena    |  98
- bertha  |  88
- koko    |  88
- martie  |  88
- sarah   |  88
- trisha  |  88
- trudy   |  88
- carmen  |  78
- chris   |  78
- sharon  |  78
- susan   |  78
- uma     |  78
- wendy   |  78
- julie   |  68
- leah    |  68
- paula   |  68
- velma   |  68
- larry   |  60
- carina  |  58
- jane    |  58
- juanita |  58
- zola    |  58
- sue     |  50
- karen   |  48
- pamela  |  48
- rean    |  48
- mike    |  40
- belinda |  38
- jenifer |  38
- liza    |  38
- sandy   |  38
- sumi    |  38
- teresa  |  38
- sally   |  34
- alex    |  30
- cim     |  30
- sam     |  30
- fred    |  28
- jean    |  28
- melissa |  28
- nan     |  28
- lita    |  25
- sharon  |  25
- denise  |  24
- jeff    |  23
- bill    |  20
- joe     |  20
- linda   |  19
- sandra  |  19
- diane   |  18
- edna    |  18
- gina    |  18
- joan    |  18
- pat     |  18
- fanny   |   8
- mary    |   8
-(58 rows)
-
+ERROR:  relation "public.person" does not exist
 --
 -- Test some cases involving whole-row Var referencing a subquery
 --
 select foo from (select 1 offset 0) as foo;
- foo 
------
- (1)
-(1 row)
-
+ERROR:  column "foo" not exist
 select foo from (select null offset 0) as foo;
- foo 
------
- ()
-(1 row)
-
+ERROR:  column "foo" not exist
 select foo from (select 'xyzzy',1,null offset 0) as foo;
-    foo     
-------------
- (xyzzy,1,)
-(1 row)
-
+ERROR:  column "foo" not exist
 --
 -- Test VALUES lists
 --
 select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
     WHERE onek.unique1 = v.i and onek.stringu1 = v.j;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 |  i  |   j    
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----+--------
-     147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx  | 147 | RFAAAA
-     931 |       1 |   1 |    3 |   1 |     11 |       1 |       31 |         131 |       431 |      931 |   2 |    3 | VJAAAA   | BAAAAA   | HHHHxx  | 931 | VJAAAA
-(2 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- a more complex case
 -- looks like we're coding lisp :-)
 select * from onek,
@@ -471,56 +332,26 @@
     (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
     order by i asc limit 1))) bar (i)
   where onek.unique1 = bar.i;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | i 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+---
-       2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx  | 2
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- try VALUES in a subquery
 select * from onek
     where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
     order by unique1;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-       1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
-      20 |     306 |   0 |    0 |   0 |      0 |       0 |       20 |          20 |        20 |       20 |   0 |    1 | UAAAAA   | ULAAAA   | OOOOxx
-      99 |     101 |   1 |    3 |   9 |     19 |       9 |       99 |          99 |        99 |       99 |  18 |   19 | VDAAAA   | XDAAAA   | HHHHxx
-(3 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=31]
 -- VALUES is also legal as a standalone query or a set-operation member
 VALUES (1,2), (3,4+4), (7,77.7);
- column1 | column2 
----------+---------
-       1 |       2
-       3 |       8
-       7 |    77.7
-(3 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 VALUES (1,2), (3,4+4), (7,77.7)
 UNION ALL
 SELECT 2+2, 57
 UNION ALL
 TABLE int8_tbl;
-     column1      |      column2      
-------------------+-------------------
-                1 |                 2
-                3 |                 8
-                7 |              77.7
-                4 |                57
-              123 |               456
-              123 |  4567890123456789
- 4567890123456789 |               123
- 4567890123456789 |  4567890123456789
- 4567890123456789 | -4567890123456789
-(9 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- corner case: VALUES with no columns
 CREATE TEMP TABLE nocols();
 INSERT INTO nocols DEFAULT VALUES;
 SELECT * FROM nocols n, LATERAL (VALUES(n.*)) v;
---
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 --
 -- Test ORDER BY options
 --
@@ -588,6 +419,7 @@
 
 -- check if indexscans do the right things
 CREATE INDEX fooi ON foo (f1);
+ERROR:  only support select and create table statement
 --SET enable_sort = false;
 SELECT * FROM foo ORDER BY f1;
  f1 
@@ -638,7 +470,9 @@
 (7 rows)
 
 DROP INDEX fooi;
+ERROR:  only support select and create table statement
 CREATE INDEX fooi ON foo (f1 DESC);
+ERROR:  only support select and create table statement
 SELECT * FROM foo ORDER BY f1;
  f1 
 ----
@@ -688,7 +522,9 @@
 (7 rows)
 
 DROP INDEX fooi;
+ERROR:  only support select and create table statement
 CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
+ERROR:  only support select and create table statement
 SELECT * FROM foo ORDER BY f1;
  f1 
 ----
@@ -842,51 +678,30 @@
 -- But ORDER BY on a set-valued expression does
 create function sillysrf(int) returns setof int as
   'values (1),(10),(2),($1)' language sql immutable;
+ERROR:  only support select and create table statement
 select sillysrf(42);
- sillysrf 
-----------
-        1
-       10
-        2
-       42
-(4 rows)
-
+ERROR:  function sillysrf does not exist
 select sillysrf(-1) order by 1;
- sillysrf 
-----------
-       -1
-        1
-        2
-       10
-(4 rows)
-
+ERROR:  function sillysrf does not exist
 drop function sillysrf(int);
+ERROR:  only support select and create table statement
 -- X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict
 -- (see bug #5084)
 select * from (values (2),(null),(1)) v(k) where k = k order by k;
- k 
----
- 1
- 2
-(2 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 select * from (values (2),(null),(1)) v(k) where k = k;
- k 
----
- 2
- 1
-(2 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- Test partitioned tables with no partitions, which should be handled the
 -- same as the non-inheritance case when expanding its RTE.
 create table list_parted_tbl (a int,b int) partition by list (a);
 create table list_parted_tbl1 partition of list_parted_tbl
   for values in (1) partition by list(b);
---explain (costs off) select * from list_parted_tbl;
---        QUERY PLAN
---------------------------
- Result
-   One-Time Filter: false
+explain (costs off) select * from list_parted_tbl;
+                        QUERY PLAN                        
+----------------------------------------------------------
+ tuple(table_0) = ProjectOnEmptyTable([], [Int32, Int32])
+ return tuple(table_0)
 (2 rows)
 
 drop table list_parted_tbl;
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/select_distinct.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/select_distinct.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/select_distinct.out	2024-03-25 11:16:04.687340610 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/select_distinct.out	2024-04-12 10:26:05.703022269 +0800
@@ -48,50 +48,7 @@
 SELECT DISTINCT two, string4, ten
    FROM onek
    ORDER BY two using <, string4 using <, ten using <;
- two | string4 | ten 
------+---------+-----
-   0 | AAAAxx  |   0
-   0 | AAAAxx  |   2
-   0 | AAAAxx  |   4
-   0 | AAAAxx  |   6
-   0 | AAAAxx  |   8
-   0 | HHHHxx  |   0
-   0 | HHHHxx  |   2
-   0 | HHHHxx  |   4
-   0 | HHHHxx  |   6
-   0 | HHHHxx  |   8
-   0 | OOOOxx  |   0
-   0 | OOOOxx  |   2
-   0 | OOOOxx  |   4
-   0 | OOOOxx  |   6
-   0 | OOOOxx  |   8
-   0 | VVVVxx  |   0
-   0 | VVVVxx  |   2
-   0 | VVVVxx  |   4
-   0 | VVVVxx  |   6
-   0 | VVVVxx  |   8
-   1 | AAAAxx  |   1
-   1 | AAAAxx  |   3
-   1 | AAAAxx  |   5
-   1 | AAAAxx  |   7
-   1 | AAAAxx  |   9
-   1 | HHHHxx  |   1
-   1 | HHHHxx  |   3
-   1 | HHHHxx  |   5
-   1 | HHHHxx  |   7
-   1 | HHHHxx  |   9
-   1 | OOOOxx  |   1
-   1 | OOOOxx  |   3
-   1 | OOOOxx  |   5
-   1 | OOOOxx  |   7
-   1 | OOOOxx  |   9
-   1 | VVVVxx  |   1
-   1 | VVVVxx  |   3
-   1 | VVVVxx  |   5
-   1 | VVVVxx  |   7
-   1 | VVVVxx  |   9
-(40 rows)
-
+ERROR:  order by not support using
 --
 -- awk '{print $2;}' person.data |
 -- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
@@ -100,52 +57,25 @@
 -- sort -n -r | uniq
 --
 SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
- age 
------
-  98
-  88
-  78
-  68
-  60
-  58
-  50
-  48
-  40
-  38
-  34
-  30
-  28
-  25
-  24
-  23
-  20
-  19
-  18
-   8
-(20 rows)
-
+ERROR:  order by not support using
 --
 -- Check mentioning same column more than once
 --
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT count(*) FROM
   (SELECT DISTINCT two, four, two FROM tenk1) ss;
-                       QUERY PLAN                       
---------------------------------------------------------
- Aggregate
-   Output: count(*)
-   ->  HashAggregate
-         Output: tenk1.two, tenk1.four, tenk1.two
-         Group Key: tenk1.two, tenk1.four
-         ->  Seq Scan on public.tenk1
-               Output: tenk1.two, tenk1.four, tenk1.two
-(7 rows)
+                            QUERY PLAN                            
+------------------------------------------------------------------
+ datum(col_0_literal) = LiteralAggregate(COUNT_NOT_NULL(0) tenk1)
+ tuple(table_1) = [datum(col_0_literal)]
+ return tuple(table_1)
+(3 rows)
 
 SELECT count(*) FROM
   (SELECT DISTINCT two, four, two FROM tenk1) ss;
  count 
 -------
-     4
+ 10000
 (1 row)
 
 --
@@ -153,96 +83,95 @@
 -- aggregation. Force spilling in both cases by setting work_mem low.
 --
 SET work_mem='64kB';
+ERROR:  only support select and create table statement
 -- Produce results with sorting.
 SET enable_hashagg=FALSE;
+ERROR:  only support select and create table statement
 SET jit_above_cost=0;
+ERROR:  only support select and create table statement
 EXPLAIN (costs off)
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
-                   QUERY PLAN                   
-------------------------------------------------
- Unique
-   ->  Sort
-         Sort Key: ((g % 1000))
-         ->  Function Scan on generate_series g
-(4 rows)
-
+ERROR:  function generate_series does not exist
 CREATE TABLE distinct_group_1 AS
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET jit_above_cost TO DEFAULT;
+ERROR:  only support select and create table statement
 CREATE TABLE distinct_group_2 AS
 SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET enable_seqscan = 0;
+ERROR:  only support select and create table statement
 -- Check to see we get an incremental sort plan
 EXPLAIN (costs off)
 SELECT DISTINCT hundred, two FROM tenk1;
-                     QUERY PLAN                      
------------------------------------------------------
- Unique
-   ->  Incremental Sort
-         Sort Key: hundred, two
-         Presorted Key: hundred
-         ->  Index Scan using tenk1_hundred on tenk1
-(5 rows)
+                                                        QUERY PLAN                                                        
+--------------------------------------------------------------------------------------------------------------------------
+ tuple(table_0) = parallel: [tuple(table_0) = IndexScan([column(hundred), column(two)]) + unique), return tuple(table_0)]
+ tuple(table_0) = Unique(tuple(table_0))
+ return tuple(table_0)
+(3 rows)
 
 RESET enable_seqscan;
+ERROR:  only support select and create table statement
 SET enable_hashagg=TRUE;
+ERROR:  only support select and create table statement
 -- Produce results with hash aggregation.
 SET enable_sort=FALSE;
+ERROR:  only support select and create table statement
 SET jit_above_cost=0;
+ERROR:  only support select and create table statement
 EXPLAIN (costs off)
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
-                QUERY PLAN                
-------------------------------------------
- HashAggregate
-   Group Key: (g % 1000)
-   ->  Function Scan on generate_series g
-(3 rows)
-
+ERROR:  function generate_series does not exist
 CREATE TABLE distinct_hash_1 AS
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET jit_above_cost TO DEFAULT;
+ERROR:  only support select and create table statement
 CREATE TABLE distinct_hash_2 AS
 SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET enable_sort=TRUE;
+ERROR:  only support select and create table statement
 SET work_mem TO DEFAULT;
+ERROR:  only support select and create table statement
 -- Compare results
 (SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
   UNION ALL
 (SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1);
- ?column? 
-----------
-(0 rows)
-
+ERROR:  relation "public.distinct_hash_1" does not exist
 (SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
   UNION ALL
 (SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1);
- ?column? 
-----------
-(0 rows)
-
+ERROR:  relation "public.distinct_hash_1" does not exist
 DROP TABLE distinct_hash_1;
+ERROR:  only support select and create table statement
 DROP TABLE distinct_hash_2;
+ERROR:  only support select and create table statement
 DROP TABLE distinct_group_1;
+ERROR:  only support select and create table statement
 DROP TABLE distinct_group_2;
+ERROR:  only support select and create table statement
 -- Test parallel DISTINCT
 SET parallel_tuple_cost=0;
+ERROR:  only support select and create table statement
 SET parallel_setup_cost=0;
+ERROR:  only support select and create table statement
 SET min_parallel_table_scan_size=0;
+ERROR:  only support select and create table statement
 SET max_parallel_workers_per_gather=2;
+ERROR:  only support select and create table statement
 -- Ensure we get a parallel plan
 EXPLAIN (costs off)
 SELECT DISTINCT four FROM tenk1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Unique
-   ->  Gather Merge
-         Workers Planned: 2
-         ->  Sort
-               Sort Key: four
-               ->  HashAggregate
-                     Group Key: four
-                     ->  Parallel Seq Scan on tenk1
-(8 rows)
+                                                 QUERY PLAN                                                  
+-------------------------------------------------------------------------------------------------------------
+ tuple(table_0) = parallel: [tuple(var_5_1) = IndexTopN([columns(four ASC)], unique), return tuple(var_5_1)]
+ tuple(table_0) = Unique(tuple(table_0))
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(4 rows)
 
 -- Ensure the parallel plan produces the correct results
 SELECT DISTINCT four FROM tenk1;
@@ -259,41 +188,30 @@
     RETURN a;
   END;
 $$ LANGUAGE plpgsql PARALLEL UNSAFE;
+ERROR:  only support select and create table statement
 -- Ensure we don't do parallel distinct with a parallel unsafe function
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT distinct_func(1) FROM tenk1;
-                        QUERY PLAN                        
-----------------------------------------------------------
- Unique
-   ->  Sort
-         Sort Key: (distinct_func(1))
-         ->  Index Only Scan using tenk1_hundred on tenk1
-(4 rows)
-
+ERROR:  function distinct_func does not exist
 -- make the function parallel safe
 CREATE OR REPLACE FUNCTION distinct_func(a INT) RETURNS INT AS $$
   BEGIN
     RETURN a;
   END;
 $$ LANGUAGE plpgsql PARALLEL SAFE;
+ERROR:  only support select and create table statement
 -- Ensure we do parallel distinct now that the function is parallel safe
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT distinct_func(1) FROM tenk1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Unique
-   ->  Gather Merge
-         Workers Planned: 2
-         ->  Unique
-               ->  Sort
-                     Sort Key: (distinct_func(1))
-                     ->  Parallel Seq Scan on tenk1
-(7 rows)
-
+ERROR:  function distinct_func does not exist
 RESET max_parallel_workers_per_gather;
+ERROR:  only support select and create table statement
 RESET min_parallel_table_scan_size;
+ERROR:  only support select and create table statement
 RESET parallel_setup_cost;
+ERROR:  only support select and create table statement
 RESET parallel_tuple_cost;
+ERROR:  only support select and create table statement
 --
 -- Test the planner's ability to use a LIMIT 1 instead of a Unique node when
 -- all of the distinct_pathkeys have been marked as redundant
@@ -301,12 +219,14 @@
 -- Ensure we get a plan with a Limit 1
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four FROM tenk1 WHERE four = 0;
-         QUERY PLAN         
-----------------------------
- Limit
-   ->  Seq Scan on tenk1
-         Filter: (four = 0)
-(3 rows)
+                                                                   QUERY PLAN                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_5_1) = IndexFilter(column(four) in [[0,0]]), return tid(var_5_1)]
+ tuple(table_0) = broadcast: [tid(where)] parallel: [tuple(var_6_1) = IndexTopN([columns(four ASC)], tid(where), unique), return tuple(var_6_1)]
+ tuple(table_0) = Unique(tuple(table_0))
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(5 rows)
 
 -- Ensure the above gives us the correct result
 SELECT DISTINCT four FROM tenk1 WHERE four = 0;
@@ -318,28 +238,40 @@
 -- Ensure we get a plan with a Limit 1
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0;
-                 QUERY PLAN                  
----------------------------------------------
- Limit
-   ->  Seq Scan on tenk1
-         Filter: ((two <> 0) AND (four = 0))
-(3 rows)
+                                                                   QUERY PLAN                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------------
+ tid(var_5_1) = parallel: [tid(var_5_2) = IndexFilter(column(four) in [[0,0]]), return tid(var_5_2)]
+ tid(var_5_3) = parallel: [tid(var_5_4) = IndexFilter(column(two) in [[-inf,0), (0,+inf]]), return tid(var_5_4)]
+ tid(where) = [tid(var_5_3) and tid(var_5_1)]
+ tuple(table_0) = broadcast: [tid(where)] parallel: [tuple(var_6_1) = IndexTopN([columns(four ASC)], tid(where), unique), return tuple(var_6_1)]
+ tuple(table_0) = Unique(tuple(table_0))
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(7 rows)
 
 -- Ensure no rows are returned
 SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0;
- four 
-------
+--
 (0 rows)
 
 -- Ensure we get a plan with a Limit 1 when the SELECT list contains constants
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0;
-         QUERY PLAN         
-----------------------------
- Limit
-   ->  Seq Scan on tenk1
-         Filter: (four = 0)
-(3 rows)
+                                                                       QUERY PLAN                                                                       
+--------------------------------------------------------------------------------------------------------------------------------------------------------
+ tuple_with_tid(where_with_value) = parallel: [tuple_with_tid(var_4_1) = IndexFilterWithValue(column(four) in [[0,0]]), return tuple_with_tid(var_4_1)]
+ tuple(table_0) = tuple_with_tid(where_with_value)
+ datum(var_5_1) = TupleAt(tuple(table_0) 0)
+ tuple(var_5_3) = ConstExprTuple([1], table_0)
+ datum(var_5_2) = TupleAt(tuple(var_5_3) 0)
+ tuple(var_5_5) = ConstExprTuple([2], table_0)
+ datum(var_5_4) = TupleAt(tuple(var_5_5) 0)
+ tuple(var_5_7) = ConstExprTuple([3], table_0)
+ datum(var_5_6) = TupleAt(tuple(var_5_7) 0)
+ tuple(table_0) = [datum(var_5_1), datum(var_5_2), datum(var_5_4), datum(var_5_6)]
+ tuple(table_0) = Unique(tuple(table_0))
+ return tuple(table_0)
+(12 rows)
 
 -- Ensure we only get 1 row
 SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0;
@@ -349,25 +281,30 @@
 (1 row)
 
 SET parallel_setup_cost=0;
+ERROR:  only support select and create table statement
 SET min_parallel_table_scan_size=0;
+ERROR:  only support select and create table statement
 SET max_parallel_workers_per_gather=2;
+ERROR:  only support select and create table statement
 -- Ensure we get a plan with a Limit 1 in both partial distinct and final
 -- distinct
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four FROM tenk1 WHERE four = 10;
-                  QUERY PLAN                  
-----------------------------------------------
- Limit
-   ->  Gather
-         Workers Planned: 2
-         ->  Limit
-               ->  Parallel Seq Scan on tenk1
-                     Filter: (four = 10)
-(6 rows)
+                                                                   QUERY PLAN                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_5_1) = IndexFilter(column(four) in [[10,10]]), return tid(var_5_1)]
+ tuple(table_0) = broadcast: [tid(where)] parallel: [tuple(var_6_1) = IndexTopN([columns(four ASC)], tid(where), unique), return tuple(var_6_1)]
+ tuple(table_0) = Unique(tuple(table_0))
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(5 rows)
 
 RESET max_parallel_workers_per_gather;
+ERROR:  only support select and create table statement
 RESET min_parallel_table_scan_size;
+ERROR:  only support select and create table statement
 RESET parallel_setup_cost;
+ERROR:  only support select and create table statement
 --
 -- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
 -- very own regression file.
@@ -379,88 +316,28 @@
 INSERT INTO DISTTABLE VALUES(NULL);
 -- basic cases
 SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
- f1 | not 2 
-----+-------
-  1 | t
-  2 | f
-  3 | t
-    | t
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
- f1 | not null 
-----+----------
-  1 | t
-  2 | t
-  3 | t
-    | f
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
- f1 | false 
-----+-------
-  1 | f
-  2 | f
-  3 | f
-    | f
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
- f1 | not null 
-----+----------
-  1 | t
-  2 | t
-  3 | t
-    | f
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 -- check that optimizer constant-folds it properly
 SELECT 1 IS DISTINCT FROM 2 as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT 2 IS DISTINCT FROM 2 as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT 2 IS DISTINCT FROM null as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT null IS DISTINCT FROM null as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 -- negated form
 SELECT 1 IS NOT DISTINCT FROM 2 as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
 SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
 SELECT 2 IS NOT DISTINCT FROM null as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
 SELECT null IS NOT DISTINCT FROM null as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
diff -U3 /home/longqimin/stdb/thirdparty/pg_regress_input/expected/aggregates.out /home/longqimin/stdb/thirdparty/pg_regress_input/results/aggregates.out
--- /home/longqimin/stdb/thirdparty/pg_regress_input/expected/aggregates.out	2024-03-25 11:16:04.660340585 +0800
+++ /home/longqimin/stdb/thirdparty/pg_regress_input/results/aggregates.out	2024-04-12 10:29:34.269164919 +0800
@@ -5,6 +5,7 @@
 \getenv abs_srcdir PG_ABS_SRCDIR
 -- avoid bit-exact output here because operations may not be bit-exact.
 SET extra_float_digits = 0;
+ERROR:  only support select and create table statement
 -- prepare some test data
 CREATE TABLE aggtest (
 	a 			int2,
@@ -13,6 +14,7 @@
 \set filename :abs_srcdir '/data/agg.data'
 COPY aggtest FROM :'filename';
 ANALYZE aggtest;
+ERROR:  only support select and create table statement
 SELECT avg(four) AS avg_1 FROM onek;
        avg_1        
 --------------------
@@ -26,43 +28,19 @@
 (1 row)
 
 SELECT any_value(v) FROM (VALUES (1), (2), (3)) AS v (v);
- any_value 
------------
-         1
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT any_value(v) FROM (VALUES (NULL)) AS v (v);
- any_value 
------------
- 
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT any_value(v) FROM (VALUES (NULL), (1), (2)) AS v (v);
- any_value 
------------
-         1
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT any_value(v) FROM (VALUES (array['hello', 'world'])) AS v (v);
-   any_value   
----------------
- {hello,world}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- In 7.1, avg(float4) is computed using float8 arithmetic.
 -- Round the result to 3 digits to avoid platform-specific results.
 SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
- avg_107_943 
--------------
-     107.943
-(1 row)
-
+ERROR:  not implemented type_cast case [to=numeric]
 SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
- avg_3_4 
----------
-     3.4
-(1 row)
-
+ERROR:  relation "public.student" does not exist
 SELECT sum(four) AS sum_1500 FROM onek;
  sum_1500 
 ----------
@@ -78,15 +56,11 @@
 SELECT sum(b) AS avg_431_773 FROM aggtest;
  avg_431_773 
 -------------
-     431.773
+    431.7726
 (1 row)
 
 SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
- avg_6_8 
----------
-     6.8
-(1 row)
-
+ERROR:  relation "public.student" does not exist
 SELECT max(four) AS max_3 FROM onek;
  max_3 
 -------
@@ -106,473 +80,182 @@
 (1 row)
 
 SELECT max(student.gpa) AS max_3_7 FROM student;
- max_3_7 
----------
-     3.7
-(1 row)
-
+ERROR:  relation "public.student" does not exist
 SELECT stddev_pop(b) FROM aggtest;
-   stddev_pop    
------------------
- 131.10703231895
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT stddev_samp(b) FROM aggtest;
-   stddev_samp    
-------------------
- 151.389360803998
-(1 row)
-
+ERROR:  function stddev_samp does not exist
 SELECT var_pop(b) FROM aggtest;
-     var_pop      
-------------------
- 17189.0539234823
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT var_samp(b) FROM aggtest;
-     var_samp     
-------------------
- 22918.7385646431
-(1 row)
-
+ERROR:  function var_samp does not exist
 SELECT stddev_pop(b::numeric) FROM aggtest;
-    stddev_pop    
-------------------
- 131.107032862199
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT stddev_samp(b::numeric) FROM aggtest;
-   stddev_samp    
-------------------
- 151.389361431288
-(1 row)
-
+ERROR:  function stddev_samp does not exist
 SELECT var_pop(b::numeric) FROM aggtest;
-      var_pop       
---------------------
- 17189.054065929769
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT var_samp(b::numeric) FROM aggtest;
-      var_samp      
---------------------
- 22918.738754573025
-(1 row)
-
+ERROR:  function var_samp does not exist
 -- population variance is defined for a single tuple, sample variance
 -- is not
 SELECT var_pop(1.0::float8), var_samp(2.0::float8);
- var_pop | var_samp 
----------+----------
-       0 |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop(3.0::float8), stddev_samp(4.0::float8);
- stddev_pop | stddev_samp 
-------------+-------------
-          0 |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('inf'::float8), var_samp('inf'::float8);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('inf'::float8), stddev_samp('inf'::float8);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('nan'::float8), var_samp('nan'::float8);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('nan'::float8), stddev_samp('nan'::float8);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop(1.0::float4), var_samp(2.0::float4);
- var_pop | var_samp 
----------+----------
-       0 |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop(3.0::float4), stddev_samp(4.0::float4);
- stddev_pop | stddev_samp 
-------------+-------------
-          0 |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('inf'::float4), var_samp('inf'::float4);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('inf'::float4), stddev_samp('inf'::float4);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('nan'::float4), var_samp('nan'::float4);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('nan'::float4), stddev_samp('nan'::float4);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop(1.0::numeric), var_samp(2.0::numeric);
- var_pop | var_samp 
----------+----------
-       0 |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
- stddev_pop | stddev_samp 
-------------+-------------
-          0 |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('inf'::numeric), var_samp('inf'::numeric);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('inf'::numeric), stddev_samp('inf'::numeric);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('nan'::numeric), var_samp('nan'::numeric);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('nan'::numeric), stddev_samp('nan'::numeric);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 -- verify correct results for null and NaN inputs
 select sum(null::int4) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum(null::int8) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum(null::numeric) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum(null::float8) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::int4) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::int8) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::numeric) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::float8) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum('NaN'::numeric) from generate_series(1,3);
- sum 
------
- NaN
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg('NaN'::numeric) from generate_series(1,3);
- avg 
------
- NaN
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- verify correct results for infinite inputs
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('1'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('infinity'), ('1')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('infinity'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('-infinity'), ('infinity')) v(x);
- sum | avg | var_pop 
------+-----+---------
- NaN | NaN |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('-infinity'), ('-infinity')) v(x);
-    sum    |    avg    | var_pop 
------------+-----------+---------
- -Infinity | -Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('1'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('infinity'), ('1')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('infinity'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('-infinity'), ('infinity')) v(x);
- sum | avg | var_pop 
------+-----+---------
- NaN | NaN |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('-infinity'), ('-infinity')) v(x);
-    sum    |    avg    | var_pop 
------------+-----------+---------
- -Infinity | -Infinity |     NaN
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- test accuracy with a large input offset
 SELECT avg(x::float8), var_pop(x::float8)
 FROM (VALUES (100000003), (100000004), (100000006), (100000007)) v(x);
-    avg    | var_pop 
------------+---------
- 100000005 |     2.5
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT avg(x::float8), var_pop(x::float8)
 FROM (VALUES (7000000000005), (7000000000007)) v(x);
-      avg      | var_pop 
----------------+---------
- 7000000000006 |       1
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- SQL2003 binary aggregates
 SELECT regr_count(b, a) FROM aggtest;
- regr_count 
-------------
-          4
-(1 row)
-
+ERROR:  function regr_count does not exist
 SELECT regr_sxx(b, a) FROM aggtest;
- regr_sxx 
-----------
-     5099
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT regr_syy(b, a) FROM aggtest;
-     regr_syy     
-------------------
- 68756.2156939293
-(1 row)
-
+ERROR:  function regr_syy does not exist
 SELECT regr_sxy(b, a) FROM aggtest;
-     regr_sxy     
-------------------
- 2614.51582155004
-(1 row)
-
+ERROR:  function regr_sxy does not exist
 SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
- regr_avgx |    regr_avgy     
------------+------------------
-      49.5 | 107.943152273074
-(1 row)
-
+ERROR:  function regr_avgx does not exist
 SELECT regr_r2(b, a) FROM aggtest;
-      regr_r2       
---------------------
- 0.0194977982031803
-(1 row)
-
+ERROR:  function regr_r2 does not exist
 SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
-    regr_slope     |  regr_intercept  
--------------------+------------------
- 0.512750700441271 | 82.5619926012309
-(1 row)
-
+ERROR:  function regr_slope does not exist
 SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
-    covar_pop    |    covar_samp    
------------------+------------------
- 653.62895538751 | 871.505273850014
-(1 row)
-
+ERROR:  function covar_pop does not exist
 SELECT corr(b, a) FROM aggtest;
-       corr        
--------------------
- 0.139634516517873
-(1 row)
-
+ERROR:  function corr does not exist
 -- check single-tuple behavior
 SELECT covar_pop(1::float8,2::float8), covar_samp(3::float8,4::float8);
- covar_pop | covar_samp 
------------+------------
-         0 |           
-(1 row)
-
+ERROR:  function covar_pop does not exist
 SELECT covar_pop(1::float8,'inf'::float8), covar_samp(3::float8,'inf'::float8);
- covar_pop | covar_samp 
------------+------------
-       NaN |           
-(1 row)
-
+ERROR:  function covar_pop does not exist
 SELECT covar_pop(1::float8,'nan'::float8), covar_samp(3::float8,'nan'::float8);
- covar_pop | covar_samp 
------------+------------
-       NaN |           
-(1 row)
-
+ERROR:  function covar_pop does not exist
 -- test accum and combine functions directly
 CREATE TABLE regr_test (x float8, y float8);
 INSERT INTO regr_test VALUES (10,150),(20,250),(30,350),(80,540),(100,200);
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test WHERE x IN (10,20,30,80);
- count | sum | regr_sxx | sum  | regr_syy | regr_sxy 
--------+-----+----------+------+----------+----------
-     4 | 140 |     2900 | 1290 |    83075 |    15050
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test;
- count | sum | regr_sxx | sum  | regr_syy | regr_sxy 
--------+-----+----------+------+----------+----------
-     5 | 240 |     6280 | 1490 |    95080 |     8680
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT float8_accum('{4,140,2900}'::float8[], 100);
- float8_accum 
---------------
- {5,240,6280}
-(1 row)
-
+ERROR:  function float8_accum does not exist
 SELECT float8_regr_accum('{4,140,2900,1290,83075,15050}'::float8[], 200, 100);
-      float8_regr_accum       
-------------------------------
- {5,240,6280,1490,95080,8680}
-(1 row)
-
+ERROR:  function float8_regr_accum does not exist
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test WHERE x IN (10,20,30);
- count | sum | regr_sxx | sum | regr_syy | regr_sxy 
--------+-----+----------+-----+----------+----------
-     3 |  60 |      200 | 750 |    20000 |     2000
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test WHERE x IN (80,100);
- count | sum | regr_sxx | sum | regr_syy | regr_sxy 
--------+-----+----------+-----+----------+----------
-     2 | 180 |      200 | 740 |    57800 |    -3400
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT float8_combine('{3,60,200}'::float8[], '{0,0,0}'::float8[]);
- float8_combine 
-----------------
- {3,60,200}
-(1 row)
-
+ERROR:  function float8_combine does not exist
 SELECT float8_combine('{0,0,0}'::float8[], '{2,180,200}'::float8[]);
- float8_combine 
-----------------
- {2,180,200}
-(1 row)
-
+ERROR:  function float8_combine does not exist
 SELECT float8_combine('{3,60,200}'::float8[], '{2,180,200}'::float8[]);
- float8_combine 
-----------------
- {5,240,6280}
-(1 row)
-
+ERROR:  function float8_combine does not exist
 SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                            '{0,0,0,0,0,0}'::float8[]);
-    float8_regr_combine    
----------------------------
- {3,60,200,750,20000,2000}
-(1 row)
-
+ERROR:  function float8_regr_combine does not exist
 SELECT float8_regr_combine('{0,0,0,0,0,0}'::float8[],
                            '{2,180,200,740,57800,-3400}'::float8[]);
-     float8_regr_combine     
------------------------------
- {2,180,200,740,57800,-3400}
-(1 row)
-
+ERROR:  function float8_regr_combine does not exist
 SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                            '{2,180,200,740,57800,-3400}'::float8[]);
-     float8_regr_combine      
-------------------------------
- {5,240,6280,1490,95080,8680}
-(1 row)
-
+ERROR:  function float8_regr_combine does not exist
 DROP TABLE regr_test;
+ERROR:  only support select and create table statement
 -- test count, distinct
 SELECT count(four) AS cnt_1000 FROM onek;
  cnt_1000 
@@ -620,73 +303,35 @@
 
 -- user-defined aggregates
 SELECT newavg(four) AS avg_1 FROM onek;
-       avg_1        
---------------------
- 1.5000000000000000
-(1 row)
-
+ERROR:  function newavg does not exist
 SELECT newsum(four) AS sum_1500 FROM onek;
- sum_1500 
-----------
-     1500
-(1 row)
-
+ERROR:  function newsum does not exist
 SELECT newcnt(four) AS cnt_1000 FROM onek;
- cnt_1000 
-----------
-     1000
-(1 row)
-
+ERROR:  function newcnt does not exist
 SELECT newcnt(*) AS cnt_1000 FROM onek;
- cnt_1000 
-----------
-     1000
-(1 row)
-
+ERROR:  function newcnt does not exist
 SELECT oldcnt(*) AS cnt_1000 FROM onek;
- cnt_1000 
-----------
-     1000
-(1 row)
-
+ERROR:  function oldcnt does not exist
 SELECT sum2(q1,q2) FROM int8_tbl;
-       sum2        
--------------------
- 18271560493827981
-(1 row)
-
+ERROR:  function sum2 does not exist
 -- test for outer-level aggregates
 -- this should work
 select ten, sum(distinct four) from onek a
 group by ten
 having exists (select 1 from onek b where sum(distinct a.four) = b.four);
- ten | sum 
------+-----
-   0 |   2
-   2 |   2
-   4 |   2
-   6 |   2
-   8 |   2
-(5 rows)
-
+ERROR:  split_condition_by_logical_operator bug! optr: AND
 -- this should fail because subquery has an agg of its own in WHERE
 select ten, sum(distinct four) from onek a
 group by ten
 having exists (select 1 from onek b
                where sum(distinct a.four + b.four) = b.four);
-ERROR:  aggregate functions are not allowed in WHERE
-LINE 4:                where sum(distinct a.four + b.four) = b.four)...
-                             ^
+ERROR:  split_condition_by_logical_operator bug! optr: AND
 -- Test handling of sublinks within outer-level aggregates.
 -- Per bug report from Daniel Grace.
 select
   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
 from tenk1 o;
- max  
-------
- 9999
-(1 row)
-
+ERROR:  clapdb doesn't support subquery as expr currently
 -- Test handling of Params within aggregate arguments in hashed aggregation.
 -- Per bug report from Jeevan Chalke.
 explain (verbose, costs off)
@@ -695,73 +340,22 @@
      lateral (select s2, sum(s1 + s2) sm
               from generate_series(1, 3) s2 group by s2) ss
 order by 1, 2;
-                            QUERY PLAN                            
-------------------------------------------------------------------
- Sort
-   Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
-   Sort Key: s1.s1, s2.s2
-   ->  Nested Loop
-         Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
-         ->  Function Scan on pg_catalog.generate_series s1
-               Output: s1.s1
-               Function Call: generate_series(1, 3)
-         ->  HashAggregate
-               Output: s2.s2, sum((s1.s1 + s2.s2))
-               Group Key: s2.s2
-               ->  Function Scan on pg_catalog.generate_series s2
-                     Output: s2.s2
-                     Function Call: generate_series(1, 3)
-(14 rows)
-
+ERROR:  function generate_series does not exist
 select s1, s2, sm
 from generate_series(1, 3) s1,
      lateral (select s2, sum(s1 + s2) sm
               from generate_series(1, 3) s2 group by s2) ss
 order by 1, 2;
- s1 | s2 | sm 
-----+----+----
-  1 |  1 |  2
-  1 |  2 |  3
-  1 |  3 |  4
-  2 |  1 |  3
-  2 |  2 |  4
-  2 |  3 |  5
-  3 |  1 |  4
-  3 |  2 |  5
-  3 |  3 |  6
-(9 rows)
-
+ERROR:  function generate_series does not exist
 explain (verbose, costs off)
 select array(select sum(x+y) s
             from generate_series(1,3) y group by y order by s)
   from generate_series(1,3) x;
-                            QUERY PLAN                             
--------------------------------------------------------------------
- Function Scan on pg_catalog.generate_series x
-   Output: (SubPlan 1)
-   Function Call: generate_series(1, 3)
-   SubPlan 1
-     ->  Sort
-           Output: (sum((x.x + y.y))), y.y
-           Sort Key: (sum((x.x + y.y)))
-           ->  HashAggregate
-                 Output: sum((x.x + y.y)), y.y
-                 Group Key: y.y
-                 ->  Function Scan on pg_catalog.generate_series y
-                       Output: y.y
-                       Function Call: generate_series(1, 3)
-(13 rows)
-
+ERROR:  function generate_series does not exist
 select array(select sum(x+y) s
             from generate_series(1,3) y group by y order by s)
   from generate_series(1,3) x;
-  array  
----------
- {2,3,4}
- {3,4,5}
- {4,5,6}
-(3 rows)
-
+ERROR:  function generate_series does not exist
 --
 -- test for bitwise integer aggregates
 --
@@ -773,18 +367,21 @@
   x INT2,
   y BIT(4)
 );
+ERROR:  invalid column type [type_name=bit]
 -- empty case
 SELECT
   BIT_AND(i2) AS "?",
   BIT_OR(i4)  AS "?",
   BIT_XOR(i8) AS "?"
 FROM bitwise_test;
- ? | ? | ? 
----+---+---
-   |   |  
-(1 row)
-
+ERROR:  function bit_and does not exist
 COPY bitwise_test FROM STDIN NULL 'null';
+ERROR:  relation "public.bitwise_test" not exists
+1	1	1	1	1	B0101
+3	3	3	null	2	B0100
+7	7	7	3	4	B1100
+\.
+invalid command \.
 SELECT
   BIT_AND(i2) AS "1",
   BIT_AND(i4) AS "1",
@@ -805,11 +402,7 @@
   BIT_XOR(x)  AS "7",
   BIT_XOR(y)  AS "1101"
 FROM bitwise_test;
- 1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 | 5 | 5 | 5 | ? | 7 | 1101 
----+---+---+---+---+------+---+---+---+---+---+------+---+---+---+---+---+------
- 1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101 | 5 | 5 | 5 | 2 | 7 | 1101
-(1 row)
-
+ERROR:  syntax error at or near "1"
 --
 -- test boolean aggregates
 --
@@ -827,11 +420,7 @@
   NOT booland_statefunc(TRUE, FALSE) AS "t",
   NOT booland_statefunc(FALSE, TRUE) AS "t",
   NOT booland_statefunc(FALSE, FALSE) AS "t";
- t | t | t | t | t | t | t | t | t 
----+---+---+---+---+---+---+---+---
- t | t | t | t | t | t | t | t | t
-(1 row)
-
+ERROR:  function booland_statefunc does not exist
 SELECT
   -- boolean or transitions
   -- null because strict
@@ -845,11 +434,7 @@
   boolor_statefunc(TRUE, FALSE) AS "t",
   boolor_statefunc(FALSE, TRUE) AS "t",
   NOT boolor_statefunc(FALSE, FALSE) AS "t";
- t | t | t | t | t | t | t | t | t 
----+---+---+---+---+---+---+---+---
- t | t | t | t | t | t | t | t | t
-(1 row)
-
+ERROR:  function boolor_statefunc does not exist
 CREATE TEMPORARY TABLE bool_test(
   b1 BOOL,
   b2 BOOL,
@@ -860,12 +445,14 @@
   BOOL_AND(b1)   AS "n",
   BOOL_OR(b3)    AS "n"
 FROM bool_test;
- n | n 
----+---
-   | 
-(1 row)
-
+ERROR:  function bool_and does not exist
 COPY bool_test FROM STDIN NULL 'null';
+ERROR:  Can not open file "" because "No such file or directory".
+TRUE	null	FALSE	null
+FALSE	TRUE	null	null
+null	TRUE	FALSE	null
+\.
+invalid command \.
 SELECT
   BOOL_AND(b1)     AS "f",
   BOOL_AND(b2)     AS "t",
@@ -874,11 +461,7 @@
   BOOL_AND(NOT b2) AS "f",
   BOOL_AND(NOT b3) AS "t"
 FROM bool_test;
- f | t | f | n | f | t 
----+---+---+---+---+---
- f | t | f |   | f | t
-(1 row)
-
+ERROR:  syntax error at or near "TRUE"
 SELECT
   EVERY(b1)     AS "f",
   EVERY(b2)     AS "t",
@@ -887,11 +470,7 @@
   EVERY(NOT b2) AS "f",
   EVERY(NOT b3) AS "t"
 FROM bool_test;
- f | t | f | n | f | t 
----+---+---+---+---+---
- f | t | f |   | f | t
-(1 row)
-
+ERROR:  function every does not exist
 SELECT
   BOOL_OR(b1)      AS "t",
   BOOL_OR(b2)      AS "t",
@@ -900,11 +479,7 @@
   BOOL_OR(NOT b2)  AS "f",
   BOOL_OR(NOT b3)  AS "t"
 FROM bool_test;
- t | t | f | n | f | t 
----+---+---+---+---+---
- t | t | f |   | f | t
-(1 row)
-
+ERROR:  function bool_or does not exist
 --
 -- Test cases that should be optimized into indexscans instead of
 -- the generic aggregate implementation.
@@ -912,14 +487,12 @@
 -- Basic cases
 explain (costs off)
   select min(unique1) from tenk1;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan using tenk1_unique1 on tenk1
-                 Index Cond: (unique1 IS NOT NULL)
-(5 rows)
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MIN, column(unique1))
+ tuple(table_0) = [datum(col_0_unique1)]
+ return tuple(table_0)
+(3 rows)
 
 select min(unique1) from tenk1;
  min 
@@ -929,14 +502,12 @@
 
 explain (costs off)
   select max(unique1) from tenk1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: (unique1 IS NOT NULL)
-(5 rows)
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1))
+ tuple(table_0) = [datum(col_0_unique1)]
+ return tuple(table_0)
+(3 rows)
 
 select max(unique1) from tenk1;
  max  
@@ -946,14 +517,13 @@
 
 explain (costs off)
   select max(unique1) from tenk1 where unique1 < 42;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 < 42))
-(5 rows)
+                                                QUERY PLAN                                                
+----------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(unique1) in [[-inf,42)]), return tid(var_4_1)]
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1), tid(where))
+ tuple(table_0) = [datum(col_0_unique1)]
+ return tuple(table_0)
+(4 rows)
 
 select max(unique1) from tenk1 where unique1 < 42;
  max 
@@ -963,14 +533,13 @@
 
 explain (costs off)
   select max(unique1) from tenk1 where unique1 > 42;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42))
-(5 rows)
+                                                QUERY PLAN                                                
+----------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(unique1) in [(42,+inf]]), return tid(var_4_1)]
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1), tid(where))
+ tuple(table_0) = [datum(col_0_unique1)]
+ return tuple(table_0)
+(4 rows)
 
 select max(unique1) from tenk1 where unique1 > 42;
  max  
@@ -983,17 +552,18 @@
 -- plan, which has almost identical cost, will not be.  we want to test
 -- the optimized plan, so temporarily disable parallel query.
 begin;
+ERROR:  only support select and create table statement
 set local max_parallel_workers_per_gather = 0;
+ERROR:  only support select and create table statement
 explain (costs off)
   select max(unique1) from tenk1 where unique1 > 42000;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42000))
-(5 rows)
+                                                 QUERY PLAN                                                  
+-------------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(unique1) in [(42000,+inf]]), return tid(var_4_1)]
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1), tid(where))
+ tuple(table_0) = [datum(col_0_unique1)]
+ return tuple(table_0)
+(4 rows)
 
 select max(unique1) from tenk1 where unique1 > 42000;
  max 
@@ -1002,17 +572,17 @@
 (1 row)
 
 rollback;
+ERROR:  only support select and create table statement
 -- multi-column index (uses tenk1_thous_tenthous)
 explain (costs off)
   select max(tenthous) from tenk1 where thousand = 33;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1
-                 Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
-(5 rows)
+                                               QUERY PLAN                                                
+---------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(thousand) in [[33,33]]), return tid(var_4_1)]
+ datum(col_0_tenthous) = IndexAggregateForMultiSegment(MAX, column(tenthous), tid(where))
+ tuple(table_0) = [datum(col_0_tenthous)]
+ return tuple(table_0)
+(4 rows)
 
 select max(tenthous) from tenk1 where thousand = 33;
  max  
@@ -1022,14 +592,13 @@
 
 explain (costs off)
   select min(tenthous) from tenk1 where thousand = 33;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan using tenk1_thous_tenthous on tenk1
-                 Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
-(5 rows)
+                                               QUERY PLAN                                                
+---------------------------------------------------------------------------------------------------------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(thousand) in [[33,33]]), return tid(var_4_1)]
+ datum(col_0_tenthous) = IndexAggregateForMultiSegment(MIN, column(tenthous), tid(where))
+ tuple(table_0) = [datum(col_0_tenthous)]
+ return tuple(table_0)
+(4 rows)
 
 select min(tenthous) from tenk1 where thousand = 33;
  min 
@@ -1041,41 +610,19 @@
 explain (costs off)
   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
     from int4_tbl;
-                                       QUERY PLAN                                        
------------------------------------------------------------------------------------------
- Seq Scan on int4_tbl
-   SubPlan 2
-     ->  Result
-           InitPlan 1 (returns $1)
-             ->  Limit
-                   ->  Index Only Scan using tenk1_unique1 on tenk1
-                         Index Cond: ((unique1 IS NOT NULL) AND (unique1 > int4_tbl.f1))
-(7 rows)
-
+ERROR:  clapdb doesn't support subquery as expr currently
 select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
   from int4_tbl;
-     f1      | gt 
--------------+----
-           0 |  1
-      123456 |   
-     -123456 |  0
-  2147483647 |   
- -2147483647 |  0
-(5 rows)
-
+ERROR:  clapdb doesn't support subquery as expr currently
 -- check some cases that were handled incorrectly in 8.3.0
 explain (costs off)
   select distinct max(unique2) from tenk1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- HashAggregate
-   Group Key: $0
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2))
+ tuple(table_0) = [datum(col_0_unique2)]
+ return tuple(table_0)
+(3 rows)
 
 select distinct max(unique2) from tenk1;
  max  
@@ -1085,16 +632,13 @@
 
 explain (costs off)
   select max(unique2) from tenk1 order by 1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: ($0)
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2))
+ tuple(table_0) = [datum(col_0_unique2)]
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(4 rows)
 
 select max(unique2) from tenk1 order by 1;
  max  
@@ -1104,16 +648,13 @@
 
 explain (costs off)
   select max(unique2) from tenk1 order by max(unique2);
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: ($0)
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2))
+ tuple(table_0) = [datum(col_0_unique2)]
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])
+ return tuple(table_0)
+(4 rows)
 
 select max(unique2) from tenk1 order by max(unique2);
  max  
@@ -1123,16 +664,18 @@
 
 explain (costs off)
   select max(unique2) from tenk1 order by max(unique2)+1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: (($0 + 1))
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2))
+ tuple(table_0) = [datum(col_0_unique2)]
+ datum(var_7_1) = TupleAt(tuple(table_0) 0)
+ datum(var_7_2) = DatumMapJIT(cast(Int64, datum(var_7_1)) + 1)
+ tuple(tmp_order) = [datum(var_7_2)]
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tmp_order))
+ tuple(table_0) = Sort(tuple(table_0), [columns(1 ASC)])
+ tuple(table_0) = Erase(tuple(table_0), [1])
+ return tuple(table_0)
+(9 rows)
 
 select max(unique2) from tenk1 order by max(unique2)+1;
  max  
@@ -1142,38 +685,18 @@
 
 explain (costs off)
   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: (generate_series(1, 3)) DESC
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  ProjectSet
-         ->  Result
-(8 rows)
-
+ERROR:  function generate_series does not exist
 select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
- max  | g 
-------+---
- 9999 | 3
- 9999 | 2
- 9999 | 1
-(3 rows)
-
+ERROR:  function generate_series does not exist
 -- interesting corner case: constant gets optimized into a seqscan
 explain (costs off)
   select max(100) from tenk1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Result
-                 One-Time Filter: (100 IS NOT NULL)
-                 ->  Seq Scan on tenk1
-(6 rows)
+                       QUERY PLAN                        
+---------------------------------------------------------
+ datum(col_0_literal) = LiteralAggregate(MAX(100) tenk1)
+ tuple(table_0) = [datum(col_0_literal)]
+ return tuple(table_0)
+(3 rows)
 
 select max(100) from tenk1;
  max 
@@ -1187,191 +710,99 @@
 create table minmaxtest2(f1 int);
 create table minmaxtest3(f1 int);
 create index minmaxtesti on minmaxtest(f1);
+ERROR:  only support select and create table statement
 create index minmaxtest1i on minmaxtest1(f1);
+ERROR:  only support select and create table statement
 create index minmaxtest2i on minmaxtest2(f1 desc);
+ERROR:  only support select and create table statement
 create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
+ERROR:  only support select and create table statement
 insert into minmaxtest values(11), (12);
 insert into minmaxtest1 values(13), (14);
 insert into minmaxtest2 values(15), (16);
 insert into minmaxtest3 values(17), (18);
 explain (costs off)
   select min(f1), max(f1) from minmaxtest;
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest.f1
-                 ->  Index Only Scan using minmaxtesti on minmaxtest minmaxtest_1
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest1i on minmaxtest1 minmaxtest_2
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2 minmaxtest_3
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest3i on minmaxtest3 minmaxtest_4
-   InitPlan 2 (returns $1)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest_5.f1 DESC
-                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_6
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest_7
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest_8
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest_9
-(23 rows)
+                            QUERY PLAN                            
+------------------------------------------------------------------
+ datum(col_0_f1) = IndexAggregateForMultiSegment(MIN, column(f1))
+ datum(col_1_f1) = IndexAggregateForMultiSegment(MAX, column(f1))
+ tuple(table_0) = [datum(col_0_f1), datum(col_1_f1)]
+ return tuple(table_0)
+(4 rows)
 
 select min(f1), max(f1) from minmaxtest;
  min | max 
 -----+-----
-  11 |  18
+  11 |  12
 (1 row)
 
 -- DISTINCT doesn't do anything useful here, but it shouldn't fail
 explain (costs off)
   select distinct min(f1), max(f1) from minmaxtest;
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
- Unique
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest.f1
-                 ->  Index Only Scan using minmaxtesti on minmaxtest minmaxtest_1
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest1i on minmaxtest1 minmaxtest_2
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2 minmaxtest_3
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest3i on minmaxtest3 minmaxtest_4
-   InitPlan 2 (returns $1)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest_5.f1 DESC
-                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_6
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest_7
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest_8
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest_9
-   ->  Sort
-         Sort Key: ($0), ($1)
-         ->  Result
-(26 rows)
+                            QUERY PLAN                            
+------------------------------------------------------------------
+ datum(col_0_f1) = IndexAggregateForMultiSegment(MIN, column(f1))
+ datum(col_1_f1) = IndexAggregateForMultiSegment(MAX, column(f1))
+ tuple(table_0) = [datum(col_0_f1), datum(col_1_f1)]
+ return tuple(table_0)
+(4 rows)
 
 select distinct min(f1), max(f1) from minmaxtest;
  min | max 
 -----+-----
-  11 |  18
+  11 |  12
 (1 row)
 
 drop table minmaxtest cascade;
-NOTICE:  drop cascades to 3 other objects
-DETAIL:  drop cascades to table minmaxtest1
-drop cascades to table minmaxtest2
-drop cascades to table minmaxtest3
+ERROR:  only support select and create table statement
 -- check for correct detection of nested-aggregate errors
 select max(min(unique1)) from tenk1;
 ERROR:  aggregate function calls cannot be nested
-LINE 1: select max(min(unique1)) from tenk1;
-                   ^
 select (select max(min(unique1)) from int8_tbl) from tenk1;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select (select max(min(unique1)) from int8_tbl) from tenk1;
-                           ^
+ERROR:  clapdb doesn't support subquery as expr currently
 select avg((select avg(a1.col1 order by (select avg(a2.col2) from tenk1 a3))
             from tenk1 a1(col1)))
 from tenk1 a2(col2);
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select avg((select avg(a1.col1 order by (select avg(a2.col2)...
-                                                        ^
+ERROR:  clapdb doesn't support subquery as expr currently
 --
 -- Test removal of redundant GROUP BY columns
 --
 create temp table t1 (a int, b int, c int, d int, primary key (a, b));
+ERROR:  std::get variant by const ref type error: /home/longqimin/stdb/arabic/pgsql/arabic_create.cc:338:47
+
 create temp table t2 (x int, y int, z int, primary key (x, y));
+ERROR:  std::get variant by const ref type error: /home/longqimin/stdb/arabic/pgsql/arabic_create.cc:338:47
+
 create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
+ERROR:  std::get variant by const ref type error: /home/longqimin/stdb/arabic/pgsql/arabic_create.cc:338:47
+
 -- Non-primary-key columns can be removed from GROUP BY
 explain (costs off) select * from t1 group by a,b,c,d;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, b
-   ->  Seq Scan on t1
-(3 rows)
-
+ERROR:  relation "public.t1" does not exist
 -- No removal can happen if the complete PK is not present in GROUP BY
 explain (costs off) select a,c from t1 group by a,c,d;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, c, d
-   ->  Seq Scan on t1
-(3 rows)
-
+ERROR:  relation "public.t1" does not exist
 -- Test removal across multiple relations
 explain (costs off) select *
 from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
 group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
-                      QUERY PLAN                      
-------------------------------------------------------
- HashAggregate
-   Group Key: t1.a, t1.b
-   ->  Hash Join
-         Hash Cond: ((t2.x = t1.a) AND (t2.y = t1.b))
-         ->  Seq Scan on t2
-         ->  Hash
-               ->  Seq Scan on t1
-(7 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- Test case where t1 can be optimized but not t2
 explain (costs off) select t1.*,t2.x,t2.z
 from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
 group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
-                      QUERY PLAN                      
-------------------------------------------------------
- HashAggregate
-   Group Key: t1.a, t1.b, t2.z
-   ->  Hash Join
-         Hash Cond: ((t2.x = t1.a) AND (t2.y = t1.b))
-         ->  Seq Scan on t2
-         ->  Hash
-               ->  Seq Scan on t1
-(7 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- Cannot optimize when PK is deferrable
 explain (costs off) select * from t3 group by a,b,c;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, b, c
-   ->  Seq Scan on t3
-(3 rows)
-
+ERROR:  relation "public.t3" does not exist
 create temp table t1c () inherits (t1);
 -- Ensure we don't remove any columns when t1 has a child table
 explain (costs off) select * from t1 group by a,b,c,d;
-             QUERY PLAN              
--------------------------------------
- HashAggregate
-   Group Key: t1.a, t1.b, t1.c, t1.d
-   ->  Append
-         ->  Seq Scan on t1 t1_1
-         ->  Seq Scan on t1c t1_2
-(5 rows)
-
+ERROR:  relation "public.t1" does not exist
 -- Okay to remove columns if we're only querying the parent.
 explain (costs off) select * from only t1 group by a,b,c,d;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, b
-   ->  Seq Scan on t1
-(3 rows)
-
+ERROR:  relation "public.t1" does not exist
 create temp table p_t1 (
   a int,
   b int,
@@ -1379,66 +810,48 @@
   d int,
   primary key(a,b)
 ) partition by list(a);
+ERROR:  std::get variant by const ref type error: /home/longqimin/stdb/arabic/pgsql/arabic_create.cc:338:47
+
 create temp table p_t1_1 partition of p_t1 for values in(1);
 create temp table p_t1_2 partition of p_t1 for values in(2);
 -- Ensure we can remove non-PK columns for partitioned tables.
 explain (costs off) select * from p_t1 group by a,b,c,d;
-           QUERY PLAN           
---------------------------------
- HashAggregate
-   Group Key: p_t1.a, p_t1.b
-   ->  Append
-         ->  Seq Scan on p_t1_1
-         ->  Seq Scan on p_t1_2
-(5 rows)
-
+ERROR:  relation "public.p_t1" does not exist
 drop table t1 cascade;
-NOTICE:  drop cascades to table t1c
+ERROR:  only support select and create table statement
 drop table t2;
+ERROR:  only support select and create table statement
 drop table t3;
+ERROR:  only support select and create table statement
 drop table p_t1;
+ERROR:  only support select and create table statement
 --
 -- Test GROUP BY matching of join columns that are type-coerced due to USING
 --
 create temp table t1(f1 int, f2 int);
 create temp table t2(f1 bigint, f2 oid);
+ERROR:  invalid column type [type_name=oid]
 select f1 from t1 left join t2 using (f1) group by f1;
- f1 
-----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 select f1 from t1 left join t2 using (f1) group by t1.f1;
- f1 
-----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 select t1.f1 from t1 left join t2 using (f1) group by t1.f1;
- f1 
-----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- only this one should fail:
 select t1.f1 from t1 left join t2 using (f1) group by f1;
-ERROR:  column "t1.f1" must appear in the GROUP BY clause or be used in an aggregate function
-LINE 1: select t1.f1 from t1 left join t2 using (f1) group by f1;
-               ^
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- check case where we have to inject nullingrels into coerced join alias
 select f1, count(*) from
 t1 x(x0,x1) left join (t1 left join t2 using(f1)) on (x0 = 0)
 group by f1;
- f1 | count 
-----+-------
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- same, for a RelabelType coercion
 select f2, count(*) from
 t1 x(x0,x1) left join (t1 left join t2 using(f2)) on (x0 = 0)
 group by f2;
- f2 | count 
-----+-------
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 drop table t1, t2;
+ERROR:  only support select and create table statement
 --
 -- Test planner's selection of pathkeys for ORDER BY aggregates
 --
@@ -1446,13 +859,14 @@
 explain (costs off)
 select sum(two order by two),max(four order by four), min(four order by four)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: four
-         ->  Seq Scan on tenk1
-(4 rows)
+                                QUERY PLAN                                 
+---------------------------------------------------------------------------
+ datum(col_0_two) = IndexAggregateForMultiSegment(SUM, column(two))
+ datum(col_1_four) = IndexAggregateForMultiSegment(MAX, column(four))
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))
+ tuple(table_0) = [datum(col_0_two), datum(col_1_four), datum(col_2_four)]
+ return tuple(table_0)
+(5 rows)
 
 -- Ensure we order by two.  It's a tie between ordering by two and four but
 -- we tiebreak on the aggregate's position.
@@ -1461,13 +875,15 @@
   sum(two order by two), max(four order by four),
   min(four order by four), max(two order by two)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: two
-         ->  Seq Scan on tenk1
-(4 rows)
+                                         QUERY PLAN                                          
+---------------------------------------------------------------------------------------------
+ datum(col_0_two) = IndexAggregateForMultiSegment(SUM, column(two))
+ datum(col_1_four) = IndexAggregateForMultiSegment(MAX, column(four))
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))
+ datum(col_3_two) = IndexAggregateForMultiSegment(MAX, column(two))
+ tuple(table_0) = [datum(col_0_two), datum(col_1_four), datum(col_2_four), datum(col_3_two)]
+ return tuple(table_0)
+(6 rows)
 
 -- Similar to above, but tiebreak on ordering by four
 explain (costs off)
@@ -1475,13 +891,15 @@
   max(four order by four), sum(two order by two),
   min(four order by four), max(two order by two)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: four
-         ->  Seq Scan on tenk1
-(4 rows)
+                                         QUERY PLAN                                          
+---------------------------------------------------------------------------------------------
+ datum(col_0_four) = IndexAggregateForMultiSegment(MAX, column(four))
+ datum(col_1_two) = IndexAggregateForMultiSegment(SUM, column(two))
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))
+ datum(col_3_two) = IndexAggregateForMultiSegment(MAX, column(two))
+ tuple(table_0) = [datum(col_0_four), datum(col_1_two), datum(col_2_four), datum(col_3_two)]
+ return tuple(table_0)
+(6 rows)
 
 -- Ensure this one orders by ten since there are 3 aggregates that require ten
 -- vs two that suit two and four.
@@ -1491,13 +909,18 @@
   min(four order by four), max(two order by two),
   sum(ten order by ten), min(ten order by ten), max(ten order by ten)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: ten
-         ->  Seq Scan on tenk1
-(4 rows)
+                                                                    QUERY PLAN                                                                     
+---------------------------------------------------------------------------------------------------------------------------------------------------
+ datum(col_0_four) = IndexAggregateForMultiSegment(MAX, column(four))
+ datum(col_1_two) = IndexAggregateForMultiSegment(SUM, column(two))
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))
+ datum(col_3_two) = IndexAggregateForMultiSegment(MAX, column(two))
+ datum(col_4_ten) = IndexAggregateForMultiSegment(SUM, column(ten))
+ datum(col_5_ten) = IndexAggregateForMultiSegment(MIN, column(ten))
+ datum(col_6_ten) = IndexAggregateForMultiSegment(MAX, column(ten))
+ tuple(table_0) = [datum(col_0_four), datum(col_1_two), datum(col_2_four), datum(col_3_two), datum(col_4_ten), datum(col_5_ten), datum(col_6_ten)]
+ return tuple(table_0)
+(9 rows)
 
 -- Try a case involving a GROUP BY clause where the GROUP BY column is also
 -- part of an aggregate's ORDER BY clause.  We want a sort order that works
@@ -1508,14 +931,20 @@
   sum(unique1 order by two, four)
 from tenk1
 group by ten;
-            QUERY PLAN            
-----------------------------------
- GroupAggregate
-   Group Key: ten
-   ->  Sort
-         Sort Key: ten, two, four
-         ->  Seq Scan on tenk1
-(5 rows)
+                                                                              QUERY PLAN                                                                              
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ FilterHistogram(histogram_tenk1_0) = parallel: [FilterHistogram(var_5_1) = IndexTopNGroup([Get(ten)], 10000, [ASC_AND_NULLS_LAST]), return FilterHistogram(var_5_1)]
+ tuple(tuple_0_tenk1) = to_tuple(FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_0_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_1_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_2_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(table_0) = TupleExpand(tuple(tuple_0_tenk1), tuple(tuple_0_unique1))
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_1_unique1))
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_2_unique1))
+ tuple(table_0) = TupleReorder(tuple(table_0), [3, 0, 1, 2])
+ tuple(table_0) = Erase(tuple(table_0), [3])
+ return tuple(table_0)
+(11 rows)
 
 -- Ensure that we never choose to provide presorted input to an Aggref with
 -- a volatile function in the ORDER BY / DISTINCT clause.  We want to ensure
@@ -1527,173 +956,110 @@
   sum(unique1 order by two, random(), random() + 1)
 from tenk1
 group by ten;
-            QUERY PLAN            
-----------------------------------
- GroupAggregate
-   Group Key: ten
-   ->  Sort
-         Sort Key: ten, four, two
-         ->  Seq Scan on tenk1
-(5 rows)
+                                                                              QUERY PLAN                                                                              
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ FilterHistogram(histogram_tenk1_0) = parallel: [FilterHistogram(var_5_1) = IndexTopNGroup([Get(ten)], 10000, [ASC_AND_NULLS_LAST]), return FilterHistogram(var_5_1)]
+ tuple(tuple_0_tenk1) = to_tuple(FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_0_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_1_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_2_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_3_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(tuple_4_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))
+ tuple(table_0) = TupleExpand(tuple(tuple_0_tenk1), tuple(tuple_0_unique1))
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_1_unique1))
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_2_unique1))
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_3_unique1))
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_4_unique1))
+ tuple(table_0) = TupleReorder(tuple(table_0), [5, 0, 1, 2, 3, 4])
+ tuple(table_0) = Erase(tuple(table_0), [5])
+ return tuple(table_0)
+(15 rows)
 
 -- Ensure consecutive NULLs are properly treated as distinct from each other
 select array_agg(distinct val)
 from (select null as val from generate_series(1, 2));
- array_agg 
------------
- {NULL}
-(1 row)
-
+ERROR:  subquery in FROM must have an alias
 -- Ensure no ordering is requested when enable_presorted_aggregate is off
 set enable_presorted_aggregate to off;
+ERROR:  only support select and create table statement
 explain (costs off)
 select sum(two order by two) from tenk1;
-       QUERY PLAN        
--------------------------
- Aggregate
-   ->  Seq Scan on tenk1
-(2 rows)
+                             QUERY PLAN                             
+--------------------------------------------------------------------
+ datum(col_0_two) = IndexAggregateForMultiSegment(SUM, column(two))
+ tuple(table_0) = [datum(col_0_two)]
+ return tuple(table_0)
+(3 rows)
 
 reset enable_presorted_aggregate;
+ERROR:  only support select and create table statement
 --
 -- Test combinations of DISTINCT and/or ORDER BY
 --
 select array_agg(a order by b)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {3,4,2,1}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(a order by a)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {1,2,3,4}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(a order by a desc)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {4,3,2,1}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(b order by a desc)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {2,1,3,4}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(distinct a)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {1,2,3,NULL}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(distinct a order by a)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {1,2,3,NULL}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(distinct a order by a desc)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {NULL,3,2,1}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select array_agg(distinct a order by a desc nulls last)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {3,2,1,NULL}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- multi-arg aggs, strict/nonstrict, distinct/order by
 select aggfstr(a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
-                aggfstr                
----------------------------------------
- {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
-                    aggfns                     
------------------------------------------------
- {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfstr(distinct a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                aggfstr                
----------------------------------------
- {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfstr(distinct a,b,c order by b)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                aggfstr                
----------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,b,c order by b)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                    aggfns                     
------------------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- test specific code paths
 select aggfns(distinct a,a,c order by c using ~<~,a)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                     aggfns                     
-------------------------------------------------
- {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,a,c order by c using ~<~)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                     aggfns                     
-------------------------------------------------
- {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,a,c order by a)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                     aggfns                     
-------------------------------------------------
- {"(0,0,)","(1,1,foo)","(2,2,bar)","(3,3,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,b,c order by a,c using ~<~,b)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- test a more complex permutation that has previous caused issues
 select
     string_agg(distinct 'a', ','),
@@ -1702,244 +1068,137 @@
         from (values(1)) b(id)
         where a.id = b.id
 )) from unnest(array[1]) a(id);
- string_agg | sum 
-------------+-----
- a          |   1
-(1 row)
-
+ERROR:  function unnest does not exist
 -- check node I/O via view creation and usage, also deparsing logic
 create view agg_view1 as
   select aggfns(a,b,c)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, b, c) AS aggfns                                                                                  +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(distinct a,b,c)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
          generate_series(1,3) i;
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(DISTINCT v.a, v.b, v.c) AS aggfns                                                                   +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
-     generate_series(1, 3) i(i);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(distinct a,b,c order by b)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
          generate_series(1,3) i;
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.b) AS aggfns                                                      +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
-     generate_series(1, 3) i(i);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(a,b,c order by b+1)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, b, c ORDER BY (b + 1)) AS aggfns                                                                 +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(a,a,c order by b)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                     aggfns                     
-------------------------------------------------
- {"(3,3,baz)","(2,2,bar)","(1,1,foo)","(0,0,)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, a, c ORDER BY b) AS aggfns                                                                       +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(a,b,c order by c using ~<~)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(2,2,bar)","(3,1,baz)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, b, c ORDER BY c USING ~<~ NULLS LAST) AS aggfns                                                  +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(distinct a,b,c order by a,c using ~<~,b)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
          generate_series(1,2) i;
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  relation "public.agg_view1" does not exist
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.a, v.c USING ~<~ NULLS LAST, v.b) AS aggfns                       +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
-     generate_series(1, 2) i(i);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 drop view agg_view1;
+ERROR:  only support select and create table statement
 -- incorrect DISTINCT usage errors
 select aggfns(distinct a,b,c order by i)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,b,c order by i)
-                                              ^
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,b,c order by a,b+1)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,b,c order by a,b+1)
-                                                ^
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,b,c order by a,b,i,c)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,b,c order by a,b,i,c)
-                                                  ^
+ERROR:  clapdb doesn't support select ValueLists
 select aggfns(distinct a,a,c order by a,b)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,a,c order by a,b)
-                                                ^
+ERROR:  clapdb doesn't support select ValueLists
 -- string_agg tests
 select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
-   string_agg   
-----------------
- aaaa,bbbb,cccc
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
-   string_agg   
-----------------
- aaaa,bbbb,cccc
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
- string_agg 
-------------
- bbbbABcccc
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select string_agg(a,',') from (values(null),(null)) g(a);
- string_agg 
-------------
- 
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- check some implicit casting cases, as per bug #5564
 select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
- string_agg 
-------------
- a,ab,abcd
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
-                                                          ^
+ERROR:  function string_agg does not exist
 select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
-                                                    ^
+ERROR:  function string_agg does not exist
 select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
- string_agg 
-------------
- a,ab,abcd
-(1 row)
-
+ERROR:  function string_agg does not exist
 -- string_agg bytea tests
 create table bytea_test_table(v bytea);
+ERROR:  invalid column type [type_name=bytea]
 select string_agg(v, '') from bytea_test_table;
- string_agg 
-------------
- 
-(1 row)
-
+ERROR:  function string_agg does not exist
 insert into bytea_test_table values(decode('ff','hex'));
+ERROR:  relation "public.bytea_test_table" not exists
 select string_agg(v, '') from bytea_test_table;
- string_agg 
-------------
- \xff
-(1 row)
-
+ERROR:  function string_agg does not exist
 insert into bytea_test_table values(decode('aa','hex'));
+ERROR:  relation "public.bytea_test_table" not exists
 select string_agg(v, '') from bytea_test_table;
- string_agg 
-------------
- \xffaa
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(v, NULL) from bytea_test_table;
- string_agg 
-------------
- \xffaa
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
- string_agg 
-------------
- \xffeeaa
-(1 row)
-
+ERROR:  function string_agg does not exist
 drop table bytea_test_table;
+ERROR:  only support select and create table statement
 -- Test parallel string_agg and array_agg
 create table pagg_test (x int, y int);
 insert into pagg_test
 select (case x % 4 when 1 then null else x end), x % 10
 from generate_series(1,5000) x;
+ERROR:  INSERT without VALUES
 set parallel_setup_cost TO 0;
+ERROR:  only support select and create table statement
 set parallel_tuple_cost TO 0;
+ERROR:  only support select and create table statement
 set parallel_leader_participation TO 0;
+ERROR:  only support select and create table statement
 set min_parallel_table_scan_size = 0;
+ERROR:  only support select and create table statement
 set bytea_output = 'escape';
+ERROR:  only support select and create table statement
 set max_parallel_workers_per_gather = 2;
+ERROR:  only support select and create table statement
 -- create a view as we otherwise have to repeat this query a few times.
 create view v_pagg_test AS
 select
@@ -1967,424 +1226,223 @@
 	) a1
 ) a2
 group by y;
+ERROR:  only support select and create table statement
 -- Ensure results are correct.
 select * from v_pagg_test order by y;
- y | tmin | tmax | tndistinct | bmin | bmax | bndistinct | amin | amax | andistinct | aamin | aamax | aandistinct 
----+------+------+------------+------+------+------------+------+------+------------+-------+-------+-------------
- 0 |   10 | 5000 |        500 | 10   | 990  |        500 |   10 | 5000 |        500 |    10 |  5000 |         500
- 1 |   11 | 4991 |        250 | 1011 | 991  |        250 |   11 | 4991 |        250 |    11 |  4991 |         250
- 2 |    2 | 4992 |        500 | 1002 | 992  |        500 |    2 | 4992 |        500 |     2 |  4992 |         500
- 3 |    3 | 4983 |        250 | 1003 | 983  |        250 |    3 | 4983 |        250 |     3 |  4983 |         250
- 4 |    4 | 4994 |        500 | 1004 | 994  |        500 |    4 | 4994 |        500 |     4 |  4994 |         500
- 5 |   15 | 4995 |        250 | 1015 | 995  |        250 |   15 | 4995 |        250 |    15 |  4995 |         250
- 6 |    6 | 4996 |        500 | 1006 | 996  |        500 |    6 | 4996 |        500 |     6 |  4996 |         500
- 7 |    7 | 4987 |        250 | 1007 | 987  |        250 |    7 | 4987 |        250 |     7 |  4987 |         250
- 8 |    8 | 4998 |        500 | 1008 | 998  |        500 |    8 | 4998 |        500 |     8 |  4998 |         500
- 9 |   19 | 4999 |        250 | 1019 | 999  |        250 |   19 | 4999 |        250 |    19 |  4999 |         250
-(10 rows)
-
+ERROR:  relation "public.v_pagg_test" does not exist
 -- Ensure parallel aggregation is actually being used.
 explain (costs off) select * from v_pagg_test order by y;
-                                                              QUERY PLAN                                                              
---------------------------------------------------------------------------------------------------------------------------------------
- GroupAggregate
-   Group Key: pagg_test.y
-   ->  Sort
-         Sort Key: pagg_test.y, (((unnest(regexp_split_to_array((string_agg((pagg_test.x)::text, ','::text)), ','::text))))::integer)
-         ->  Result
-               ->  ProjectSet
-                     ->  Finalize HashAggregate
-                           Group Key: pagg_test.y
-                           ->  Gather
-                                 Workers Planned: 2
-                                 ->  Partial HashAggregate
-                                       Group Key: pagg_test.y
-                                       ->  Parallel Seq Scan on pagg_test
-(13 rows)
-
+ERROR:  relation "public.v_pagg_test" does not exist
 set max_parallel_workers_per_gather = 0;
+ERROR:  only support select and create table statement
 -- Ensure results are the same without parallel aggregation.
 select * from v_pagg_test order by y;
- y | tmin | tmax | tndistinct | bmin | bmax | bndistinct | amin | amax | andistinct | aamin | aamax | aandistinct 
----+------+------+------------+------+------+------------+------+------+------------+-------+-------+-------------
- 0 |   10 | 5000 |        500 | 10   | 990  |        500 |   10 | 5000 |        500 |    10 |  5000 |         500
- 1 |   11 | 4991 |        250 | 1011 | 991  |        250 |   11 | 4991 |        250 |    11 |  4991 |         250
- 2 |    2 | 4992 |        500 | 1002 | 992  |        500 |    2 | 4992 |        500 |     2 |  4992 |         500
- 3 |    3 | 4983 |        250 | 1003 | 983  |        250 |    3 | 4983 |        250 |     3 |  4983 |         250
- 4 |    4 | 4994 |        500 | 1004 | 994  |        500 |    4 | 4994 |        500 |     4 |  4994 |         500
- 5 |   15 | 4995 |        250 | 1015 | 995  |        250 |   15 | 4995 |        250 |    15 |  4995 |         250
- 6 |    6 | 4996 |        500 | 1006 | 996  |        500 |    6 | 4996 |        500 |     6 |  4996 |         500
- 7 |    7 | 4987 |        250 | 1007 | 987  |        250 |    7 | 4987 |        250 |     7 |  4987 |         250
- 8 |    8 | 4998 |        500 | 1008 | 998  |        500 |    8 | 4998 |        500 |     8 |  4998 |         500
- 9 |   19 | 4999 |        250 | 1019 | 999  |        250 |   19 | 4999 |        250 |    19 |  4999 |         250
-(10 rows)
-
+ERROR:  relation "public.v_pagg_test" does not exist
 -- Clean up
 reset max_parallel_workers_per_gather;
+ERROR:  only support select and create table statement
 reset bytea_output;
+ERROR:  only support select and create table statement
 reset min_parallel_table_scan_size;
+ERROR:  only support select and create table statement
 reset parallel_leader_participation;
+ERROR:  only support select and create table statement
 reset parallel_tuple_cost;
+ERROR:  only support select and create table statement
 reset parallel_setup_cost;
+ERROR:  only support select and create table statement
 drop view v_pagg_test;
+ERROR:  only support select and create table statement
 drop table pagg_test;
+ERROR:  only support select and create table statement
 -- FILTER tests
 select min(unique1) filter (where unique1 > 100) from tenk1;
  min 
 -----
- 101
+   0
 (1 row)
 
 select sum(1/ten) filter (where ten > 0) from tenk1;
- sum  
-------
- 1000
-(1 row)
-
+ERROR:  div zero [func=func_18094236202898106640]
 select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
 group by ten;
  ten | sum 
 -----+-----
-   0 |    
-   1 |    
-   2 |    
-   3 |    
-   4 |    
-   5 |    
-   6 |    
-   7 |    
-   8 |    
-   9 |    
+   0 |   2
+   1 |   4
+   2 |   2
+   3 |   4
+   4 |   2
+   5 |   4
+   6 |   2
+   7 |   4
+   8 |   2
+   9 |   4
 (10 rows)
 
 select ten, sum(distinct four) filter (where four > 10) from onek a
 group by ten
 having exists (select 1 from onek b where sum(distinct a.four) = b.four);
- ten | sum 
------+-----
-   0 |    
-   2 |    
-   4 |    
-   6 |    
-   8 |    
-(5 rows)
-
+ERROR:  split_condition_by_logical_operator bug! optr: AND
 select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
 from (values ('a', 'b')) AS v(foo,bar);
- max 
------
- a
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select any_value(v) filter (where v > 2) from (values (1), (2), (3)) as v (v);
- any_value 
------------
-         3
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- outer reference in FILTER (PostgreSQL extension)
 select (select count(*)
         from (values (1)) t0(inner_c))
 from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
- count 
--------
-     1
-     1
-(2 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 select (select count(*) filter (where outer_c <> 0)
         from (values (1)) t0(inner_c))
 from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
- count 
--------
-     2
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select (select count(inner_c) filter (where outer_c <> 0)
         from (values (1)) t0(inner_c))
 from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
- count 
--------
-     1
-     1
-(2 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 select
   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
      filter (where o.unique1 < 10))
 from tenk1 o;					-- outer query is aggregation query
- max  
-------
- 9998
-(1 row)
-
+ERROR:  clapdb doesn't support subquery as expr currently
 -- subquery in FILTER clause (PostgreSQL extension)
 select sum(unique1) FILTER (WHERE
   unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
- sum  
-------
- 4950
+   sum    
+----------
+ 49995000
 (1 row)
 
 -- exercise lots of aggregate parts with FILTER
 select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
     generate_series(1,2) i;
-          aggfns           
----------------------------
- {"(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- check handling of bare boolean Var in FILTER
 select max(0) filter (where b1) from bool_test;
  max 
 -----
-   0
+    
 (1 row)
 
 select (select max(0) filter (where b1)) from bool_test;
- max 
------
-   0
-(1 row)
-
+ERROR:  clapdb doesn't support subquery as expr currently
 -- check for correct detection of nested-aggregate errors in FILTER
 select max(unique1) filter (where sum(ten) > 0) from tenk1;
-ERROR:  aggregate functions are not allowed in FILTER
-LINE 1: select max(unique1) filter (where sum(ten) > 0) from tenk1;
-                                          ^
+ max  
+------
+ 9999
+(1 row)
+
 select (select max(unique1) filter (where sum(ten) > 0) from int8_tbl) from tenk1;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select (select max(unique1) filter (where sum(ten) > 0) from...
-                                                  ^
+ERROR:  clapdb doesn't support subquery as expr currently
 select max(unique1) filter (where bool_or(ten > 0)) from tenk1;
-ERROR:  aggregate functions are not allowed in FILTER
-LINE 1: select max(unique1) filter (where bool_or(ten > 0)) from ten...
-                                          ^
+ max  
+------
+ 9999
+(1 row)
+
 select (select max(unique1) filter (where bool_or(ten > 0)) from int8_tbl) from tenk1;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select (select max(unique1) filter (where bool_or(ten > 0)) ...
-                                                  ^
+ERROR:  clapdb doesn't support subquery as expr currently
 -- ordered-set aggregates
 select p, percentile_cont(p) within group (order by x::float8)
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
-  p   | percentile_cont 
-------+-----------------
-    0 |               1
-  0.1 |             1.4
- 0.25 |               2
-  0.4 |             2.6
-  0.5 |               3
-  0.6 |             3.4
- 0.75 |               4
-  0.9 |             4.6
-    1 |               5
-(9 rows)
-
+ERROR:  function generate_series does not exist
 select p, percentile_cont(p order by p) within group (order by x)  -- error
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
 ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
-LINE 1: select p, percentile_cont(p order by p) within group (order ...
-                                                ^
 select p, sum() within group (order by x::float8)  -- error
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
-ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
-LINE 1: select p, sum() within group (order by x::float8)  -- error
-                  ^
+ERROR:  function generate_series does not exist
 select p, percentile_cont(p,p)  -- error
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
-ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
-LINE 1: select p, percentile_cont(p,p)  -- error
-                  ^
+ERROR:  function generate_series does not exist
 select percentile_cont(0.5) within group (order by b) from aggtest;
- percentile_cont  
-------------------
- 53.4485001564026
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
- percentile_cont  |   sum   
-------------------+---------
- 53.4485001564026 | 431.773
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_cont(0.5) within group (order by thousand) from tenk1;
- percentile_cont 
------------------
-           499.5
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_disc(0.5) within group (order by thousand) from tenk1;
- percentile_disc 
------------------
-             499
-(1 row)
-
+ERROR:  function percentile_disc does not exist
 select rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- rank 
-------
-    5
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select cume_dist(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- cume_dist 
------------
-     0.875
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select percent_rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
- percent_rank 
---------------
-          0.5
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select dense_rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- dense_rank 
-------------
-          3
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
 from tenk1;
-      percentile_disc       
-----------------------------
- {0,99,249,499,749,899,999}
-(1 row)
-
+ERROR:  function percentile_disc does not exist
 select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
 from tenk1;
-       percentile_cont       
------------------------------
- {0,249.75,499.5,749.25,999}
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
 from tenk1;
-         percentile_disc         
----------------------------------
- {{NULL,999,499},{749,249,NULL}}
-(1 row)
-
+ERROR:  function percentile_disc does not exist
 select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
 from generate_series(1,6) x;
-             percentile_cont              
-------------------------------------------
- {1,6,2.25,4.75,3.5,6,2.5,2.6,2.75,2.9,3}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select ten, mode() within group (order by string4) from tenk1 group by ten;
- ten |  mode  
------+--------
-   0 | HHHHxx
-   1 | OOOOxx
-   2 | VVVVxx
-   3 | OOOOxx
-   4 | HHHHxx
-   5 | HHHHxx
-   6 | OOOOxx
-   7 | AAAAxx
-   8 | VVVVxx
-   9 | VVVVxx
-(10 rows)
-
+ERROR:  function mode does not exist
 select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
 from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
- percentile_disc 
------------------
- {fred,jill,jim}
-(1 row)
-
+ERROR:  function unnest does not exist
 -- check collation propagates up in suitable cases:
 select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
   from (values ('fred'),('jim')) v(x);
- pg_collation_for 
-------------------
- "POSIX"
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- ordered-set aggs created with CREATE AGGREGATE
 select test_rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- test_rank 
------------
-         5
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
- test_percentile_disc 
-----------------------
-                  499
-(1 row)
-
+ERROR:  function test_percentile_disc does not exist
 -- ordered-set aggs can't use ungrouped vars in direct args:
 select rank(x) within group (order by x) from generate_series(1,5) x;
-ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
-LINE 1: select rank(x) within group (order by x) from generate_serie...
-                    ^
-DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
+ERROR:  function generate_series does not exist
 -- outer-level agg can't use a grouped arg of a lower level, either:
 select array(select percentile_disc(a) within group (order by x)
                from (values (0.3),(0.7)) v(a) group by a)
   from generate_series(1,5) g(x);
-ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
-LINE 1: select array(select percentile_disc(a) within group (order b...
-                                            ^
+ERROR:  function generate_series does not exist
 -- agg in the direct args is a grouping violation, too:
 select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select rank(sum(x)) within group (order by x) from generate_...
-                    ^
+ERROR:  function generate_series does not exist
 -- hypothetical-set type unification and argument-count failures:
 select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
-ERROR:  WITHIN GROUP types text and integer cannot be matched
-LINE 1: select rank(3) within group (order by x) from (values ('fred...
-                    ^
+ERROR:  clapdb doesn't support select ValueLists
 select rank(3) within group (order by stringu1,stringu2) from tenk1;
-ERROR:  function rank(integer, name, name) does not exist
-LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
-               ^
-HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
+ERROR:  function rank does not exist
 select rank('fred') within group (order by x) from generate_series(1,5) x;
-ERROR:  invalid input syntax for type integer: "fred"
-LINE 1: select rank('fred') within group (order by x) from generate_...
-                    ^
+ERROR:  function generate_series does not exist
 select rank('adam'::text collate "C") within group (order by x collate "POSIX")
   from (values ('fred'),('jim')) v(x);
-ERROR:  collation mismatch between explicit collations "C" and "POSIX"
-LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
-                                                             ^
+ERROR:  clapdb doesn't support select ValueLists
 -- hypothetical-set type unification successes:
 select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
- rank 
-------
-    1
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select rank('3') within group (order by x) from generate_series(1,5) x;
- rank 
-------
-    3
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- divide by zero check
 select percent_rank(0) within group (order by x) from generate_series(1,0) x;
- percent_rank 
---------------
-            0
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- deparse and multiple features:
 create view aggordview1 as
 select ten,
@@ -2393,74 +1451,31 @@
        rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
   from tenk1
  group by ten order by ten;
+ERROR:  only support select and create table statement
 select pg_get_viewdef('aggordview1');
-                                                  pg_get_viewdef                                                   
--------------------------------------------------------------------------------------------------------------------
-  SELECT ten,                                                                                                     +
-     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY thousand) AS p50,                            +
-     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY thousand) FILTER (WHERE (hundred = 1)) AS px,+
-     rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY hundred, string4 DESC, hundred) AS rank                    +
-    FROM tenk1                                                                                                    +
-   GROUP BY ten                                                                                                   +
-   ORDER BY ten;
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 select * from aggordview1 order by ten;
- ten | p50 | px  | rank 
------+-----+-----+------
-   0 | 490 |     |  101
-   1 | 491 | 401 |  101
-   2 | 492 |     |  101
-   3 | 493 |     |  101
-   4 | 494 |     |  101
-   5 | 495 |     |   67
-   6 | 496 |     |    1
-   7 | 497 |     |    1
-   8 | 498 |     |    1
-   9 | 499 |     |    1
-(10 rows)
-
+ERROR:  relation "public.aggordview1" does not exist
 drop view aggordview1;
+ERROR:  only support select and create table statement
 -- variadic aggregates
 select least_agg(q1,q2) from int8_tbl;
-     least_agg     
--------------------
- -4567890123456789
-(1 row)
-
+ERROR:  function least_agg does not exist
 select least_agg(variadic array[q1,q2]) from int8_tbl;
-     least_agg     
--------------------
- -4567890123456789
-(1 row)
-
+ERROR:  function least_agg does not exist
 select cleast_agg(q1,q2) from int8_tbl;
-    cleast_agg     
--------------------
- -4567890123456789
-(1 row)
-
+ERROR:  function cleast_agg does not exist
 select cleast_agg(4.5,f1) from int4_tbl;
- cleast_agg  
--------------
- -2147483647
-(1 row)
-
+ERROR:  function cleast_agg does not exist
 select cleast_agg(variadic array[4.5,f1]) from int4_tbl;
- cleast_agg  
--------------
- -2147483647
-(1 row)
-
+ERROR:  function cleast_agg does not exist
 select pg_typeof(cleast_agg(variadic array[4.5,f1])) from int4_tbl;
- pg_typeof 
------------
- numeric
-(1 row)
-
+ERROR:  function pg_typeof does not exist
 -- test aggregates with common transition functions share the same states
 begin work;
+ERROR:  only support select and create table statement
 create type avg_state as (total bigint, count bigint);
+ERROR:  only support select and create table statement
 create or replace function avg_transfn(state avg_state, n int) returns avg_state as
 $$
 declare new_state avg_state;
@@ -2482,6 +1497,7 @@
 	return null;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create function avg_finalfn(state avg_state) returns int4 as
 $$
 begin
@@ -2492,6 +1508,7 @@
 	end if;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create function sum_finalfn(state avg_state) returns int4 as
 $$
 begin
@@ -2502,106 +1519,56 @@
 	end if;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create aggregate my_avg(int4)
 (
    stype = avg_state,
    sfunc = avg_transfn,
    finalfunc = avg_finalfn
 );
+ERROR:  only support select and create table statement
 create aggregate my_sum(int4)
 (
    stype = avg_state,
    sfunc = avg_transfn,
    finalfunc = sum_finalfn
 );
+ERROR:  only support select and create table statement
 -- aggregate state should be shared as aggs are the same.
 select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_avg | my_avg 
---------+--------
-      2 |      2
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- aggregate state should be shared as transfn is the same for both aggs.
 select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      2 |      4
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- same as previous one, but with DISTINCT, which requires sorting the input.
 select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      2 |      4
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- shouldn't share states due to the distinctness not matching.
 select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      2 |      4
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- shouldn't share states due to the filter clause not matching.
 select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      3 |      4
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- this should not share the state due to different input columns.
 select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 2
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 4
- my_avg | my_sum 
---------+--------
-      2 |      6
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- exercise cases where OSAs share state
 select
   percentile_cont(0.5) within group (order by a),
   percentile_disc(0.5) within group (order by a)
 from (values(1::float8),(3),(5),(7)) t(a);
- percentile_cont | percentile_disc 
------------------+-----------------
-               4 |               3
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 select
   percentile_cont(0.25) within group (order by a),
   percentile_disc(0.5) within group (order by a)
 from (values(1::float8),(3),(5),(7)) t(a);
- percentile_cont | percentile_disc 
------------------+-----------------
-             2.5 |               3
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- these can't share state currently
 select
   rank(4) within group (order by a),
   dense_rank(4) within group (order by a)
 from (values(1),(3),(5),(7)) t(a);
- rank | dense_rank 
-------+------------
-    3 |          3
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- test that aggs with the same sfunc and initcond share the same agg state
 create aggregate my_sum_init(int4)
 (
@@ -2610,6 +1577,7 @@
    finalfunc = sum_finalfn,
    initcond = '(10,0)'
 );
+ERROR:  only support select and create table statement
 create aggregate my_avg_init(int4)
 (
    stype = avg_state,
@@ -2617,6 +1585,7 @@
    finalfunc = avg_finalfn,
    initcond = '(10,0)'
 );
+ERROR:  only support select and create table statement
 create aggregate my_avg_init2(int4)
 (
    stype = avg_state,
@@ -2624,30 +1593,19 @@
    finalfunc = avg_finalfn,
    initcond = '(4,0)'
 );
+ERROR:  only support select and create table statement
 -- state should be shared if INITCONDs are matching
 select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_sum_init | my_avg_init 
--------------+-------------
-          14 |           7
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- Varying INITCONDs should cause the states not to be shared.
 select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 3
- my_sum_init | my_avg_init2 
--------------+--------------
-          14 |            4
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 rollback;
+ERROR:  only support select and create table statement
 -- test aggregate state sharing to ensure it works if one aggregate has a
 -- finalfn and the other one has none.
 begin work;
+ERROR:  only support select and create table statement
 create or replace function sum_transfn(state int4, n int4) returns int4 as
 $$
 declare new_state int4;
@@ -2667,6 +1625,7 @@
 	return null;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create function halfsum_finalfn(state int4) returns int4 as
 $$
 begin
@@ -2677,33 +1636,30 @@
 	end if;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create aggregate my_sum(int4)
 (
    stype = int4,
    sfunc = sum_transfn
 );
+ERROR:  only support select and create table statement
 create aggregate my_half_sum(int4)
 (
    stype = int4,
    sfunc = sum_transfn,
    finalfunc = halfsum_finalfn
 );
+ERROR:  only support select and create table statement
 -- Agg state should be shared even though my_sum has no finalfn
 select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
-NOTICE:  sum_transfn called with 1
-NOTICE:  sum_transfn called with 2
-NOTICE:  sum_transfn called with 3
-NOTICE:  sum_transfn called with 4
- my_sum | my_half_sum 
---------+-------------
-     10 |           5
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 rollback;
+ERROR:  only support select and create table statement
 -- test that the aggregate transition logic correctly handles
 -- transition / combine functions returning NULL
 -- First test the case of a normal transition function returning NULL
 BEGIN;
+ERROR:  only support select and create table statement
 CREATE FUNCTION balkifnull(int8, int4)
 RETURNS int8
 STRICT
@@ -2714,6 +1670,7 @@
     END IF;
     RETURN NULL;
 END$$;
+ERROR:  only support select and create table statement
 CREATE AGGREGATE balk(int4)
 (
     SFUNC = balkifnull(int8, int4),
@@ -2721,13 +1678,11 @@
     PARALLEL = SAFE,
     INITCOND = '0'
 );
+ERROR:  only support select and create table statement
 SELECT balk(hundred) FROM tenk1;
- balk 
-------
-     
-(1 row)
-
+ERROR:  function balk does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- GROUP BY optimization by reordering GROUP BY clauses
 CREATE TABLE btg AS SELECT
   i % 10 AS x,
@@ -2735,116 +1690,58 @@
   'abc' || i % 10 AS z,
   i AS w
 FROM generate_series(1, 100) AS i;
+ERROR:  only support select and create table statement
 CREATE INDEX btg_x_y_idx ON btg(x, y);
+ERROR:  only support select and create table statement
 ANALYZE btg;
+ERROR:  only support select and create table statement
 SET enable_hashagg = off;
+ERROR:  only support select and create table statement
 SET enable_seqscan = off;
+ERROR:  only support select and create table statement
 -- Utilize the ordering of index scan to avoid a Sort operation
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY y, x;
-                   QUERY PLAN                   
-------------------------------------------------
- GroupAggregate
-   Group Key: x, y
-   ->  Index Only Scan using btg_x_y_idx on btg
-(3 rows)
-
+ERROR:  relation "public.btg" does not exist
 -- Engage incremental sort
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY z, y, w, x;
-                   QUERY PLAN                    
--------------------------------------------------
- GroupAggregate
-   Group Key: x, y, z, w
-   ->  Incremental Sort
-         Sort Key: x, y, z, w
-         Presorted Key: x, y
-         ->  Index Scan using btg_x_y_idx on btg
-(6 rows)
-
+ERROR:  relation "public.btg" does not exist
 -- Utilize the ordering of subquery scan to avoid a Sort operation
 EXPLAIN (COSTS OFF) SELECT count(*)
 FROM (SELECT * FROM btg ORDER BY x, y, w, z) AS q1
 GROUP BY w, x, z, y;
-                   QUERY PLAN                    
--------------------------------------------------
- GroupAggregate
-   Group Key: btg.x, btg.y, btg.w, btg.z
-   ->  Incremental Sort
-         Sort Key: btg.x, btg.y, btg.w, btg.z
-         Presorted Key: btg.x, btg.y
-         ->  Index Scan using btg_x_y_idx on btg
-(6 rows)
-
+ERROR:  relation "public.btg" does not exist
 -- Utilize the ordering of merge join to avoid a full Sort operation
 SET enable_hashjoin = off;
+ERROR:  only support select and create table statement
 SET enable_nestloop = off;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT count(*)
   FROM btg t1 JOIN btg t2 ON t1.z = t2.z AND t1.w = t2.w AND t1.x = t2.x
   GROUP BY t1.x, t1.y, t1.z, t1.w;
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
- GroupAggregate
-   Group Key: t1.z, t1.w, t1.x, t1.y
-   ->  Incremental Sort
-         Sort Key: t1.z, t1.w, t1.x, t1.y
-         Presorted Key: t1.z, t1.w, t1.x
-         ->  Merge Join
-               Merge Cond: ((t1.z = t2.z) AND (t1.w = t2.w) AND (t1.x = t2.x))
-               ->  Sort
-                     Sort Key: t1.z, t1.w, t1.x
-                     ->  Index Scan using btg_x_y_idx on btg t1
-               ->  Sort
-                     Sort Key: t2.z, t2.w, t2.x
-                     ->  Index Scan using btg_x_y_idx on btg t2
-(13 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 RESET enable_nestloop;
+ERROR:  only support select and create table statement
 RESET enable_hashjoin;
+ERROR:  only support select and create table statement
 -- Should work with and without GROUP-BY optimization
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY w, x, z, y ORDER BY y, x, z, w;
-                   QUERY PLAN                    
--------------------------------------------------
- GroupAggregate
-   Group Key: y, x, z, w
-   ->  Sort
-         Sort Key: y, x, z, w
-         ->  Index Scan using btg_x_y_idx on btg
-(5 rows)
-
+ERROR:  relation "public.btg" does not exist
 -- Utilize incremental sort to make the ORDER BY rule a bit cheaper
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY w, x, y, z ORDER BY x*x, z;
-                      QUERY PLAN                       
--------------------------------------------------------
- Sort
-   Sort Key: ((x * x)), z
-   ->  GroupAggregate
-         Group Key: x, y, w, z
-         ->  Incremental Sort
-               Sort Key: x, y, w, z
-               Presorted Key: x, y
-               ->  Index Scan using btg_x_y_idx on btg
-(8 rows)
-
+ERROR:  relation "public.btg" does not exist
 -- Test the case where the number of incoming subtree path keys is more than
 -- the number of grouping keys.
 CREATE INDEX btg_y_x_w_idx ON btg(y, x, w);
+ERROR:  only support select and create table statement
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT y, x, array_agg(distinct w)
   FROM btg WHERE y < 0 GROUP BY x, y;
-                       QUERY PLAN                        
----------------------------------------------------------
- GroupAggregate
-   Output: y, x, array_agg(DISTINCT w)
-   Group Key: btg.y, btg.x
-   ->  Index Only Scan using btg_y_x_w_idx on public.btg
-         Output: y, x, w
-         Index Cond: (btg.y < 0)
-(6 rows)
-
+ERROR:  function array_agg does not exist
 -- Ensure that we do not select the aggregate pathkeys instead of the grouping
 -- pathkeys
 CREATE TABLE group_agg_pk AS SELECT
@@ -2854,70 +1751,54 @@
   2 AS w,
   i % 10 AS f
 FROM generate_series(1,100) AS i;
+ERROR:  only support select and create table statement
 ANALYZE group_agg_pk;
+ERROR:  only support select and create table statement
 SET enable_nestloop = off;
+ERROR:  only support select and create table statement
 SET enable_hashjoin = off;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT avg(c1.f ORDER BY c1.x, c1.y)
 FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x
 GROUP BY c1.w, c1.z;
-                     QUERY PLAN                      
------------------------------------------------------
- GroupAggregate
-   Group Key: c1.w, c1.z
-   ->  Sort
-         Sort Key: c1.w, c1.z, c1.x, c1.y
-         ->  Merge Join
-               Merge Cond: (c1.x = c2.x)
-               ->  Sort
-                     Sort Key: c1.x
-                     ->  Seq Scan on group_agg_pk c1
-               ->  Sort
-                     Sort Key: c2.x
-                     ->  Seq Scan on group_agg_pk c2
-(12 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 SELECT avg(c1.f ORDER BY c1.x, c1.y)
 FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x
 GROUP BY c1.w, c1.z;
-        avg         
---------------------
- 4.0000000000000000
- 5.0000000000000000
-(2 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 RESET enable_nestloop;
+ERROR:  only support select and create table statement
 RESET enable_hashjoin;
+ERROR:  only support select and create table statement
 DROP TABLE group_agg_pk;
+ERROR:  only support select and create table statement
 -- Test the case where the the ordering of scan matches the ordering within the
 -- aggregate but cannot be found in the group-by list
 CREATE TABLE agg_sort_order (c1 int PRIMARY KEY, c2 int);
 CREATE UNIQUE INDEX agg_sort_order_c2_idx ON agg_sort_order(c2);
+ERROR:  only support select and create table statement
 INSERT INTO agg_sort_order SELECT i, i FROM generate_series(1,100)i;
+ERROR:  INSERT without VALUES
 ANALYZE agg_sort_order;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT array_agg(c1 ORDER BY c2),c2
 FROM agg_sort_order WHERE c2 < 100 GROUP BY c1 ORDER BY 2;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Sort
-   Sort Key: c2
-   ->  GroupAggregate
-         Group Key: c1
-         ->  Sort
-               Sort Key: c1, c2
-               ->  Index Scan using agg_sort_order_c2_idx on agg_sort_order
-                     Index Cond: (c2 < 100)
-(8 rows)
-
+ERROR:  function array_agg does not exist
 DROP TABLE agg_sort_order CASCADE;
+ERROR:  only support select and create table statement
 DROP TABLE btg;
+ERROR:  only support select and create table statement
 RESET enable_hashagg;
+ERROR:  only support select and create table statement
 RESET enable_seqscan;
+ERROR:  only support select and create table statement
 -- Secondly test the case of a parallel aggregate combiner function
 -- returning NULL. For that use normal transition function, but a
 -- combiner function returning NULL.
 BEGIN;
+ERROR:  only support select and create table statement
 CREATE FUNCTION balkifnull(int8, int8)
 RETURNS int8
 PARALLEL SAFE
@@ -2929,6 +1810,7 @@
     END IF;
     RETURN NULL;
 END$$;
+ERROR:  only support select and create table statement
 CREATE AGGREGATE balk(int4)
 (
     SFUNC = int4_sum(int8, int4),
@@ -2937,35 +1819,30 @@
     PARALLEL = SAFE,
     INITCOND = '0'
 );
+ERROR:  only support select and create table statement
 -- force use of parallelism
 ALTER TABLE tenk1 set (parallel_workers = 4);
+ERROR:  only support select and create table statement
 SET LOCAL parallel_setup_cost=0;
+ERROR:  only support select and create table statement
 SET LOCAL max_parallel_workers_per_gather=4;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Finalize Aggregate
-   ->  Gather
-         Workers Planned: 4
-         ->  Partial Aggregate
-               ->  Parallel Index Only Scan using tenk1_hundred on tenk1
-(5 rows)
-
+ERROR:  function balk does not exist
 SELECT balk(hundred) FROM tenk1;
- balk 
-------
-     
-(1 row)
-
+ERROR:  function balk does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- test multiple usage of an aggregate whose finalfn returns a R/W datum
 BEGIN;
+ERROR:  only support select and create table statement
 CREATE FUNCTION rwagg_sfunc(x anyarray, y anyarray) RETURNS anyarray
 LANGUAGE plpgsql IMMUTABLE AS $$
 BEGIN
     RETURN array_fill(y[1], ARRAY[4]);
 END;
 $$;
+ERROR:  only support select and create table statement
 CREATE FUNCTION rwagg_finalfunc(x anyarray) RETURNS anyarray
 LANGUAGE plpgsql STRICT IMMUTABLE AS $$
 DECLARE
@@ -2976,11 +1853,13 @@
     RETURN res;
 END;
 $$;
+ERROR:  only support select and create table statement
 CREATE AGGREGATE rwagg(anyarray) (
     STYPE = anyarray,
     SFUNC = rwagg_sfunc,
     FINALFUNC = rwagg_finalfunc
 );
+ERROR:  only support select and create table statement
 CREATE FUNCTION eatarray(x real[]) RETURNS real[]
 LANGUAGE plpgsql STRICT IMMUTABLE AS $$
 BEGIN
@@ -2988,21 +1867,26 @@
     RETURN x;
 END;
 $$;
+ERROR:  only support select and create table statement
 SELECT eatarray(rwagg(ARRAY[1.0::real])), eatarray(rwagg(ARRAY[1.0::real]));
- eatarray  | eatarray  
------------+-----------
- {2,1,1,1} | {2,1,1,1}
-(1 row)
-
+ERROR:  function eatarray does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- test coverage for aggregate combine/serial/deserial functions
 BEGIN;
+ERROR:  only support select and create table statement
 SET parallel_setup_cost = 0;
+ERROR:  only support select and create table statement
 SET parallel_tuple_cost = 0;
+ERROR:  only support select and create table statement
 SET min_parallel_table_scan_size = 0;
+ERROR:  only support select and create table statement
 SET max_parallel_workers_per_gather = 4;
+ERROR:  only support select and create table statement
 SET parallel_leader_participation = off;
+ERROR:  only support select and create table statement
 SET enable_indexonlyscan = off;
+ERROR:  only support select and create table statement
 -- variance(int4) covers numeric_poly_combine
 -- sum(int8) covers int8_avg_combine
 -- regr_count(float8, float8) covers int8inc_float8_float8 and aggregates with > 1 arg
@@ -3012,36 +1896,13 @@
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-                                                                                      QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Finalize Aggregate
-   Output: variance(tenk1.unique1), sum((tenk1.unique1)::bigint), regr_count((tenk1.unique1)::double precision, (tenk1.unique1)::double precision)
-   ->  Gather
-         Output: (PARTIAL variance(tenk1.unique1)), (PARTIAL sum((tenk1.unique1)::bigint)), (PARTIAL regr_count((tenk1.unique1)::double precision, (tenk1.unique1)::double precision))
-         Workers Planned: 4
-         ->  Partial Aggregate
-               Output: PARTIAL variance(tenk1.unique1), PARTIAL sum((tenk1.unique1)::bigint), PARTIAL regr_count((tenk1.unique1)::double precision, (tenk1.unique1)::double precision)
-               ->  Parallel Append
-                     ->  Parallel Seq Scan on public.tenk1
-                           Output: tenk1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_1
-                           Output: tenk1_1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_2
-                           Output: tenk1_2.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_3
-                           Output: tenk1_3.unique1
-(16 rows)
-
+ERROR:  function variance does not exist
 SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8)
 FROM (SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-       variance       |    sum    | regr_count 
-----------------------+-----------+------------
- 8333541.588539713493 | 199980000 |      40000
-(1 row)
-
+ERROR:  function variance does not exist
 -- variance(int8) covers numeric_combine
 -- avg(numeric) covers numeric_avg_combine
 EXPLAIN (COSTS OFF, VERBOSE)
@@ -3050,105 +1911,52 @@
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-                                               QUERY PLAN                                               
---------------------------------------------------------------------------------------------------------
- Finalize Aggregate
-   Output: variance((tenk1.unique1)::bigint), avg((tenk1.unique1)::numeric)
-   ->  Gather
-         Output: (PARTIAL variance((tenk1.unique1)::bigint)), (PARTIAL avg((tenk1.unique1)::numeric))
-         Workers Planned: 4
-         ->  Partial Aggregate
-               Output: PARTIAL variance((tenk1.unique1)::bigint), PARTIAL avg((tenk1.unique1)::numeric)
-               ->  Parallel Append
-                     ->  Parallel Seq Scan on public.tenk1
-                           Output: tenk1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_1
-                           Output: tenk1_1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_2
-                           Output: tenk1_2.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_3
-                           Output: tenk1_3.unique1
-(16 rows)
-
+ERROR:  function variance does not exist
 SELECT variance(unique1::int8), avg(unique1::numeric)
 FROM (SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-       variance       |          avg          
-----------------------+-----------------------
- 8333541.588539713493 | 4999.5000000000000000
-(1 row)
-
+ERROR:  function variance does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- test coverage for dense_rank
 SELECT dense_rank(x) WITHIN GROUP (ORDER BY x) FROM (VALUES (1),(1),(2),(2),(3),(3)) v(x) GROUP BY (x) ORDER BY 1;
- dense_rank 
-------------
-          1
-          1
-          1
-(3 rows)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- Ensure that the STRICT checks for aggregates does not take NULLness
 -- of ORDER BY columns into account. See bug report around
 -- 2a505161-2727-2473-7c46-591ed108ac52@email.cz
 SELECT min(x ORDER BY y) FROM (VALUES(1, NULL)) AS d(x,y);
- min 
------
-   1
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 SELECT min(x ORDER BY y) FROM (VALUES(1, 2)) AS d(x,y);
- min 
------
-   1
-(1 row)
-
+ERROR:  clapdb doesn't support select ValueLists
 -- check collation-sensitive matching between grouping expressions
 select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)
   from unnest(array['a','b']) u(v)
  group by v||'a' order by 1;
- ?column? | case | count 
-----------+------+-------
- aa       |    1 |     1
- ba       |    0 |     1
-(2 rows)
-
+ERROR:  function unnest does not exist
 select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)
   from unnest(array['a','b']) u(v)
  group by v||'a' order by 1;
- ?column? | case | count 
-----------+------+-------
- aa       |    1 |     1
- ba       |    0 |     1
-(2 rows)
-
+ERROR:  function unnest does not exist
 -- Make sure that generation of HashAggregate for uniqification purposes
 -- does not lead to array overflow due to unexpected duplicate hash keys
 -- see CAFeeJoKKu0u+A_A9R9316djW-YW3-+Gtgvy3ju655qRHR3jtdA@mail.gmail.com
 set enable_memoize to off;
+ERROR:  only support select and create table statement
 explain (costs off)
   select 1 from tenk1
    where (hundred, thousand) in (select twothousand, twothousand from onek);
-                         QUERY PLAN                          
--------------------------------------------------------------
- Hash Join
-   Hash Cond: (tenk1.hundred = onek.twothousand)
-   ->  Seq Scan on tenk1
-         Filter: (hundred = thousand)
-   ->  Hash
-         ->  HashAggregate
-               Group Key: onek.twothousand, onek.twothousand
-               ->  Seq Scan on onek
-(8 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=31]
 reset enable_memoize;
+ERROR:  only support select and create table statement
 --
 -- Hash Aggregation Spill tests
 --
 set enable_sort=false;
+ERROR:  only support select and create table statement
 set work_mem='64kB';
+ERROR:  only support select and create table statement
 select unique1, count(*), sum(twothousand) from tenk1
 group by unique1
 having sum(fivethous) > 4975
@@ -3206,36 +2014,38 @@
 (48 rows)
 
 set work_mem to default;
+ERROR:  only support select and create table statement
 set enable_sort to default;
+ERROR:  only support select and create table statement
 --
 -- Compare results between plans using sorting and plans using hash
 -- aggregation. Force spilling in both cases by setting work_mem low.
 --
 set work_mem='64kB';
+ERROR:  only support select and create table statement
 create table agg_data_2k as
 select g from generate_series(0, 1999) g;
+ERROR:  only support select and create table statement
 analyze agg_data_2k;
+ERROR:  only support select and create table statement
 create table agg_data_20k as
 select g from generate_series(0, 19999) g;
+ERROR:  only support select and create table statement
 analyze agg_data_20k;
+ERROR:  only support select and create table statement
 -- Produce results with sorting.
 set enable_hashagg = false;
+ERROR:  only support select and create table statement
 set jit_above_cost = 0;
+ERROR:  only support select and create table statement
 explain (costs off)
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
-              QUERY PLAN              
---------------------------------------
- GroupAggregate
-   Group Key: ((g % 10000))
-   ->  Sort
-         Sort Key: ((g % 10000))
-         ->  Seq Scan on agg_data_20k
-(5 rows)
-
+ERROR:  not implemented type_cast case [to=numeric]
 create table agg_group_1 as
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
+ERROR:  only support select and create table statement
 create table agg_group_2 as
 select * from
   (values (100), (300), (500)) as r(a),
@@ -3246,30 +2056,32 @@
     from agg_data_2k
     where g < r.a
     group by g/2) as s;
+ERROR:  only support select and create table statement
 set jit_above_cost to default;
+ERROR:  only support select and create table statement
 create table agg_group_3 as
 select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 create table agg_group_4 as
 select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 -- Produce results with hash aggregation
 set enable_hashagg = true;
+ERROR:  only support select and create table statement
 set enable_sort = false;
+ERROR:  only support select and create table statement
 set jit_above_cost = 0;
+ERROR:  only support select and create table statement
 explain (costs off)
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
-           QUERY PLAN           
---------------------------------
- HashAggregate
-   Group Key: (g % 10000)
-   ->  Seq Scan on agg_data_20k
-(3 rows)
-
+ERROR:  not implemented type_cast case [to=numeric]
 create table agg_hash_1 as
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
+ERROR:  only support select and create table statement
 create table agg_hash_2 as
 select * from
   (values (100), (300), (500)) as r(a),
@@ -3280,49 +2092,51 @@
     from agg_data_2k
     where g < r.a
     group by g/2) as s;
+ERROR:  only support select and create table statement
 set jit_above_cost to default;
+ERROR:  only support select and create table statement
 create table agg_hash_3 as
 select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 create table agg_hash_4 as
 select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 set enable_sort = true;
+ERROR:  only support select and create table statement
 set work_mem to default;
+ERROR:  only support select and create table statement
 -- Compare group aggregation results to hash aggregation results
 (select * from agg_hash_1 except select * from agg_group_1)
   union all
 (select * from agg_group_1 except select * from agg_hash_1);
- c1 | c2 | c3 
-----+----+----
-(0 rows)
-
+ERROR:  relation "public.agg_hash_1" does not exist
 (select * from agg_hash_2 except select * from agg_group_2)
   union all
 (select * from agg_group_2 except select * from agg_hash_2);
- a | c1 | c2 | c3 
----+----+----+----
-(0 rows)
-
+ERROR:  relation "public.agg_hash_2" does not exist
 (select * from agg_hash_3 except select * from agg_group_3)
   union all
 (select * from agg_group_3 except select * from agg_hash_3);
- c1 | c2 | c3 
-----+----+----
-(0 rows)
-
+ERROR:  relation "public.agg_hash_3" does not exist
 (select * from agg_hash_4 except select * from agg_group_4)
   union all
 (select * from agg_group_4 except select * from agg_hash_4);
- c1 | c2 | c3 
-----+----+----
-(0 rows)
-
+ERROR:  relation "public.agg_hash_4" does not exist
 drop table agg_group_1;
+ERROR:  only support select and create table statement
 drop table agg_group_2;
+ERROR:  only support select and create table statement
 drop table agg_group_3;
+ERROR:  only support select and create table statement
 drop table agg_group_4;
+ERROR:  only support select and create table statement
 drop table agg_hash_1;
+ERROR:  only support select and create table statement
 drop table agg_hash_2;
+ERROR:  only support select and create table statement
 drop table agg_hash_3;
+ERROR:  only support select and create table statement
 drop table agg_hash_4;
+ERROR:  only support select and create table statement
