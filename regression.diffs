diff -U3 /home/longqimin/pg_regress_input/expected/boolean.out /home/longqimin/pg_regress_input/results/boolean.out
--- /home/longqimin/pg_regress_input/expected/boolean.out	2024-03-08 10:39:42.632805177 +0800
+++ /home/longqimin/pg_regress_input/results/boolean.out	2024-03-08 13:58:42.114482662 +0800
@@ -44,8 +44,6 @@
 
 SELECT bool 'test' AS error;
 ERROR:  invalid input syntax for type boolean: "test"
-LINE 1: SELECT bool 'test' AS error;
-                    ^
 SELECT bool 'false' AS false;
  false 
 -------
@@ -54,8 +52,6 @@
 
 SELECT bool 'foo' AS error;
 ERROR:  invalid input syntax for type boolean: "foo"
-LINE 1: SELECT bool 'foo' AS error;
-                    ^
 SELECT bool 'y' AS true;
  true 
 ------
@@ -70,8 +66,6 @@
 
 SELECT bool 'yeah' AS error;
 ERROR:  invalid input syntax for type boolean: "yeah"
-LINE 1: SELECT bool 'yeah' AS error;
-                    ^
 SELECT bool 'n' AS false;
  false 
 -------
@@ -86,8 +80,6 @@
 
 SELECT bool 'nay' AS error;
 ERROR:  invalid input syntax for type boolean: "nay"
-LINE 1: SELECT bool 'nay' AS error;
-                    ^
 SELECT bool 'on' AS true;
  true 
 ------
@@ -108,16 +100,10 @@
 
 SELECT bool 'o' AS error;
 ERROR:  invalid input syntax for type boolean: "o"
-LINE 1: SELECT bool 'o' AS error;
-                    ^
 SELECT bool 'on_' AS error;
 ERROR:  invalid input syntax for type boolean: "on_"
-LINE 1: SELECT bool 'on_' AS error;
-                    ^
 SELECT bool 'off_' AS error;
 ERROR:  invalid input syntax for type boolean: "off_"
-LINE 1: SELECT bool 'off_' AS error;
-                    ^
 SELECT bool '1' AS true;
  true 
 ------
@@ -126,8 +112,6 @@
 
 SELECT bool '11' AS error;
 ERROR:  invalid input syntax for type boolean: "11"
-LINE 1: SELECT bool '11' AS error;
-                    ^
 SELECT bool '0' AS false;
  false 
 -------
@@ -136,31 +120,15 @@
 
 SELECT bool '000' AS error;
 ERROR:  invalid input syntax for type boolean: "000"
-LINE 1: SELECT bool '000' AS error;
-                    ^
 SELECT bool '' AS error;
 ERROR:  invalid input syntax for type boolean: ""
-LINE 1: SELECT bool '' AS error;
-                    ^
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('true', 'bool');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('asdf', 'bool');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('junk', 'bool');
-                    message                    | detail | hint | sql_error_code 
------------------------------------------------+--------+------+----------------
- invalid input syntax for type boolean: "junk" |        |      | 22P02
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- and, or, not in qualifications
 SELECT bool 't' or bool 'f' AS true;
  true 
@@ -276,10 +244,7 @@
 SELECT BOOLTBL1.*
    FROM BOOLTBL1
    WHERE booleq(bool 'false', f1);
- f1 
-----
-(0 rows)
-
+ERROR:  function booleq does not exist
 INSERT INTO BOOLTBL1 (f1) VALUES (bool 'f');
 SELECT BOOLTBL1.*
    FROM BOOLTBL1
@@ -299,8 +264,6 @@
 INSERT INTO BOOLTBL2 (f1)
    VALUES (bool 'XXX');
 ERROR:  invalid input syntax for type boolean: "XXX"
-LINE 2:    VALUES (bool 'XXX');
-                        ^
 -- BOOLTBL2 should be full of false's at this point
 SELECT BOOLTBL2.* FROM BOOLTBL2;
  f1 
@@ -314,76 +277,20 @@
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE BOOLTBL2.f1 <> BOOLTBL1.f1;
- f1 | f1 
-----+----
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
-(12 rows)
-
+ERROR:  column reference "f1" is ambiguous
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE boolne(BOOLTBL2.f1,BOOLTBL1.f1);
- f1 | f1 
-----+----
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
-(12 rows)
-
+ERROR:  function boolne does not exist
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE BOOLTBL2.f1 = BOOLTBL1.f1 and BOOLTBL1.f1 = bool 'false';
- f1 | f1 
-----+----
- f  | f
- f  | f
- f  | f
- f  | f
-(4 rows)
-
+ERROR:  column reference "f1" is ambiguous
 SELECT BOOLTBL1.*, BOOLTBL2.*
    FROM BOOLTBL1, BOOLTBL2
    WHERE BOOLTBL2.f1 = BOOLTBL1.f1 or BOOLTBL1.f1 = bool 'true'
    ORDER BY BOOLTBL1.f1, BOOLTBL2.f1;
- f1 | f1 
-----+----
- f  | f
- f  | f
- f  | f
- f  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
- t  | f
-(16 rows)
-
+ERROR:  column reference "f1" is ambiguous
 --
 -- SQL syntax
 -- Try all combinations to ensure that we get nothing when we expect nothing
@@ -568,20 +475,20 @@
 
 -- Casts
 SELECT 0::boolean;
- bool 
-------
+ boolean 
+---------
  f
 (1 row)
 
 SELECT 1::boolean;
- bool 
-------
+ boolean 
+---------
  t
 (1 row)
 
 SELECT 2::boolean;
- bool 
-------
+ boolean 
+---------
  t
 (1 row)
 
@@ -592,6 +499,10 @@
 --  - thomas 1997-11-30
 --
 DROP TABLE  BOOLTBL1;
+ERROR:  only support select and create table statement
 DROP TABLE  BOOLTBL2;
+ERROR:  only support select and create table statement
 DROP TABLE  BOOLTBL3;
+ERROR:  only support select and create table statement
 DROP TABLE  BOOLTBL4;
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/pg_regress_input/expected/int2.out /home/longqimin/pg_regress_input/results/int2.out
--- /home/longqimin/pg_regress_input/expected/int2.out	2024-02-27 09:30:35.087460301 +0800
+++ /home/longqimin/pg_regress_input/results/int2.out	2024-03-08 13:58:42.494482625 +0800
@@ -4,37 +4,21 @@
 -- int2_tbl was already created and filled in test_setup.sql.
 -- Here we just try to insert bad values.
 INSERT INTO INT2_TBL(f1) VALUES ('34.5');
-ERROR:  invalid input syntax for type smallint: "34.5"
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('34.5');
-                                         ^
+ERROR:  invalid input syntax for type integer: "34.5"
 INSERT INTO INT2_TBL(f1) VALUES ('100000');
-ERROR:  value "100000" is out of range for type smallint
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('100000');
-                                         ^
+ERROR:  value "100000" is out of range for type integer
 INSERT INTO INT2_TBL(f1) VALUES ('asdf');
-ERROR:  invalid input syntax for type smallint: "asdf"
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('asdf');
-                                         ^
+ERROR:  invalid input syntax for type integer: "asdf"
 INSERT INTO INT2_TBL(f1) VALUES ('    ');
-ERROR:  invalid input syntax for type smallint: "    "
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('    ');
-                                         ^
+ERROR:  invalid input syntax for type integer: "    "
 INSERT INTO INT2_TBL(f1) VALUES ('- 1234');
-ERROR:  invalid input syntax for type smallint: "- 1234"
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('- 1234');
-                                         ^
+ERROR:  invalid input syntax for type integer: "- 1234"
 INSERT INTO INT2_TBL(f1) VALUES ('4 444');
-ERROR:  invalid input syntax for type smallint: "4 444"
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('4 444');
-                                         ^
+ERROR:  invalid input syntax for type integer: "4 444"
 INSERT INTO INT2_TBL(f1) VALUES ('123 dt');
-ERROR:  invalid input syntax for type smallint: "123 dt"
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('123 dt');
-                                         ^
+ERROR:  invalid input syntax for type integer: "123 dt"
 INSERT INTO INT2_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for type smallint: ""
-LINE 1: INSERT INTO INT2_TBL(f1) VALUES ('');
-                                         ^
+ERROR:  invalid input syntax for type integer: ""
 SELECT * FROM INT2_TBL;
    f1   
 --------
@@ -47,52 +31,40 @@
 
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34', 'int2');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('asdf', 'int2');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('50000', 'int2');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('50000', 'int2');
-                     message                     | detail | hint | sql_error_code 
--------------------------------------------------+--------+------+----------------
- value "50000" is out of range for type smallint |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- While we're here, check int2vector as well
 SELECT pg_input_is_valid(' 1 3  5 ', 'int2vector');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('1 asdf', 'int2vector');
-                    message                     | detail | hint | sql_error_code 
-------------------------------------------------+--------+------+----------------
- invalid input syntax for type smallint: "asdf" |        |      | 22P02
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('50000', 'int2vector');
-                     message                     | detail | hint | sql_error_code 
--------------------------------------------------+--------+------+----------------
- value "50000" is out of range for type smallint |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM INT2_TBL AS f(a, b);
-ERROR:  table "f" has 1 columns available but 2 columns specified
+   f1   
+--------
+      0
+   1234
+  -1234
+  32767
+ -32767
+(5 rows)
+
 SELECT * FROM (TABLE int2_tbl) AS s (a, b);
-ERROR:  table "s" has 1 columns available but 2 columns specified
+   f1   
+--------
+      0
+   1234
+  -1234
+  32767
+ -32767
+(5 rows)
+
 SELECT i.* FROM INT2_TBL i WHERE i.f1 <> int2 '0';
    f1   
 --------
@@ -200,7 +172,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i;
-ERROR:  smallint out of range
+   f1   |   x    
+--------+--------
+      0 |      0
+   1234 |   2468
+  -1234 |  -2468
+  32767 |  65534
+ -32767 | -65534
+(5 rows)
+
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i
 WHERE abs(f1) < 16384;
   f1   |   x   
@@ -211,28 +191,8 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int4 '2' AS x FROM INT2_TBL i;
-   f1   |   x    
---------+--------
-      0 |      0
-   1234 |   2468
-  -1234 |  -2468
-  32767 |  65534
- -32767 | -65534
-(5 rows)
-
+ERROR:  build PhysicalColumnarBinaryExpr failed: the data type of lhs and rhs must be the same [result_name=output_datum_0] [lhs=int32] [rhs=int16]
 SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i;
-ERROR:  smallint out of range
-SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i
-WHERE f1 < 32766;
-   f1   |   x    
---------+--------
-      0 |      2
-   1234 |   1236
-  -1234 |  -1232
- -32767 | -32765
-(4 rows)
-
-SELECT i.f1, i.f1 + int4 '2' AS x FROM INT2_TBL i;
    f1   |   x    
 --------+--------
       0 |      2
@@ -242,19 +202,19 @@
  -32767 | -32765
 (5 rows)
 
-SELECT i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i;
-ERROR:  smallint out of range
-SELECT i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i
-WHERE f1 > -32767;
-  f1   |   x   
--------+-------
-     0 |    -2
-  1234 |  1232
- -1234 | -1236
- 32767 | 32765
+SELECT i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i
+WHERE f1 < 32766;
+   f1   
+--------
+      0
+   1234
+  -1234
+ -32767
 (4 rows)
 
-SELECT i.f1, i.f1 - int4 '2' AS x FROM INT2_TBL i;
+SELECT i.f1, i.f1 + int4 '2' AS x FROM INT2_TBL i;
+ERROR:  build PhysicalColumnarBinaryExpr failed: the data type of lhs and rhs must be the same [result_name=output_datum_0] [lhs=int32] [rhs=int16]
+SELECT i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i;
    f1   |   x    
 --------+--------
       0 |     -2
@@ -264,6 +224,18 @@
  -32767 | -32769
 (5 rows)
 
+SELECT i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i
+WHERE f1 > -32767;
+  f1   
+-------
+     0
+  1234
+ -1234
+ 32767
+(4 rows)
+
+SELECT i.f1, i.f1 - int4 '2' AS x FROM INT2_TBL i;
+ERROR:  build PhysicalColumnarBinaryExpr failed: the data type of lhs and rhs must be the same [result_name=output_datum_0] [lhs=int32] [rhs=int16]
 SELECT i.f1, i.f1 / int2 '2' AS x FROM INT2_TBL i;
    f1   |   x    
 --------+--------
@@ -275,33 +247,25 @@
 (5 rows)
 
 SELECT i.f1, i.f1 / int4 '2' AS x FROM INT2_TBL i;
-   f1   |   x    
---------+--------
-      0 |      0
-   1234 |    617
-  -1234 |   -617
-  32767 |  16383
- -32767 | -16383
-(5 rows)
-
+ERROR:  build PhysicalColumnarBinaryExpr failed: the data type of lhs and rhs must be the same [result_name=output_datum_0] [lhs=int32] [rhs=int16]
 -- corner cases
 SELECT (-1::int2<<15)::text;
-  text  
---------
- -32768
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 SELECT ((-1::int2<<15)+1::int2)::text;
-  text  
---------
- -32767
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- check sane handling of INT16_MIN overflow cases
 SELECT (-32768)::int2 * (-1)::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+    32768
+(1 row)
+
 SELECT (-32768)::int2 / (-1)::int2;
-ERROR:  smallint out of range
+ ?column? 
+----------
+    32768
+(1 row)
+
 SELECT (-32768)::int2 % (-1)::int2;
  ?column? 
 ----------
@@ -317,17 +281,7 @@
              (0.5::float8),
              (1.5::float8),
              (2.5::float8)) t(x);
-  x   | int2_value 
-------+------------
- -2.5 |         -2
- -1.5 |         -2
- -0.5 |          0
-    0 |          0
-  0.5 |          0
-  1.5 |          2
-  2.5 |          2
-(7 rows)
-
+ERROR:  column "x" not exist
 -- check rounding when casting from numeric
 SELECT x, x::int2 AS int2_value
 FROM (VALUES (-2.5::numeric),
@@ -337,17 +291,7 @@
              (0.5::numeric),
              (1.5::numeric),
              (2.5::numeric)) t(x);
-  x   | int2_value 
-------+------------
- -2.5 |         -3
- -1.5 |         -2
- -0.5 |         -1
-  0.0 |          0
-  0.5 |          1
-  1.5 |          2
-  2.5 |          3
-(7 rows)
-
+ERROR:  column "x" not exist
 -- non-decimal literals
 SELECT int2 '0b100101';
  int2 
@@ -368,17 +312,11 @@
 (1 row)
 
 SELECT int2 '0b';
-ERROR:  invalid input syntax for type smallint: "0b"
-LINE 1: SELECT int2 '0b';
-                    ^
+ERROR:  invalid input syntax for type integer: "0b"
 SELECT int2 '0o';
-ERROR:  invalid input syntax for type smallint: "0o"
-LINE 1: SELECT int2 '0o';
-                    ^
+ERROR:  invalid input syntax for type integer: "0o"
 SELECT int2 '0x';
-ERROR:  invalid input syntax for type smallint: "0x"
-LINE 1: SELECT int2 '0x';
-                    ^
+ERROR:  invalid input syntax for type integer: "0x"
 -- cases near overflow
 SELECT int2 '0b111111111111111';
  int2  
@@ -387,9 +325,7 @@
 (1 row)
 
 SELECT int2 '0b1000000000000000';
-ERROR:  value "0b1000000000000000" is out of range for type smallint
-LINE 1: SELECT int2 '0b1000000000000000';
-                    ^
+ERROR:  value "0b1000000000000000" is out of range for type integer
 SELECT int2 '0o77777';
  int2  
 -------
@@ -397,9 +333,7 @@
 (1 row)
 
 SELECT int2 '0o100000';
-ERROR:  value "0o100000" is out of range for type smallint
-LINE 1: SELECT int2 '0o100000';
-                    ^
+ERROR:  value "0o100000" is out of range for type integer
 SELECT int2 '0x7FFF';
  int2  
 -------
@@ -407,9 +341,7 @@
 (1 row)
 
 SELECT int2 '0x8000';
-ERROR:  value "0x8000" is out of range for type smallint
-LINE 1: SELECT int2 '0x8000';
-                    ^
+ERROR:  value "0x8000" is out of range for type integer
 SELECT int2 '-0b1000000000000000';
   int2  
 --------
@@ -417,9 +349,7 @@
 (1 row)
 
 SELECT int2 '-0b1000000000000001';
-ERROR:  value "-0b1000000000000001" is out of range for type smallint
-LINE 1: SELECT int2 '-0b1000000000000001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0b1000000000000001"
 SELECT int2 '-0o100000';
   int2  
 --------
@@ -427,9 +357,7 @@
 (1 row)
 
 SELECT int2 '-0o100001';
-ERROR:  value "-0o100001" is out of range for type smallint
-LINE 1: SELECT int2 '-0o100001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0o100001"
 SELECT int2 '-0x8000';
   int2  
 --------
@@ -437,50 +365,22 @@
 (1 row)
 
 SELECT int2 '-0x8001';
-ERROR:  value "-0x8001" is out of range for type smallint
-LINE 1: SELECT int2 '-0x8001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0x8001"
 -- underscores
 SELECT int2 '1_000';
- int2 
-------
- 1000
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_000"
 SELECT int2 '1_2_3';
- int2 
-------
-  123
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_2_3"
 SELECT int2 '0xE_FF';
- int2 
-------
- 3839
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0xE_FF"
 SELECT int2 '0o2_73';
- int2 
-------
-  187
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0o2_73"
 SELECT int2 '0b_10_0101';
- int2 
-------
-   37
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0b_10_0101"
 -- error cases
 SELECT int2 '_100';
-ERROR:  invalid input syntax for type smallint: "_100"
-LINE 1: SELECT int2 '_100';
-                    ^
+ERROR:  invalid input syntax for type integer: "_100"
 SELECT int2 '100_';
-ERROR:  invalid input syntax for type smallint: "100_"
-LINE 1: SELECT int2 '100_';
-                    ^
+ERROR:  invalid input syntax for type integer: "100_"
 SELECT int2 '10__000';
-ERROR:  invalid input syntax for type smallint: "10__000"
-LINE 1: SELECT int2 '10__000';
-                    ^
+ERROR:  invalid input syntax for type integer: "10__000"
diff -U3 /home/longqimin/pg_regress_input/expected/int4.out /home/longqimin/pg_regress_input/results/int4.out
--- /home/longqimin/pg_regress_input/expected/int4.out	2024-03-08 10:37:26.410799760 +0800
+++ /home/longqimin/pg_regress_input/results/int4.out	2024-03-08 13:58:43.061482569 +0800
@@ -5,36 +5,20 @@
 -- Here we just try to insert bad values.
 INSERT INTO INT4_TBL(f1) VALUES ('34.5');
 ERROR:  invalid input syntax for type integer: "34.5"
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('34.5');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('1000000000000');
 ERROR:  value "1000000000000" is out of range for type integer
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('1000000000000');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('asdf');
 ERROR:  invalid input syntax for type integer: "asdf"
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('asdf');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('     ');
 ERROR:  invalid input syntax for type integer: "     "
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('     ');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('   asdf   ');
 ERROR:  invalid input syntax for type integer: "   asdf   "
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('   asdf   ');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('- 1234');
 ERROR:  invalid input syntax for type integer: "- 1234"
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('- 1234');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('123       5');
 ERROR:  invalid input syntax for type integer: "123       5"
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('123       5');
-                                         ^
 INSERT INTO INT4_TBL(f1) VALUES ('');
 ERROR:  invalid input syntax for type integer: ""
-LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('');
-                                         ^
 SELECT * FROM INT4_TBL;
      f1      
 -------------
@@ -47,29 +31,13 @@
 
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34', 'int4');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('asdf', 'int4');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('1000000000000', 'int4');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('1000000000000', 'int4');
-                        message                         | detail | hint | sql_error_code 
---------------------------------------------------------+--------+------+----------------
- value "1000000000000" is out of range for type integer |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT i.* FROM INT4_TBL i WHERE i.f1 <> int2 '0';
      f1      
 -------------
@@ -177,7 +145,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |           0
+      123456 |      246912
+     -123456 |     -246912
+  2147483647 |  4294967294
+ -2147483647 | -4294967294
+(5 rows)
+
 SELECT i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i
 WHERE abs(f1) < 1073741824;
    f1    |    x    
@@ -188,7 +164,15 @@
 (3 rows)
 
 SELECT i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |           0
+      123456 |      246912
+     -123456 |     -246912
+  2147483647 |  4294967294
+ -2147483647 | -4294967294
+(5 rows)
+
 SELECT i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i
 WHERE abs(f1) < 1073741824;
    f1    |    x    
@@ -199,51 +183,83 @@
 (3 rows)
 
 SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
-SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i
-WHERE f1 < 2147483646;
      f1      |      x      
 -------------+-------------
            0 |           2
       123456 |      123458
      -123456 |     -123454
+  2147483647 |  2147483649
  -2147483647 | -2147483645
+(5 rows)
+
+SELECT i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i
+WHERE f1 < 2147483646;
+     f1      
+-------------
+           0
+      123456
+     -123456
+ -2147483647
 (4 rows)
 
 SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
-SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i
-WHERE f1 < 2147483646;
      f1      |      x      
 -------------+-------------
            0 |           2
       123456 |      123458
      -123456 |     -123454
+  2147483647 |  2147483649
  -2147483647 | -2147483645
+(5 rows)
+
+SELECT i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i
+WHERE f1 < 2147483646;
+     f1      
+-------------
+           0
+      123456
+     -123456
+ -2147483647
 (4 rows)
 
 SELECT i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |          -2
+      123456 |      123454
+     -123456 |     -123458
+  2147483647 |  2147483645
+ -2147483647 | -2147483649
+(5 rows)
+
 SELECT i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i
 WHERE f1 > -2147483647;
-     f1     |     x      
-------------+------------
-          0 |         -2
-     123456 |     123454
-    -123456 |    -123458
- 2147483647 | 2147483645
+     f1     
+------------
+          0
+     123456
+    -123456
+ 2147483647
 (4 rows)
 
 SELECT i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i;
-ERROR:  integer out of range
+     f1      |      x      
+-------------+-------------
+           0 |          -2
+      123456 |      123454
+     -123456 |     -123458
+  2147483647 |  2147483645
+ -2147483647 | -2147483649
+(5 rows)
+
 SELECT i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i
 WHERE f1 > -2147483647;
-     f1     |     x      
-------------+------------
-          0 |         -2
-     123456 |     123454
-    -123456 |    -123458
- 2147483647 | 2147483645
+     f1     
+------------
+          0
+     123456
+    -123456
+ 2147483647
 (4 rows)
 
 SELECT i.f1, i.f1 / int2 '2' AS x FROM INT4_TBL i;
@@ -338,22 +354,22 @@
 
 -- corner case
 SELECT (-1::int4<<31)::text;
-    text     
--------------
- -2147483648
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 SELECT ((-1::int4<<31)+1)::text;
-    text     
--------------
- -2147483647
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- check sane handling of INT_MIN overflow cases
 SELECT (-2147483648)::int4 * (-1)::int4;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 / (-1)::int4;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 % (-1)::int4;
  ?column? 
 ----------
@@ -361,9 +377,17 @@
 (1 row)
 
 SELECT (-2147483648)::int4 * (-1)::int2;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 / (-1)::int2;
-ERROR:  integer out of range
+  ?column?  
+------------
+ 2147483648
+(1 row)
+
 SELECT (-2147483648)::int4 % (-1)::int2;
  ?column? 
 ----------
@@ -379,17 +403,7 @@
              (0.5::float8),
              (1.5::float8),
              (2.5::float8)) t(x);
-  x   | int4_value 
-------+------------
- -2.5 |         -2
- -1.5 |         -2
- -0.5 |          0
-    0 |          0
-  0.5 |          0
-  1.5 |          2
-  2.5 |          2
-(7 rows)
-
+ERROR:  column "x" not exist
 -- check rounding when casting from numeric
 SELECT x, x::int4 AS int4_value
 FROM (VALUES (-2.5::numeric),
@@ -399,17 +413,7 @@
              (0.5::numeric),
              (1.5::numeric),
              (2.5::numeric)) t(x);
-  x   | int4_value 
-------+------------
- -2.5 |         -3
- -1.5 |         -2
- -0.5 |         -1
-  0.0 |          0
-  0.5 |          1
-  1.5 |          2
-  2.5 |          3
-(7 rows)
-
+ERROR:  column "x" not exist
 -- test gcd()
 SELECT a, b, gcd(a, b), gcd(a, -b), gcd(b, a), gcd(-b, a)
 FROM (VALUES (0::int4, 0::int4),
@@ -419,21 +423,11 @@
              ((-2147483648)::int4, 1::int4),
              ((-2147483648)::int4, 2147483647::int4),
              ((-2147483648)::int4, 1073741824::int4)) AS v(a, b);
-      a      |     b      |    gcd     |    gcd     |    gcd     |    gcd     
--------------+------------+------------+------------+------------+------------
-           0 |          0 |          0 |          0 |          0 |          0
-           0 |    6410818 |    6410818 |    6410818 |    6410818 |    6410818
-    61866666 |    6410818 |       1466 |       1466 |       1466 |       1466
-   -61866666 |    6410818 |       1466 |       1466 |       1466 |       1466
- -2147483648 |          1 |          1 |          1 |          1 |          1
- -2147483648 | 2147483647 |          1 |          1 |          1 |          1
- -2147483648 | 1073741824 | 1073741824 | 1073741824 | 1073741824 | 1073741824
-(7 rows)
-
+ERROR:  function gcd does not exist
 SELECT gcd((-2147483648)::int4, 0::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function gcd does not exist
 SELECT gcd((-2147483648)::int4, (-2147483648)::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function gcd does not exist
 -- test lcm()
 SELECT a, b, lcm(a, b), lcm(a, -b), lcm(b, a), lcm(-b, a)
 FROM (VALUES (0::int4, 0::int4),
@@ -442,20 +436,11 @@
              (330::int4, 462::int4),
              (-330::int4, 462::int4),
              ((-2147483648)::int4, 0::int4)) AS v(a, b);
-      a      |  b  | lcm  | lcm  | lcm  | lcm  
--------------+-----+------+------+------+------
-           0 |   0 |    0 |    0 |    0 |    0
-           0 |  42 |    0 |    0 |    0 |    0
-          42 |  42 |   42 |   42 |   42 |   42
-         330 | 462 | 2310 | 2310 | 2310 | 2310
-        -330 | 462 | 2310 | 2310 | 2310 | 2310
- -2147483648 |   0 |    0 |    0 |    0 |    0
-(6 rows)
-
+ERROR:  function lcm does not exist
 SELECT lcm((-2147483648)::int4, 1::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function lcm does not exist
 SELECT lcm(2147483647::int4, 2147483646::int4); -- overflow
-ERROR:  integer out of range
+ERROR:  function lcm does not exist
 -- non-decimal literals
 SELECT int4 '0b100101';
  int4 
@@ -477,16 +462,10 @@
 
 SELECT int4 '0b';
 ERROR:  invalid input syntax for type integer: "0b"
-LINE 1: SELECT int4 '0b';
-                    ^
 SELECT int4 '0o';
 ERROR:  invalid input syntax for type integer: "0o"
-LINE 1: SELECT int4 '0o';
-                    ^
 SELECT int4 '0x';
 ERROR:  invalid input syntax for type integer: "0x"
-LINE 1: SELECT int4 '0x';
-                    ^
 -- cases near overflow
 SELECT int4 '0b1111111111111111111111111111111';
     int4    
@@ -496,8 +475,6 @@
 
 SELECT int4 '0b10000000000000000000000000000000';
 ERROR:  value "0b10000000000000000000000000000000" is out of range for type integer
-LINE 1: SELECT int4 '0b10000000000000000000000000000000';
-                    ^
 SELECT int4 '0o17777777777';
     int4    
 ------------
@@ -506,8 +483,6 @@
 
 SELECT int4 '0o20000000000';
 ERROR:  value "0o20000000000" is out of range for type integer
-LINE 1: SELECT int4 '0o20000000000';
-                    ^
 SELECT int4 '0x7FFFFFFF';
     int4    
 ------------
@@ -516,8 +491,6 @@
 
 SELECT int4 '0x80000000';
 ERROR:  value "0x80000000" is out of range for type integer
-LINE 1: SELECT int4 '0x80000000';
-                    ^
 SELECT int4 '-0b10000000000000000000000000000000';
     int4     
 -------------
@@ -525,9 +498,7 @@
 (1 row)
 
 SELECT int4 '-0b10000000000000000000000000000001';
-ERROR:  value "-0b10000000000000000000000000000001" is out of range for type integer
-LINE 1: SELECT int4 '-0b10000000000000000000000000000001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0b10000000000000000000000000000001"
 SELECT int4 '-0o20000000000';
     int4     
 -------------
@@ -535,9 +506,7 @@
 (1 row)
 
 SELECT int4 '-0o20000000001';
-ERROR:  value "-0o20000000001" is out of range for type integer
-LINE 1: SELECT int4 '-0o20000000001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0o20000000001"
 SELECT int4 '-0x80000000';
     int4     
 -------------
@@ -545,50 +514,22 @@
 (1 row)
 
 SELECT int4 '-0x80000001';
-ERROR:  value "-0x80000001" is out of range for type integer
-LINE 1: SELECT int4 '-0x80000001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0x80000001"
 -- underscores
 SELECT int4 '1_000_000';
-  int4   
----------
- 1000000
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_000_000"
 SELECT int4 '1_2_3';
- int4 
-------
-  123
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_2_3"
 SELECT int4 '0x1EEE_FFFF';
-   int4    
------------
- 518979583
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0x1EEE_FFFF"
 SELECT int4 '0o2_73';
- int4 
-------
-  187
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0o2_73"
 SELECT int4 '0b_10_0101';
- int4 
-------
-   37
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0b_10_0101"
 -- error cases
 SELECT int4 '_100';
 ERROR:  invalid input syntax for type integer: "_100"
-LINE 1: SELECT int4 '_100';
-                    ^
 SELECT int4 '100_';
 ERROR:  invalid input syntax for type integer: "100_"
-LINE 1: SELECT int4 '100_';
-                    ^
 SELECT int4 '100__000';
 ERROR:  invalid input syntax for type integer: "100__000"
-LINE 1: SELECT int4 '100__000';
-                    ^
diff -U3 /home/longqimin/pg_regress_input/expected/int8.out /home/longqimin/pg_regress_input/results/int8.out
--- /home/longqimin/pg_regress_input/expected/int8.out	2024-03-08 10:37:51.242801636 +0800
+++ /home/longqimin/pg_regress_input/results/int8.out	2024-03-08 13:58:44.294482448 +0800
@@ -5,33 +5,19 @@
 -- int8_tbl was already created and filled in test_setup.sql.
 -- Here we just try to insert bad values.
 INSERT INTO INT8_TBL(q1) VALUES ('      ');
-ERROR:  invalid input syntax for type bigint: "      "
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('      ');
-                                         ^
+ERROR:  invalid input syntax for type integer: "      "
 INSERT INTO INT8_TBL(q1) VALUES ('xxx');
-ERROR:  invalid input syntax for type bigint: "xxx"
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('xxx');
-                                         ^
+ERROR:  invalid input syntax for type integer: "xxx"
 INSERT INTO INT8_TBL(q1) VALUES ('3908203590239580293850293850329485');
-ERROR:  value "3908203590239580293850293850329485" is out of range for type bigint
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('39082035902395802938502938...
-                                         ^
+ERROR:  value "3908203590239580293850293850329485" is out of range for type integer
 INSERT INTO INT8_TBL(q1) VALUES ('-1204982019841029840928340329840934');
-ERROR:  value "-1204982019841029840928340329840934" is out of range for type bigint
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('-1204982019841029840928340...
-                                         ^
+ERROR:  value "-1204982019841029840928340329840934" is out of range for type integer
 INSERT INTO INT8_TBL(q1) VALUES ('- 123');
-ERROR:  invalid input syntax for type bigint: "- 123"
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('- 123');
-                                         ^
+ERROR:  invalid input syntax for type integer: "- 123"
 INSERT INTO INT8_TBL(q1) VALUES ('  345     5');
-ERROR:  invalid input syntax for type bigint: "  345     5"
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('  345     5');
-                                         ^
+ERROR:  invalid input syntax for type integer: "  345     5"
 INSERT INTO INT8_TBL(q1) VALUES ('');
-ERROR:  invalid input syntax for type bigint: ""
-LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('');
-                                         ^
+ERROR:  invalid input syntax for type integer: ""
 SELECT * FROM INT8_TBL;
         q1        |        q2         
 ------------------+-------------------
@@ -44,29 +30,13 @@
 
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34', 'int8');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('asdf', 'int8');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('10000000000000000000', 'int8');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('10000000000000000000', 'int8');
-                           message                            | detail | hint | sql_error_code 
---------------------------------------------------------------+--------+------+----------------
- value "10000000000000000000" is out of range for type bigint |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- int8/int8 cmp
 SELECT * FROM INT8_TBL WHERE q2 = 4567890123456789;
         q1        |        q2        
@@ -328,7 +298,15 @@
 (5 rows)
 
 SELECT q1, q2, q1 * q2 AS multiply FROM INT8_TBL;
-ERROR:  bigint out of range
+        q1        |        q2         |       multiply       
+------------------+-------------------+----------------------
+              123 |               456 |                56088
+              123 |  4567890123456789 |   561850485185185047
+ 4567890123456789 |               123 |   561850485185185047
+ 4567890123456789 |  4567890123456789 |  4868582358072306617
+ 4567890123456789 | -4567890123456789 | -4868582358072306617
+(5 rows)
+
 SELECT q1, q2, q1 * q2 AS multiply FROM INT8_TBL
  WHERE q1 < 1000 or (q2 > 0 and q2 < 1000);
         q1        |        q2        |      multiply      
@@ -349,25 +327,9 @@
 (5 rows)
 
 SELECT q1, float8(q1) FROM INT8_TBL;
-        q1        |        float8         
-------------------+-----------------------
-              123 |                   123
-              123 |                   123
- 4567890123456789 | 4.567890123456789e+15
- 4567890123456789 | 4.567890123456789e+15
- 4567890123456789 | 4.567890123456789e+15
-(5 rows)
-
+ERROR:  function float8 does not exist
 SELECT q2, float8(q2) FROM INT8_TBL;
-        q2         |         float8         
--------------------+------------------------
-               456 |                    456
-  4567890123456789 |  4.567890123456789e+15
-               123 |                    123
-  4567890123456789 |  4.567890123456789e+15
- -4567890123456789 | -4.567890123456789e+15
-(5 rows)
-
+ERROR:  function float8 does not exist
 SELECT 37 + q1 AS plus4 FROM INT8_TBL;
       plus4       
 ------------------
@@ -478,253 +440,101 @@
 --
 SELECT to_char(q1, '9G999G999G999G999G999'), to_char(q2, '9,999,999,999,999,999')
 	FROM INT8_TBL;
-        to_char         |        to_char         
-------------------------+------------------------
-                    123 |                    456
-                    123 |  4,567,890,123,456,789
-  4,567,890,123,456,789 |                    123
-  4,567,890,123,456,789 |  4,567,890,123,456,789
-  4,567,890,123,456,789 | -4,567,890,123,456,789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q1, '9G999G999G999G999G999D999G999'), to_char(q2, '9,999,999,999,999,999.999,999')
 	FROM INT8_TBL;
-            to_char             |            to_char             
---------------------------------+--------------------------------
-                    123.000,000 |                    456.000,000
-                    123.000,000 |  4,567,890,123,456,789.000,000
-  4,567,890,123,456,789.000,000 |                    123.000,000
-  4,567,890,123,456,789.000,000 |  4,567,890,123,456,789.000,000
-  4,567,890,123,456,789.000,000 | -4,567,890,123,456,789.000,000
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char( (q1 * -1), '9999999999999999PR'), to_char( (q2 * -1), '9999999999999999.999PR')
 	FROM INT8_TBL;
-      to_char       |        to_char         
---------------------+------------------------
-              <123> |              <456.000>
-              <123> | <4567890123456789.000>
- <4567890123456789> |              <123.000>
- <4567890123456789> | <4567890123456789.000>
- <4567890123456789> |  4567890123456789.000 
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char( (q1 * -1), '9999999999999999S'), to_char( (q2 * -1), 'S9999999999999999')
 	FROM INT8_TBL;
-      to_char      |      to_char      
--------------------+-------------------
-              123- |              -456
-              123- | -4567890123456789
- 4567890123456789- |              -123
- 4567890123456789- | -4567890123456789
- 4567890123456789- | +4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'MI9999999999999999')     FROM INT8_TBL;
-      to_char      
--------------------
-               456
-  4567890123456789
-               123
-  4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FMS9999999999999999')    FROM INT8_TBL;
-      to_char      
--------------------
- +456
- +4567890123456789
- +123
- +4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM9999999999999999THPR') FROM INT8_TBL;
-      to_char       
---------------------
- 456TH
- 4567890123456789TH
- 123RD
- 4567890123456789TH
- <4567890123456789>
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'SG9999999999999999th')   FROM INT8_TBL;
-       to_char       
----------------------
- +             456th
- +4567890123456789th
- +             123rd
- +4567890123456789th
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, '0999999999999999')       FROM INT8_TBL;
-      to_char      
--------------------
-  0000000000000456
-  4567890123456789
-  0000000000000123
-  4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'S0999999999999999')      FROM INT8_TBL;
-      to_char      
--------------------
- +0000000000000456
- +4567890123456789
- +0000000000000123
- +4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM0999999999999999')     FROM INT8_TBL;
-      to_char      
--------------------
- 0000000000000456
- 4567890123456789
- 0000000000000123
- 4567890123456789
- -4567890123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM9999999999999999.000') FROM INT8_TBL;
-        to_char        
------------------------
- 456.000
- 4567890123456789.000
- 123.000
- 4567890123456789.000
- -4567890123456789.000
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'L9999999999999999.000')  FROM INT8_TBL;
-        to_char         
-------------------------
-                456.000
-   4567890123456789.000
-                123.000
-   4567890123456789.000
-  -4567890123456789.000
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'FM9999999999999999.999') FROM INT8_TBL;
-      to_char       
---------------------
- 456.
- 4567890123456789.
- 123.
- 4567890123456789.
- -4567890123456789.
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, 'S 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 . 9 9 9') FROM INT8_TBL;
-                  to_char                  
--------------------------------------------
-                            +4 5 6 . 0 0 0
-  +4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 . 0 0 0
-                            +1 2 3 . 0 0 0
-  +4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 . 0 0 0
-  -4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 . 0 0 0
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, E'99999 "text" 9999 "9999" 999 "\\"text between quote marks\\"" 9999') FROM INT8_TBL;
-                          to_char                          
------------------------------------------------------------
-       text      9999     "text between quote marks"   456
-  45678 text 9012 9999 345 "text between quote marks" 6789
-       text      9999     "text between quote marks"   123
-  45678 text 9012 9999 345 "text between quote marks" 6789
- -45678 text 9012 9999 345 "text between quote marks" 6789
-(5 rows)
-
+ERROR:  function to_char does not exist
 SELECT to_char(q2, '999999SG9999999999')     FROM INT8_TBL;
-      to_char      
--------------------
-       +       456
- 456789+0123456789
-       +       123
- 456789+0123456789
- 456789-0123456789
-(5 rows)
-
+ERROR:  function to_char does not exist
 -- check min/max values and overflow behavior
 select '-9223372036854775808'::int8;
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  value "-9223372036854775808" is out of range for type integer
 select '-9223372036854775809'::int8;
-ERROR:  value "-9223372036854775809" is out of range for type bigint
-LINE 1: select '-9223372036854775809'::int8;
-               ^
+ERROR:  value "-9223372036854775809" is out of range for type integer
 select '9223372036854775807'::int8;
-        int8         
----------------------
- 9223372036854775807
-(1 row)
-
+ERROR:  value "9223372036854775807" is out of range for type integer
 select '9223372036854775808'::int8;
-ERROR:  value "9223372036854775808" is out of range for type bigint
-LINE 1: select '9223372036854775808'::int8;
-               ^
+ERROR:  value "9223372036854775808" is out of range for type integer
 select -('-9223372036854775807'::int8);
-      ?column?       
----------------------
- 9223372036854775807
-(1 row)
-
+ERROR:  value "-9223372036854775807" is out of range for type integer
 select -('-9223372036854775808'::int8);
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 select 0::int8 - '-9223372036854775808'::int8;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 select '9223372036854775800'::int8 + '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-9223372036854775800'::int8 + '-9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 - '-9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-9223372036854775800'::int8 - '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 * '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 / '0'::int8;
-ERROR:  division by zero
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 % '0'::int8;
-ERROR:  division by zero
+ERROR:  value "9223372036854775800" is out of range for type integer
 select abs('-9223372036854775808'::int8);
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 select '9223372036854775800'::int8 + '100'::int4;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-9223372036854775800'::int8 - '100'::int4;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 * '100'::int4;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '100'::int4 + '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-100'::int4 - '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '100'::int4 * '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 + '100'::int2;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-9223372036854775800'::int8 - '100'::int2;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775800" is out of range for type integer
 select '9223372036854775800'::int8 * '100'::int2;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-9223372036854775808'::int8 / '0'::int2;
-ERROR:  division by zero
+ERROR:  value "-9223372036854775808" is out of range for type integer
 select '100'::int2 + '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '-100'::int2 - '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '100'::int2 * '9223372036854775800'::int8;
-ERROR:  bigint out of range
+ERROR:  value "9223372036854775800" is out of range for type integer
 select '100'::int2 / '0'::int8;
-ERROR:  division by zero
+ERROR:  div zero [func=func_9060753810053611181]
 SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 = 456;
  q1  
 -----
@@ -732,7 +542,14 @@
 (1 row)
 
 SELECT CAST(q1 AS int4) FROM int8_tbl WHERE q2 <> 456;
-ERROR:  integer out of range
+     q1     
+------------
+        123
+ -869367531
+ -869367531
+ -869367531
+(4 rows)
+
 SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 = 456;
  q1  
 -----
@@ -740,134 +557,74 @@
 (1 row)
 
 SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456;
-ERROR:  smallint out of range
+   q1   
+--------
+    123
+ -32491
+ -32491
+ -32491
+(4 rows)
+
 SELECT CAST('42'::int2 AS int8), CAST('-37'::int2 AS int8);
  int8 | int8 
 ------+------
-   42 |  -37
+ 42   | -37
 (1 row)
 
 SELECT CAST(q1 AS float4), CAST(q2 AS float8) FROM INT8_TBL;
-     q1      |           q2           
--------------+------------------------
-         123 |                    456
-         123 |  4.567890123456789e+15
- 4.56789e+15 |                    123
- 4.56789e+15 |  4.567890123456789e+15
- 4.56789e+15 | -4.567890123456789e+15
+        q1        |        q2         
+------------------+-------------------
+              123 |               456
+              123 |  4567890123456789
+ 4567890000000000 |               123
+ 4567890000000000 |  4567890123456789
+ 4567890000000000 | -4567890123456789
 (5 rows)
 
 SELECT CAST('36854775807.0'::float4 AS int8);
-    int8     
--------------
- 36854775808
-(1 row)
-
+ERROR:  signed char out of range
 SELECT CAST('922337203685477580700.0'::float8 AS int8);
-ERROR:  bigint out of range
+ERROR:  signed char out of range
 SELECT CAST(q1 AS oid) FROM INT8_TBL;
-ERROR:  OID out of range
+ERROR:  not implemented type_cast case [to=oid]
 SELECT oid::int8 FROM pg_class WHERE relname = 'pg_class';
- oid  
-------
- 1259
-(1 row)
-
+ERROR:  can't find table : public.pg_class
 -- bit operations
 SELECT q1, q2, q1 & q2 AS "and", q1 | q2 AS "or", q1 # q2 AS "xor", ~q1 AS "not" FROM INT8_TBL;
-        q1        |        q2         |       and        |        or        |       xor        |        not        
-------------------+-------------------+------------------+------------------+------------------+-------------------
-              123 |               456 |               72 |              507 |              435 |              -124
-              123 |  4567890123456789 |               17 | 4567890123456895 | 4567890123456878 |              -124
- 4567890123456789 |               123 |               17 | 4567890123456895 | 4567890123456878 | -4567890123456790
- 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |                0 | -4567890123456790
- 4567890123456789 | -4567890123456789 |                1 |               -1 |               -2 | -4567890123456790
-(5 rows)
-
+ERROR:  binary_optr only support binary optr = [optr_str=&]
 SELECT q1, q1 << 2 AS "shl", q1 >> 3 AS "shr" FROM INT8_TBL;
-        q1        |        shl        |       shr       
-------------------+-------------------+-----------------
-              123 |               492 |              15
-              123 |               492 |              15
- 4567890123456789 | 18271560493827156 | 570986265432098
- 4567890123456789 | 18271560493827156 | 570986265432098
- 4567890123456789 | 18271560493827156 | 570986265432098
-(5 rows)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- generate_series
 SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8);
- generate_series  
-------------------
- 4567890123456789
- 4567890123456790
- 4567890123456791
- 4567890123456792
- 4567890123456793
- 4567890123456794
- 4567890123456795
- 4567890123456796
- 4567890123456797
- 4567890123456798
- 4567890123456799
-(11 rows)
-
+ERROR:  function generate_series does not exist
 SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8, 0);
-ERROR:  step size cannot equal zero
+ERROR:  function generate_series does not exist
 SELECT * FROM generate_series('+4567890123456789'::int8, '+4567890123456799'::int8, 2);
- generate_series  
-------------------
- 4567890123456789
- 4567890123456791
- 4567890123456793
- 4567890123456795
- 4567890123456797
- 4567890123456799
-(6 rows)
-
+ERROR:  function generate_series does not exist
 -- corner case
 SELECT (-1::int8<<63)::text;
-         text         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 SELECT ((-1::int8<<63)+1)::text;
-         text         
-----------------------
- -9223372036854775807
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=<<]
 -- check sane handling of INT64_MIN overflow cases
 SELECT (-9223372036854775808)::int8 * (-1)::int8;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 / (-1)::int8;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 % (-1)::int8;
- ?column? 
-----------
-        0
-(1 row)
-
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 * (-1)::int4;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 / (-1)::int4;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 % (-1)::int4;
- ?column? 
-----------
-        0
-(1 row)
-
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 * (-1)::int2;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 / (-1)::int2;
-ERROR:  bigint out of range
+ERROR:  value "-9223372036854775808" is out of range for type integer
 SELECT (-9223372036854775808)::int8 % (-1)::int2;
- ?column? 
-----------
-        0
-(1 row)
-
+ERROR:  value "-9223372036854775808" is out of range for type integer
 -- check rounding when casting from float
 SELECT x, x::int8 AS int8_value
 FROM (VALUES (-2.5::float8),
@@ -877,17 +634,7 @@
              (0.5::float8),
              (1.5::float8),
              (2.5::float8)) t(x);
-  x   | int8_value 
-------+------------
- -2.5 |         -2
- -1.5 |         -2
- -0.5 |          0
-    0 |          0
-  0.5 |          0
-  1.5 |          2
-  2.5 |          2
-(7 rows)
-
+ERROR:  column "x" not exist
 -- check rounding when casting from numeric
 SELECT x, x::int8 AS int8_value
 FROM (VALUES (-2.5::numeric),
@@ -897,17 +644,7 @@
              (0.5::numeric),
              (1.5::numeric),
              (2.5::numeric)) t(x);
-  x   | int8_value 
-------+------------
- -2.5 |         -3
- -1.5 |         -2
- -0.5 |         -1
-  0.0 |          0
-  0.5 |          1
-  1.5 |          2
-  2.5 |          3
-(7 rows)
-
+ERROR:  column "x" not exist
 -- test gcd()
 SELECT a, b, gcd(a, b), gcd(a, -b), gcd(b, a), gcd(-b, a)
 FROM (VALUES (0::int8, 0::int8),
@@ -917,21 +654,11 @@
              ((-9223372036854775808)::int8, 1::int8),
              ((-9223372036854775808)::int8, 9223372036854775807::int8),
              ((-9223372036854775808)::int8, 4611686018427387904::int8)) AS v(a, b);
-          a           |          b          |         gcd         |         gcd         |         gcd         |         gcd         
-----------------------+---------------------+---------------------+---------------------+---------------------+---------------------
-                    0 |                   0 |                   0 |                   0 |                   0 |                   0
-                    0 |         29893644334 |         29893644334 |         29893644334 |         29893644334 |         29893644334
-         288484263558 |         29893644334 |             6835958 |             6835958 |             6835958 |             6835958
-        -288484263558 |         29893644334 |             6835958 |             6835958 |             6835958 |             6835958
- -9223372036854775808 |                   1 |                   1 |                   1 |                   1 |                   1
- -9223372036854775808 | 9223372036854775807 |                   1 |                   1 |                   1 |                   1
- -9223372036854775808 | 4611686018427387904 | 4611686018427387904 | 4611686018427387904 | 4611686018427387904 | 4611686018427387904
-(7 rows)
-
+ERROR:  function gcd does not exist
 SELECT gcd((-9223372036854775808)::int8, 0::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function gcd does not exist
 SELECT gcd((-9223372036854775808)::int8, (-9223372036854775808)::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function gcd does not exist
 -- test lcm()
 SELECT a, b, lcm(a, b), lcm(a, -b), lcm(b, a), lcm(-b, a)
 FROM (VALUES (0::int8, 0::int8),
@@ -940,153 +667,68 @@
              (288484263558::int8, 29893644334::int8),
              (-288484263558::int8, 29893644334::int8),
              ((-9223372036854775808)::int8, 0::int8)) AS v(a, b);
-          a           |      b      |       lcm        |       lcm        |       lcm        |       lcm        
-----------------------+-------------+------------------+------------------+------------------+------------------
-                    0 |           0 |                0 |                0 |                0 |                0
-                    0 | 29893644334 |                0 |                0 |                0 |                0
-          29893644334 | 29893644334 |      29893644334 |      29893644334 |      29893644334 |      29893644334
-         288484263558 | 29893644334 | 1261541684539134 | 1261541684539134 | 1261541684539134 | 1261541684539134
-        -288484263558 | 29893644334 | 1261541684539134 | 1261541684539134 | 1261541684539134 | 1261541684539134
- -9223372036854775808 |           0 |                0 |                0 |                0 |                0
-(6 rows)
-
+ERROR:  function lcm does not exist
 SELECT lcm((-9223372036854775808)::int8, 1::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function lcm does not exist
 SELECT lcm(9223372036854775807::int8, 9223372036854775806::int8); -- overflow
-ERROR:  bigint out of range
+ERROR:  function lcm does not exist
 -- non-decimal literals
 SELECT int8 '0b100101';
  int8 
 ------
-   37
+ 37
 (1 row)
 
 SELECT int8 '0o273';
- int8 
-------
-  187
-(1 row)
-
+ERROR:  value "0o273" is out of range for type integer
 SELECT int8 '0x42F';
- int8 
-------
- 1071
-(1 row)
-
+ERROR:  value "0x42F" is out of range for type integer
 SELECT int8 '0b';
-ERROR:  invalid input syntax for type bigint: "0b"
-LINE 1: SELECT int8 '0b';
-                    ^
+ERROR:  invalid input syntax for type integer: "0b"
 SELECT int8 '0o';
-ERROR:  invalid input syntax for type bigint: "0o"
-LINE 1: SELECT int8 '0o';
-                    ^
+ERROR:  invalid input syntax for type integer: "0o"
 SELECT int8 '0x';
-ERROR:  invalid input syntax for type bigint: "0x"
-LINE 1: SELECT int8 '0x';
-                    ^
+ERROR:  invalid input syntax for type integer: "0x"
 -- cases near overflow
 SELECT int8 '0b111111111111111111111111111111111111111111111111111111111111111';
-        int8         
----------------------
- 9223372036854775807
-(1 row)
-
+ERROR:  value "0b111111111111111111111111111111111111111111111111111111111111111" is out of range for type integer
 SELECT int8 '0b1000000000000000000000000000000000000000000000000000000000000000';
-ERROR:  value "0b1000000000000000000000000000000000000000000000000000000000000000" is out of range for type bigint
-LINE 1: SELECT int8 '0b100000000000000000000000000000000000000000000...
-                    ^
+ERROR:  value "0b1000000000000000000000000000000000000000000000000000000000000000" is out of range for type integer
 SELECT int8 '0o777777777777777777777';
-        int8         
----------------------
- 9223372036854775807
-(1 row)
-
+ERROR:  value "0o777777777777777777777" is out of range for type integer
 SELECT int8 '0o1000000000000000000000';
-ERROR:  value "0o1000000000000000000000" is out of range for type bigint
-LINE 1: SELECT int8 '0o1000000000000000000000';
-                    ^
+ERROR:  value "0o1000000000000000000000" is out of range for type integer
 SELECT int8 '0x7FFFFFFFFFFFFFFF';
-        int8         
----------------------
- 9223372036854775807
-(1 row)
-
+ERROR:  value "0x7FFFFFFFFFFFFFFF" is out of range for type integer
 SELECT int8 '0x8000000000000000';
-ERROR:  value "0x8000000000000000" is out of range for type bigint
-LINE 1: SELECT int8 '0x8000000000000000';
-                    ^
+ERROR:  value "0x8000000000000000" is out of range for type integer
 SELECT int8 '-0b1000000000000000000000000000000000000000000000000000000000000000';
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "-0b1000000000000000000000000000000000000000000000000000000000000000"
 SELECT int8 '-0b1000000000000000000000000000000000000000000000000000000000000001';
-ERROR:  value "-0b1000000000000000000000000000000000000000000000000000000000000001" is out of range for type bigint
-LINE 1: SELECT int8 '-0b10000000000000000000000000000000000000000000...
-                    ^
+ERROR:  invalid input syntax for type integer: "-0b1000000000000000000000000000000000000000000000000000000000000001"
 SELECT int8 '-0o1000000000000000000000';
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "-0o1000000000000000000000"
 SELECT int8 '-0o1000000000000000000001';
-ERROR:  value "-0o1000000000000000000001" is out of range for type bigint
-LINE 1: SELECT int8 '-0o1000000000000000000001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0o1000000000000000000001"
 SELECT int8 '-0x8000000000000000';
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "-0x8000000000000000"
 SELECT int8 '-0x8000000000000001';
-ERROR:  value "-0x8000000000000001" is out of range for type bigint
-LINE 1: SELECT int8 '-0x8000000000000001';
-                    ^
+ERROR:  invalid input syntax for type integer: "-0x8000000000000001"
 -- underscores
 SELECT int8 '1_000_000';
-  int8   
----------
- 1000000
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_000_000"
 SELECT int8 '1_2_3';
- int8 
-------
-  123
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "1_2_3"
 SELECT int8 '0x1EEE_FFFF';
-   int8    
------------
- 518979583
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0x1EEE_FFFF"
 SELECT int8 '0o2_73';
- int8 
-------
-  187
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0o2_73"
 SELECT int8 '0b_10_0101';
- int8 
-------
-   37
-(1 row)
-
+ERROR:  invalid input syntax for type integer: "0b_10_0101"
 -- error cases
 SELECT int8 '_100';
-ERROR:  invalid input syntax for type bigint: "_100"
-LINE 1: SELECT int8 '_100';
-                    ^
+ERROR:  invalid input syntax for type integer: "_100"
 SELECT int8 '100_';
-ERROR:  invalid input syntax for type bigint: "100_"
-LINE 1: SELECT int8 '100_';
-                    ^
+ERROR:  invalid input syntax for type integer: "100_"
 SELECT int8 '100__000';
-ERROR:  invalid input syntax for type bigint: "100__000"
-LINE 1: SELECT int8 '100__000';
-                    ^
+ERROR:  invalid input syntax for type integer: "100__000"
diff -U3 /home/longqimin/pg_regress_input/expected/float4.out /home/longqimin/pg_regress_input/results/float4.out
--- /home/longqimin/pg_regress_input/expected/float4.out	2024-03-08 10:38:24.699802699 +0800
+++ /home/longqimin/pg_regress_input/results/float4.out	2024-03-08 13:58:51.752481718 +0800
@@ -9,157 +9,101 @@
 INSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e-20');
 -- test for over and under flow
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');
-ERROR:  "10e70" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');
-                                           ^
+ERROR:  value "10e70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');
-ERROR:  "-10e70" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');
-                                           ^
+ERROR:  value "-10e70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');
-ERROR:  "10e-70" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');
-                                           ^
+ERROR:  value "10e-70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');
-ERROR:  "-10e-70" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');
-                                           ^
+ERROR:  value "-10e-70" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70'::float8);
-ERROR:  value out of range: overflow
+ERROR:  value out of range
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70'::float8);
-ERROR:  value out of range: overflow
+ERROR:  value out of range
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70'::float8);
-ERROR:  value out of range: underflow
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70'::float8);
-ERROR:  value out of range: underflow
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e400');
-ERROR:  "10e400" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('10e400');
-                                           ^
+ERROR:  value "10e400" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e400');
-ERROR:  "-10e400" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e400');
-                                           ^
+ERROR:  value "-10e400" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-400');
-ERROR:  "10e-400" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-400');
-                                           ^
+ERROR:  value "10e-400" is out of range for type floating
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-400');
-ERROR:  "-10e-400" is out of range for type real
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-400');
-                                           ^
+ERROR:  value "-10e-400" is out of range for type floating
 -- bad input
 INSERT INTO FLOAT4_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for type real: ""
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('');
-                                           ^
+ERROR:  invalid input syntax for type floating: ""
 INSERT INTO FLOAT4_TBL(f1) VALUES ('       ');
-ERROR:  invalid input syntax for type real: "       "
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('       ');
-                                           ^
+ERROR:  invalid input syntax for type floating: "       "
 INSERT INTO FLOAT4_TBL(f1) VALUES ('xyz');
-ERROR:  invalid input syntax for type real: "xyz"
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('xyz');
-                                           ^
+ERROR:  invalid input syntax for type floating: "xyz"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('5.0.0');
-ERROR:  invalid input syntax for type real: "5.0.0"
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('5.0.0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "5.0.0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('5 . 0');
-ERROR:  invalid input syntax for type real: "5 . 0"
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('5 . 0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "5 . 0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('5.   0');
-ERROR:  invalid input syntax for type real: "5.   0"
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('5.   0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "5.   0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('     - 3.0');
-ERROR:  invalid input syntax for type real: "     - 3.0"
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('     - 3.0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "- 3.0"
 INSERT INTO FLOAT4_TBL(f1) VALUES ('123            5');
-ERROR:  invalid input syntax for type real: "123            5"
-LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('123            5');
-                                           ^
+ERROR:  invalid input syntax for type floating: "123            5"
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34.5', 'float4');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('xyz', 'float4');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('1e400', 'float4');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('1e400', 'float4');
-                message                | detail | hint | sql_error_code 
----------------------------------------+--------+------+----------------
- "1e400" is out of range for type real |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- special inputs
 SELECT 'NaN'::float4;
  float4 
 --------
-    NaN
+    nan
 (1 row)
 
 SELECT 'nan'::float4;
  float4 
 --------
-    NaN
+    nan
 (1 row)
 
 SELECT '   NAN  '::float4;
  float4 
 --------
-    NaN
+    nan
 (1 row)
 
 SELECT 'infinity'::float4;
-  float4  
-----------
- Infinity
+ float4 
+--------
+    inf
 (1 row)
 
 SELECT '          -INFINiTY   '::float4;
-  float4   
------------
- -Infinity
+ float4 
+--------
+   -inf
 (1 row)
 
 -- bad special inputs
 SELECT 'N A N'::float4;
-ERROR:  invalid input syntax for type real: "N A N"
-LINE 1: SELECT 'N A N'::float4;
-               ^
+ERROR:  invalid input syntax for type floating: "N A N"
 SELECT 'NaN x'::float4;
-ERROR:  invalid input syntax for type real: "NaN x"
-LINE 1: SELECT 'NaN x'::float4;
-               ^
+ERROR:  invalid input syntax for type floating: "NaN x"
 SELECT ' INFINITY    x'::float4;
-ERROR:  invalid input syntax for type real: " INFINITY    x"
-LINE 1: SELECT ' INFINITY    x'::float4;
-               ^
+ERROR:  invalid input syntax for type floating: "INFINITY    x"
 SELECT 'Infinity'::float4 + 100.0;
  ?column? 
 ----------
- Infinity
+      inf
 (1 row)
 
 SELECT 'Infinity'::float4 / 'Infinity'::float4;
  ?column? 
 ----------
-      NaN
+     -nan
 (1 row)
 
 SELECT '42'::float4 / 'Infinity'::float4;
@@ -171,39 +115,39 @@
 SELECT 'nan'::float4 / 'nan'::float4;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::float4 / '0'::float4;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::numeric::float4;
- float4 
---------
-    NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT * FROM FLOAT4_TBL;
       f1       
 ---------------
-             0
-        1004.3
         -34.84
- 1.2345679e+20
+             0
+             0
  1.2345679e-20
-(5 rows)
+ 1.2345679e+20
+             0
+        1004.3
+(7 rows)
 
 SELECT f.* FROM FLOAT4_TBL f WHERE f.f1 <> '1004.3';
       f1       
 ---------------
-             0
         -34.84
+             0
+             0
  1.2345679e+20
+             0
  1.2345679e-20
-(4 rows)
+(6 rows)
 
 SELECT f.* FROM FLOAT4_TBL f WHERE f.f1 = '1004.3';
    f1   
@@ -214,109 +158,114 @@
 SELECT f.* FROM FLOAT4_TBL f WHERE '1004.3' > f.f1;
       f1       
 ---------------
-             0
         -34.84
+             0
+             0
+             0
  1.2345679e-20
-(3 rows)
+(5 rows)
 
 SELECT f.* FROM FLOAT4_TBL f WHERE  f.f1 < '1004.3';
       f1       
 ---------------
-             0
         -34.84
+             0
+             0
  1.2345679e-20
-(3 rows)
+             0
+(5 rows)
 
 SELECT f.* FROM FLOAT4_TBL f WHERE '1004.3' >= f.f1;
       f1       
 ---------------
-             0
-        1004.3
         -34.84
+             0
+             0
  1.2345679e-20
-(4 rows)
+             0
+        1004.3
+(6 rows)
 
 SELECT f.* FROM FLOAT4_TBL f WHERE  f.f1 <= '1004.3';
       f1       
 ---------------
-             0
-        1004.3
         -34.84
+             0
+             0
  1.2345679e-20
-(4 rows)
+             0
+        1004.3
+(6 rows)
 
 SELECT f.f1, f.f1 * '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
       f1       |       x        
 ---------------+----------------
-        1004.3 |         -10043
- 1.2345679e+20 | -1.2345678e+21
  1.2345679e-20 | -1.2345678e-19
+ 1.2345679e+20 | -1.2345678e+21
+        1004.3 |         -10043
 (3 rows)
 
 SELECT f.f1, f.f1 + '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
       f1       |       x       
 ---------------+---------------
-        1004.3 |         994.3
- 1.2345679e+20 | 1.2345679e+20
  1.2345679e-20 |           -10
+ 1.2345679e+20 | 1.2345679e+20
+        1004.3 |         994.3
 (3 rows)
 
 SELECT f.f1, f.f1 / '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
       f1       |       x        
 ---------------+----------------
-        1004.3 |        -100.43
- 1.2345679e+20 | -1.2345679e+19
  1.2345679e-20 | -1.2345679e-21
+ 1.2345679e+20 | -1.2345679e+19
+        1004.3 |        -100.43
 (3 rows)
 
 SELECT f.f1, f.f1 - '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
       f1       |       x       
 ---------------+---------------
-        1004.3 |        1014.3
- 1.2345679e+20 | 1.2345679e+20
  1.2345679e-20 |            10
+ 1.2345679e+20 | 1.2345679e+20
+        1004.3 |        1014.3
 (3 rows)
 
 -- test divide by zero
 SELECT f.f1 / '0.0' from FLOAT4_TBL f;
-ERROR:  division by zero
+ERROR:  div zero [func=func_14154944641562171856]
 SELECT * FROM FLOAT4_TBL;
       f1       
 ---------------
-             0
-        1004.3
         -34.84
+             0
+             0
  1.2345679e+20
+        1004.3
  1.2345679e-20
-(5 rows)
+             0
+(7 rows)
 
 -- test the unary float4abs operator
 SELECT f.f1, @f.f1 AS abs_f1 FROM FLOAT4_TBL f;
-      f1       |    abs_f1     
----------------+---------------
-             0 |             0
-        1004.3 |        1004.3
-        -34.84 |         34.84
- 1.2345679e+20 | 1.2345679e+20
- 1.2345679e-20 | 1.2345679e-20
-(5 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=@]
 UPDATE FLOAT4_TBL
    SET f1 = FLOAT4_TBL.f1 * '-1'
    WHERE FLOAT4_TBL.f1 > '0.0';
+ERROR:  only support select and create table statement
 SELECT * FROM FLOAT4_TBL;
-       f1       
-----------------
-              0
-         -34.84
-        -1004.3
- -1.2345679e+20
- -1.2345679e-20
-(5 rows)
+      f1       
+---------------
+        -34.84
+             0
+             0
+ 1.2345679e-20
+             0
+ 1.2345679e+20
+        1004.3
+(7 rows)
 
 -- test edge-case coercions to integer
 SELECT '32767.4'::float4::int2;
@@ -326,7 +275,11 @@
 (1 row)
 
 SELECT '32767.6'::float4::int2;
-ERROR:  smallint out of range
+ int2  
+-------
+ 32767
+(1 row)
+
 SELECT '-32768.4'::float4::int2;
   int2  
 --------
@@ -334,7 +287,11 @@
 (1 row)
 
 SELECT '-32768.6'::float4::int2;
-ERROR:  smallint out of range
+  int2  
+--------
+ -32768
+(1 row)
+
 SELECT '2147483520'::float4::int4;
     int4    
 ------------
@@ -342,124 +299,52 @@
 (1 row)
 
 SELECT '2147483647'::float4::int4;
-ERROR:  integer out of range
+ERROR:  int out of range
 SELECT '-2147483648.5'::float4::int4;
-    int4     
--------------
- -2147483648
-(1 row)
-
+ERROR:  int out of range
 SELECT '-2147483900'::float4::int4;
-ERROR:  integer out of range
+ERROR:  int out of range
 SELECT '9223369837831520256'::float4::int8;
-        int8         
----------------------
- 9223369837831520256
-(1 row)
-
+ERROR:  signed char out of range
 SELECT '9223372036854775807'::float4::int8;
-ERROR:  bigint out of range
+ERROR:  signed char out of range
 SELECT '-9223372036854775808.5'::float4::int8;
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  signed char out of range
 SELECT '-9223380000000000000'::float4::int8;
-ERROR:  bigint out of range
+ERROR:  signed char out of range
 -- Test for correct input rounding in edge cases.
 -- These lists are from Paxson 1991, excluding subnormals and
 -- inputs of over 9 sig. digits.
 SELECT float4send('5e-20'::float4);
- float4send 
-------------
- \x1f6c1e4a
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('67e14'::float4);
- float4send 
-------------
- \x59be6cea
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('985e15'::float4);
- float4send 
-------------
- \x5d5ab6c4
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('55895e-16'::float4);
- float4send 
-------------
- \x2cc4a9bd
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('7038531e-32'::float4);
- float4send 
-------------
- \x15ae43fd
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('702990899e-20'::float4);
- float4send 
-------------
- \x2cf757ca
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('3e-23'::float4);
- float4send 
-------------
- \x1a111234
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('57e18'::float4);
- float4send 
-------------
- \x6045c22c
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('789e-35'::float4);
- float4send 
-------------
- \x0a23de70
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('2539e-18'::float4);
- float4send 
-------------
- \x2736f449
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('76173e28'::float4);
- float4send 
-------------
- \x7616398a
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('887745e-11'::float4);
- float4send 
-------------
- \x3714f05c
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('5382571e-37'::float4);
- float4send 
-------------
- \x0d2eaca7
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('82381273e-35'::float4);
- float4send 
-------------
- \x128289d1
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('750486563e-38'::float4);
- float4send 
-------------
- \x0f18377e
-(1 row)
-
+ERROR:  function float4send does not exist
 -- Test that the smallest possible normalized input value inputs
 -- correctly, either in 9-significant-digit or shortest-decimal
 -- format.
@@ -468,33 +353,31 @@
 -- shortest val is          1.1754944000
 -- midpoint to next val is  1.1754944208...
 SELECT float4send('1.17549435e-38'::float4);
- float4send 
-------------
- \x00800000
-(1 row)
-
+ERROR:  function float4send does not exist
 SELECT float4send('1.1754944e-38'::float4);
- float4send 
-------------
- \x00800000
-(1 row)
-
+ERROR:  function float4send does not exist
 -- test output (and round-trip safety) of various values.
 -- To ensure we're testing what we think we're testing, start with
 -- float values specified by bit patterns (as a useful side effect,
 -- this means we'll fail on non-IEEE platforms).
 create type xfloat4;
+ERROR:  only support select and create table statement
 create function xfloat4in(cstring) returns xfloat4 immutable strict
   language internal as 'int4in';
-NOTICE:  return type xfloat4 is only a shell
+ERROR:  only support select and create table statement
 create function xfloat4out(xfloat4) returns cstring immutable strict
   language internal as 'int4out';
-NOTICE:  argument type xfloat4 is only a shell
+ERROR:  only support select and create table statement
 create type xfloat4 (input = xfloat4in, output = xfloat4out, like = float4);
+ERROR:  only support select and create table statement
 create cast (xfloat4 as float4) without function;
+ERROR:  only support select and create table statement
 create cast (float4 as xfloat4) without function;
+ERROR:  only support select and create table statement
 create cast (xfloat4 as integer) without function;
+ERROR:  only support select and create table statement
 create cast (integer as xfloat4) without function;
+ERROR:  only support select and create table statement
 -- float4: seeeeeee emmmmmmm mmmmmmmm mmmmmmmm
 -- we don't care to assume the platform's strtod() handles subnormals
 -- correctly; those are "use at your own risk". However we do test
@@ -520,31 +403,7 @@
   from (select bits::integer::xfloat4::float4 as flt
           from testdata
 	offset 0) s;
-   ibits    |      flt      
-------------+---------------
- \x00000001 |         1e-45
- \x00000002 |         3e-45
- \x00000003 |         4e-45
- \x00000010 |       2.2e-44
- \x00000011 |       2.4e-44
- \x00000100 |      3.59e-43
- \x00000101 |       3.6e-43
- \x00004000 |    2.2959e-41
- \x00004001 |     2.296e-41
- \x00080000 |   7.34684e-40
- \x00080001 |   7.34685e-40
- \x0053c4f4 |     7.693e-39
- \x006c85c4 |   9.96622e-39
- \x0041ca76 |  6.041937e-39
- \x004b7678 |  6.930161e-39
- \x00000007 |         1e-44
- \x00424fe2 |    6.0898e-39
- \x007ffff0 | 1.1754921e-38
- \x007ffff1 | 1.1754922e-38
- \x007ffffe | 1.1754941e-38
- \x007fffff | 1.1754942e-38
-(21 rows)
-
+ERROR:  not implemented type_cast case [to=xfloat4]
 with testdata(bits) as (values
   (x'00000000'),
   -- smallest normal values
@@ -710,277 +569,7 @@
   from (select bits::integer::xfloat4::float4 as flt
           from testdata
 	offset 0) s;
-   ibits    |      flt       |     r_flt      |   obits    | correct 
-------------+----------------+----------------+------------+---------
- \x00000000 |              0 |              0 | \x00000000 | t
- \x00800000 |  1.1754944e-38 |  1.1754944e-38 | \x00800000 | t
- \x00800001 |  1.1754945e-38 |  1.1754945e-38 | \x00800001 | t
- \x00800004 |  1.1754949e-38 |  1.1754949e-38 | \x00800004 | t
- \x00800005 |   1.175495e-38 |   1.175495e-38 | \x00800005 | t
- \x00800006 |  1.1754952e-38 |  1.1754952e-38 | \x00800006 | t
- \x008002f1 |  1.1755999e-38 |  1.1755999e-38 | \x008002f1 | t
- \x008002f2 |     1.1756e-38 |     1.1756e-38 | \x008002f2 | t
- \x008002f3 |  1.1756001e-38 |  1.1756001e-38 | \x008002f3 | t
- \x00800e17 |  1.1759998e-38 |  1.1759998e-38 | \x00800e17 | t
- \x00800e18 |      1.176e-38 |      1.176e-38 | \x00800e18 | t
- \x00800e19 |  1.1760001e-38 |  1.1760001e-38 | \x00800e19 | t
- \x01000001 |   2.350989e-38 |   2.350989e-38 | \x01000001 | t
- \x01102843 |   2.647751e-38 |   2.647751e-38 | \x01102843 | t
- \x01a52c98 |  6.0675416e-38 |  6.0675416e-38 | \x01a52c98 | t
- \x0219c229 |  1.1296386e-37 |  1.1296386e-37 | \x0219c229 | t
- \x02e4464d |   3.354194e-37 |   3.354194e-37 | \x02e4464d | t
- \x037343c1 |   7.148906e-37 |   7.148906e-37 | \x037343c1 | t
- \x03a91b36 |   9.939175e-37 |   9.939175e-37 | \x03a91b36 | t
- \x047ada65 |   2.948764e-36 |   2.948764e-36 | \x047ada65 | t
- \x0496fe87 |  3.5498577e-36 |  3.5498577e-36 | \x0496fe87 | t
- \x0550844f |   9.804414e-36 |   9.804414e-36 | \x0550844f | t
- \x05999da3 |  1.4445957e-35 |  1.4445957e-35 | \x05999da3 | t
- \x060ea5e2 |  2.6829103e-35 |  2.6829103e-35 | \x060ea5e2 | t
- \x06e63c45 |   8.660494e-35 |   8.660494e-35 | \x06e63c45 | t
- \x07f1e548 |   3.639641e-34 |   3.639641e-34 | \x07f1e548 | t
- \x0fc5282b |  1.9441172e-29 |  1.9441172e-29 | \x0fc5282b | t
- \x1f850283 |  5.6331846e-20 |  5.6331846e-20 | \x1f850283 | t
- \x2874a9d6 |  1.3581548e-14 |  1.3581548e-14 | \x2874a9d6 | t
- \x3356bf94 |  4.9999997e-08 |  4.9999997e-08 | \x3356bf94 | t
- \x3356bf95 |          5e-08 |          5e-08 | \x3356bf95 | t
- \x3356bf96 |  5.0000004e-08 |  5.0000004e-08 | \x3356bf96 | t
- \x33d6bf94 |  9.9999994e-08 |  9.9999994e-08 | \x33d6bf94 | t
- \x33d6bf95 |          1e-07 |          1e-07 | \x33d6bf95 | t
- \x33d6bf96 |  1.0000001e-07 |  1.0000001e-07 | \x33d6bf96 | t
- \x34a10faf |  2.9999998e-07 |  2.9999998e-07 | \x34a10faf | t
- \x34a10fb0 |          3e-07 |          3e-07 | \x34a10fb0 | t
- \x34a10fb1 |  3.0000004e-07 |  3.0000004e-07 | \x34a10fb1 | t
- \x350637bc |  4.9999994e-07 |  4.9999994e-07 | \x350637bc | t
- \x350637bd |          5e-07 |          5e-07 | \x350637bd | t
- \x350637be |  5.0000006e-07 |  5.0000006e-07 | \x350637be | t
- \x35719786 |   8.999999e-07 |   8.999999e-07 | \x35719786 | t
- \x35719787 |          9e-07 |          9e-07 | \x35719787 | t
- \x35719788 |  9.0000003e-07 |  9.0000003e-07 | \x35719788 | t
- \x358637bc |   9.999999e-07 |   9.999999e-07 | \x358637bc | t
- \x358637bd |          1e-06 |          1e-06 | \x358637bd | t
- \x358637be |  1.0000001e-06 |  1.0000001e-06 | \x358637be | t
- \x36a7c5ab |  4.9999994e-06 |  4.9999994e-06 | \x36a7c5ab | t
- \x36a7c5ac |          5e-06 |          5e-06 | \x36a7c5ac | t
- \x36a7c5ad |  5.0000003e-06 |  5.0000003e-06 | \x36a7c5ad | t
- \x3727c5ab |   9.999999e-06 |   9.999999e-06 | \x3727c5ab | t
- \x3727c5ac |          1e-05 |          1e-05 | \x3727c5ac | t
- \x3727c5ad |  1.0000001e-05 |  1.0000001e-05 | \x3727c5ad | t
- \x38d1b714 |  9.9999976e-05 |  9.9999976e-05 | \x38d1b714 | t
- \x38d1b715 |   9.999998e-05 |   9.999998e-05 | \x38d1b715 | t
- \x38d1b716 |   9.999999e-05 |   9.999999e-05 | \x38d1b716 | t
- \x38d1b717 |         0.0001 |         0.0001 | \x38d1b717 | t
- \x38d1b718 | 0.000100000005 | 0.000100000005 | \x38d1b718 | t
- \x38d1b719 |  0.00010000001 |  0.00010000001 | \x38d1b719 | t
- \x38d1b71a |  0.00010000002 |  0.00010000002 | \x38d1b71a | t
- \x38d1b71b |  0.00010000003 |  0.00010000003 | \x38d1b71b | t
- \x38d1b71c | 0.000100000034 | 0.000100000034 | \x38d1b71c | t
- \x38d1b71d |  0.00010000004 |  0.00010000004 | \x38d1b71d | t
- \x38dffffe |  0.00010681151 |  0.00010681151 | \x38dffffe | t
- \x38dfffff | 0.000106811516 | 0.000106811516 | \x38dfffff | t
- \x38e00000 |  0.00010681152 |  0.00010681152 | \x38e00000 | t
- \x38efffff |  0.00011444091 |  0.00011444091 | \x38efffff | t
- \x38f00000 |  0.00011444092 |  0.00011444092 | \x38f00000 | t
- \x38f00001 | 0.000114440925 | 0.000114440925 | \x38f00001 | t
- \x3a83126e |   0.0009999999 |   0.0009999999 | \x3a83126e | t
- \x3a83126f |          0.001 |          0.001 | \x3a83126f | t
- \x3a831270 |   0.0010000002 |   0.0010000002 | \x3a831270 | t
- \x3c23d709 |    0.009999999 |    0.009999999 | \x3c23d709 | t
- \x3c23d70a |           0.01 |           0.01 | \x3c23d70a | t
- \x3c23d70b |    0.010000001 |    0.010000001 | \x3c23d70b | t
- \x3dcccccc |    0.099999994 |    0.099999994 | \x3dcccccc | t
- \x3dcccccd |            0.1 |            0.1 | \x3dcccccd | t
- \x3dccccce |     0.10000001 |     0.10000001 | \x3dccccce | t
- \x3dcccd6f |     0.10000121 |     0.10000121 | \x3dcccd6f | t
- \x3dcccd70 |    0.100001216 |    0.100001216 | \x3dcccd70 | t
- \x3dcccd71 |     0.10000122 |     0.10000122 | \x3dcccd71 | t
- \x3effffff |     0.49999997 |     0.49999997 | \x3effffff | t
- \x3f000000 |            0.5 |            0.5 | \x3f000000 | t
- \x3f000001 |     0.50000006 |     0.50000006 | \x3f000001 | t
- \x3f333332 |      0.6999999 |      0.6999999 | \x3f333332 | t
- \x3f333333 |            0.7 |            0.7 | \x3f333333 | t
- \x3f333334 |     0.70000005 |     0.70000005 | \x3f333334 | t
- \x3f666665 |      0.8999999 |      0.8999999 | \x3f666665 | t
- \x3f666666 |            0.9 |            0.9 | \x3f666666 | t
- \x3f666667 |     0.90000004 |     0.90000004 | \x3f666667 | t
- \x3f7d70a3 |     0.98999995 |     0.98999995 | \x3f7d70a3 | t
- \x3f7d70a4 |           0.99 |           0.99 | \x3f7d70a4 | t
- \x3f7d70a5 |     0.99000007 |     0.99000007 | \x3f7d70a5 | t
- \x3f7fbe76 |     0.99899995 |     0.99899995 | \x3f7fbe76 | t
- \x3f7fbe77 |          0.999 |          0.999 | \x3f7fbe77 | t
- \x3f7fbe78 |      0.9990001 |      0.9990001 | \x3f7fbe78 | t
- \x3f7ff971 |      0.9998999 |      0.9998999 | \x3f7ff971 | t
- \x3f7ff972 |         0.9999 |         0.9999 | \x3f7ff972 | t
- \x3f7ff973 |     0.99990004 |     0.99990004 | \x3f7ff973 | t
- \x3f7fff57 |      0.9999899 |      0.9999899 | \x3f7fff57 | t
- \x3f7fff58 |        0.99999 |        0.99999 | \x3f7fff58 | t
- \x3f7fff59 |     0.99999005 |     0.99999005 | \x3f7fff59 | t
- \x3f7fffee |      0.9999989 |      0.9999989 | \x3f7fffee | t
- \x3f7fffef |       0.999999 |       0.999999 | \x3f7fffef | t
- \x3f7ffff0 |     0.99999905 |     0.99999905 | \x3f7ffff0 | t
- \x3f7ffff1 |      0.9999991 |      0.9999991 | \x3f7ffff1 | t
- \x3f7ffff2 |     0.99999917 |     0.99999917 | \x3f7ffff2 | t
- \x3f7ffff3 |      0.9999992 |      0.9999992 | \x3f7ffff3 | t
- \x3f7ffff4 |      0.9999993 |      0.9999993 | \x3f7ffff4 | t
- \x3f7ffff5 |     0.99999934 |     0.99999934 | \x3f7ffff5 | t
- \x3f7ffff6 |      0.9999994 |      0.9999994 | \x3f7ffff6 | t
- \x3f7ffff7 |     0.99999946 |     0.99999946 | \x3f7ffff7 | t
- \x3f7ffff8 |      0.9999995 |      0.9999995 | \x3f7ffff8 | t
- \x3f7ffff9 |      0.9999996 |      0.9999996 | \x3f7ffff9 | t
- \x3f7ffffa |     0.99999964 |     0.99999964 | \x3f7ffffa | t
- \x3f7ffffb |      0.9999997 |      0.9999997 | \x3f7ffffb | t
- \x3f7ffffc |     0.99999976 |     0.99999976 | \x3f7ffffc | t
- \x3f7ffffd |      0.9999998 |      0.9999998 | \x3f7ffffd | t
- \x3f7ffffe |      0.9999999 |      0.9999999 | \x3f7ffffe | t
- \x3f7fffff |     0.99999994 |     0.99999994 | \x3f7fffff | t
- \x3f800000 |              1 |              1 | \x3f800000 | t
- \x3f800001 |      1.0000001 |      1.0000001 | \x3f800001 | t
- \x3f800002 |      1.0000002 |      1.0000002 | \x3f800002 | t
- \x3f800003 |      1.0000004 |      1.0000004 | \x3f800003 | t
- \x3f800004 |      1.0000005 |      1.0000005 | \x3f800004 | t
- \x3f800005 |      1.0000006 |      1.0000006 | \x3f800005 | t
- \x3f800006 |      1.0000007 |      1.0000007 | \x3f800006 | t
- \x3f800007 |      1.0000008 |      1.0000008 | \x3f800007 | t
- \x3f800008 |       1.000001 |       1.000001 | \x3f800008 | t
- \x3f800009 |      1.0000011 |      1.0000011 | \x3f800009 | t
- \x3f80000f |      1.0000018 |      1.0000018 | \x3f80000f | t
- \x3f800010 |      1.0000019 |      1.0000019 | \x3f800010 | t
- \x3f800011 |       1.000002 |       1.000002 | \x3f800011 | t
- \x3f800012 |      1.0000021 |      1.0000021 | \x3f800012 | t
- \x3f800013 |      1.0000023 |      1.0000023 | \x3f800013 | t
- \x3f800014 |      1.0000024 |      1.0000024 | \x3f800014 | t
- \x3f800017 |      1.0000027 |      1.0000027 | \x3f800017 | t
- \x3f800018 |      1.0000029 |      1.0000029 | \x3f800018 | t
- \x3f800019 |       1.000003 |       1.000003 | \x3f800019 | t
- \x3f80001a |      1.0000031 |      1.0000031 | \x3f80001a | t
- \x3f80001b |      1.0000032 |      1.0000032 | \x3f80001b | t
- \x3f80001c |      1.0000033 |      1.0000033 | \x3f80001c | t
- \x3f800029 |      1.0000049 |      1.0000049 | \x3f800029 | t
- \x3f80002a |       1.000005 |       1.000005 | \x3f80002a | t
- \x3f80002b |      1.0000051 |      1.0000051 | \x3f80002b | t
- \x3f800053 |      1.0000099 |      1.0000099 | \x3f800053 | t
- \x3f800054 |        1.00001 |        1.00001 | \x3f800054 | t
- \x3f800055 |      1.0000101 |      1.0000101 | \x3f800055 | t
- \x3f800346 |      1.0000999 |      1.0000999 | \x3f800346 | t
- \x3f800347 |         1.0001 |         1.0001 | \x3f800347 | t
- \x3f800348 |      1.0001001 |      1.0001001 | \x3f800348 | t
- \x3f8020c4 |      1.0009999 |      1.0009999 | \x3f8020c4 | t
- \x3f8020c5 |          1.001 |          1.001 | \x3f8020c5 | t
- \x3f8020c6 |      1.0010002 |      1.0010002 | \x3f8020c6 | t
- \x3f8147ad |      1.0099999 |      1.0099999 | \x3f8147ad | t
- \x3f8147ae |           1.01 |           1.01 | \x3f8147ae | t
- \x3f8147af |      1.0100001 |      1.0100001 | \x3f8147af | t
- \x3f8ccccc |      1.0999999 |      1.0999999 | \x3f8ccccc | t
- \x3f8ccccd |            1.1 |            1.1 | \x3f8ccccd | t
- \x3f8cccce |      1.1000001 |      1.1000001 | \x3f8cccce | t
- \x3fc90fdb |      1.5707964 |      1.5707964 | \x3fc90fdb | t
- \x402df854 |      2.7182817 |      2.7182817 | \x402df854 | t
- \x40490fdb |      3.1415927 |      3.1415927 | \x40490fdb | t
- \x409fffff |      4.9999995 |      4.9999995 | \x409fffff | t
- \x40a00000 |              5 |              5 | \x40a00000 | t
- \x40a00001 |      5.0000005 |      5.0000005 | \x40a00001 | t
- \x40afffff |      5.4999995 |      5.4999995 | \x40afffff | t
- \x40b00000 |            5.5 |            5.5 | \x40b00000 | t
- \x40b00001 |      5.5000005 |      5.5000005 | \x40b00001 | t
- \x411fffff |       9.999999 |       9.999999 | \x411fffff | t
- \x41200000 |             10 |             10 | \x41200000 | t
- \x41200001 |      10.000001 |      10.000001 | \x41200001 | t
- \x42c7ffff |       99.99999 |       99.99999 | \x42c7ffff | t
- \x42c80000 |            100 |            100 | \x42c80000 | t
- \x42c80001 |      100.00001 |      100.00001 | \x42c80001 | t
- \x4479ffff |      999.99994 |      999.99994 | \x4479ffff | t
- \x447a0000 |           1000 |           1000 | \x447a0000 | t
- \x447a0001 |     1000.00006 |     1000.00006 | \x447a0001 | t
- \x461c3fff |       9999.999 |       9999.999 | \x461c3fff | t
- \x461c4000 |          10000 |          10000 | \x461c4000 | t
- \x461c4001 |      10000.001 |      10000.001 | \x461c4001 | t
- \x47c34fff |       99999.99 |       99999.99 | \x47c34fff | t
- \x47c35000 |         100000 |         100000 | \x47c35000 | t
- \x47c35001 |      100000.01 |      100000.01 | \x47c35001 | t
- \x497423ff |      999999.94 |      999999.94 | \x497423ff | t
- \x49742400 |          1e+06 |          1e+06 | \x49742400 | t
- \x49742401 | 1.00000006e+06 | 1.00000006e+06 | \x49742401 | t
- \x4b18967f |   9.999999e+06 |   9.999999e+06 | \x4b18967f | t
- \x4b189680 |          1e+07 |          1e+07 | \x4b189680 | t
- \x4b189681 |  1.0000001e+07 |  1.0000001e+07 | \x4b189681 | t
- \x4cbebc1f |   9.999999e+07 |   9.999999e+07 | \x4cbebc1f | t
- \x4cbebc20 |          1e+08 |          1e+08 | \x4cbebc20 | t
- \x4cbebc21 |  1.0000001e+08 |  1.0000001e+08 | \x4cbebc21 | t
- \x4e6e6b27 |  9.9999994e+08 |  9.9999994e+08 | \x4e6e6b27 | t
- \x4e6e6b28 |          1e+09 |          1e+09 | \x4e6e6b28 | t
- \x4e6e6b29 | 1.00000006e+09 | 1.00000006e+09 | \x4e6e6b29 | t
- \x501502f8 |   9.999999e+09 |   9.999999e+09 | \x501502f8 | t
- \x501502f9 |          1e+10 |          1e+10 | \x501502f9 | t
- \x501502fa |  1.0000001e+10 |  1.0000001e+10 | \x501502fa | t
- \x51ba43b6 |   9.999999e+10 |   9.999999e+10 | \x51ba43b6 | t
- \x51ba43b7 |          1e+11 |          1e+11 | \x51ba43b7 | t
- \x51ba43b8 |  1.0000001e+11 |  1.0000001e+11 | \x51ba43b8 | t
- \x1f6c1e4a |          5e-20 |          5e-20 | \x1f6c1e4a | t
- \x59be6cea |        6.7e+15 |        6.7e+15 | \x59be6cea | t
- \x5d5ab6c4 |       9.85e+17 |       9.85e+17 | \x5d5ab6c4 | t
- \x2cc4a9bd |     5.5895e-12 |     5.5895e-12 | \x2cc4a9bd | t
- \x15ae43fd |   7.038531e-26 |   7.038531e-26 | \x15ae43fd | t
- \x2cf757ca |  7.0299088e-12 |  7.0299088e-12 | \x2cf757ca | t
- \x665ba998 |  2.5933168e+23 |  2.5933168e+23 | \x665ba998 | t
- \x743c3324 |  5.9642887e+31 |  5.9642887e+31 | \x743c3324 | t
- \x47f1205a |       123456.7 |       123456.7 | \x47f1205a | t
- \x4640e6ae |       12345.67 |       12345.67 | \x4640e6ae | t
- \x449a5225 |       1234.567 |       1234.567 | \x449a5225 | t
- \x42f6e9d5 |       123.4567 |       123.4567 | \x42f6e9d5 | t
- \x414587dd |       12.34567 |       12.34567 | \x414587dd | t
- \x3f9e064b |       1.234567 |       1.234567 | \x3f9e064b | t
- \x4c000004 |  3.3554448e+07 |  3.3554448e+07 | \x4c000004 | t
- \x50061c46 |   8.999999e+09 |   8.999999e+09 | \x50061c46 | t
- \x510006a8 |  3.4366718e+10 |  3.4366718e+10 | \x510006a8 | t
- \x48951f84 |      305404.12 |      305404.12 | \x48951f84 | t
- \x45fd1840 |      8099.0312 |      8099.0312 | \x45fd1840 | t
- \x39800000 |  0.00024414062 |  0.00024414062 | \x39800000 | t
- \x3b200000 |   0.0024414062 |   0.0024414062 | \x3b200000 | t
- \x3b900000 |   0.0043945312 |   0.0043945312 | \x3b900000 | t
- \x3bd00000 |   0.0063476562 |   0.0063476562 | \x3bd00000 | t
- \x63800000 |  4.7223665e+21 |  4.7223665e+21 | \x63800000 | t
- \x4b000000 |   8.388608e+06 |   8.388608e+06 | \x4b000000 | t
- \x4b800000 |  1.6777216e+07 |  1.6777216e+07 | \x4b800000 | t
- \x4c000001 |  3.3554436e+07 |  3.3554436e+07 | \x4c000001 | t
- \x4c800b0d |  6.7131496e+07 |  6.7131496e+07 | \x4c800b0d | t
- \x00d24584 |  1.9310392e-38 |  1.9310392e-38 | \x00d24584 | t
- \x00d90b88 |   1.993244e-38 |   1.993244e-38 | \x00d90b88 | t
- \x45803f34 |      4103.9004 |      4103.9004 | \x45803f34 | t
- \x4f9f24f7 |  5.3399997e+09 |  5.3399997e+09 | \x4f9f24f7 | t
- \x3a8722c3 |   0.0010310042 |   0.0010310042 | \x3a8722c3 | t
- \x5c800041 |   2.882326e+17 |   2.882326e+17 | \x5c800041 | t
- \x15ae43fd |   7.038531e-26 |   7.038531e-26 | \x15ae43fd | t
- \x5d4cccfb |   9.223404e+17 |   9.223404e+17 | \x5d4cccfb | t
- \x4c800001 |   6.710887e+07 |   6.710887e+07 | \x4c800001 | t
- \x57800ed8 |   2.816025e+14 |   2.816025e+14 | \x57800ed8 | t
- \x5f000000 |   9.223372e+18 |   9.223372e+18 | \x5f000000 | t
- \x700000f0 |  1.5846086e+29 |  1.5846086e+29 | \x700000f0 | t
- \x5f23e9ac |  1.1811161e+19 |  1.1811161e+19 | \x5f23e9ac | t
- \x5e9502f9 |   5.368709e+18 |   5.368709e+18 | \x5e9502f9 | t
- \x5e8012b1 |  4.6143166e+18 |  4.6143166e+18 | \x5e8012b1 | t
- \x3c000028 |    0.007812537 |    0.007812537 | \x3c000028 | t
- \x60cde861 | 1.18697725e+20 | 1.18697725e+20 | \x60cde861 | t
- \x03aa2a50 | 1.00014165e-36 | 1.00014165e-36 | \x03aa2a50 | t
- \x43480000 |            200 |            200 | \x43480000 | t
- \x4c000000 |  3.3554432e+07 |  3.3554432e+07 | \x4c000000 | t
- \x5d1502f9 |  6.7108864e+17 |  6.7108864e+17 | \x5d1502f9 | t
- \x5d9502f9 |  1.3421773e+18 |  1.3421773e+18 | \x5d9502f9 | t
- \x5e1502f9 |  2.6843546e+18 |  2.6843546e+18 | \x5e1502f9 | t
- \x3f99999a |            1.2 |            1.2 | \x3f99999a | t
- \x3f9d70a4 |           1.23 |           1.23 | \x3f9d70a4 | t
- \x3f9df3b6 |          1.234 |          1.234 | \x3f9df3b6 | t
- \x3f9e0419 |         1.2345 |         1.2345 | \x3f9e0419 | t
- \x3f9e0610 |        1.23456 |        1.23456 | \x3f9e0610 | t
- \x3f9e064b |       1.234567 |       1.234567 | \x3f9e064b | t
- \x3f9e0651 |      1.2345678 |      1.2345678 | \x3f9e0651 | t
- \x03d20cfe | 1.23456735e-36 | 1.23456735e-36 | \x03d20cfe | t
-(261 rows)
-
+ERROR:  not implemented type_cast case [to=xfloat4]
 -- clean up, lest opr_sanity complain
 drop type xfloat4 cascade;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to function xfloat4in(cstring)
-drop cascades to function xfloat4out(xfloat4)
-drop cascades to cast from xfloat4 to real
-drop cascades to cast from real to xfloat4
-drop cascades to cast from xfloat4 to integer
-drop cascades to cast from integer to xfloat4
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/pg_regress_input/expected/float8.out /home/longqimin/pg_regress_input/results/float8.out
--- /home/longqimin/pg_regress_input/expected/float8.out	2024-03-08 10:38:56.359803705 +0800
+++ /home/longqimin/pg_regress_input/results/float8.out	2024-03-08 13:58:57.261481177 +0800
@@ -6,6 +6,7 @@
 -- (This temporarily hides the table created in test_setup.sql)
 --
 CREATE TEMP TABLE FLOAT8_TBL(f1 float8);
+ERROR:  relation "public.float8_tbl" already exists
 INSERT INTO FLOAT8_TBL(f1) VALUES ('    0.0   ');
 INSERT INTO FLOAT8_TBL(f1) VALUES ('1004.30  ');
 INSERT INTO FLOAT8_TBL(f1) VALUES ('   -34.84');
@@ -13,140 +14,90 @@
 INSERT INTO FLOAT8_TBL(f1) VALUES ('1.2345678901234e-200');
 -- test for underflow and overflow handling
 SELECT '10e400'::float8;
-ERROR:  "10e400" is out of range for type double precision
-LINE 1: SELECT '10e400'::float8;
-               ^
+ERROR:  value "10e400" is out of range for type floating
 SELECT '-10e400'::float8;
-ERROR:  "-10e400" is out of range for type double precision
-LINE 1: SELECT '-10e400'::float8;
-               ^
+ERROR:  value "-10e400" is out of range for type floating
 SELECT '10e-400'::float8;
-ERROR:  "10e-400" is out of range for type double precision
-LINE 1: SELECT '10e-400'::float8;
-               ^
+ERROR:  value "10e-400" is out of range for type floating
 SELECT '-10e-400'::float8;
-ERROR:  "-10e-400" is out of range for type double precision
-LINE 1: SELECT '-10e-400'::float8;
-               ^
+ERROR:  value "-10e-400" is out of range for type floating
 -- test smallest normalized input
 SELECT float8send('2.2250738585072014E-308'::float8);
-     float8send     
---------------------
- \x0010000000000000
-(1 row)
-
+ERROR:  function float8send does not exist
 -- bad input
 INSERT INTO FLOAT8_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for type double precision: ""
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('');
-                                           ^
+ERROR:  invalid input syntax for type floating: ""
 INSERT INTO FLOAT8_TBL(f1) VALUES ('     ');
-ERROR:  invalid input syntax for type double precision: "     "
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('     ');
-                                           ^
+ERROR:  invalid input syntax for type floating: "     "
 INSERT INTO FLOAT8_TBL(f1) VALUES ('xyz');
-ERROR:  invalid input syntax for type double precision: "xyz"
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('xyz');
-                                           ^
+ERROR:  invalid input syntax for type floating: "xyz"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('5.0.0');
-ERROR:  invalid input syntax for type double precision: "5.0.0"
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('5.0.0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "5.0.0"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('5 . 0');
-ERROR:  invalid input syntax for type double precision: "5 . 0"
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('5 . 0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "5 . 0"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('5.   0');
-ERROR:  invalid input syntax for type double precision: "5.   0"
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('5.   0');
-                                           ^
+ERROR:  invalid input syntax for type floating: "5.   0"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('    - 3');
-ERROR:  invalid input syntax for type double precision: "    - 3"
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('    - 3');
-                                           ^
+ERROR:  invalid input syntax for type floating: "- 3"
 INSERT INTO FLOAT8_TBL(f1) VALUES ('123           5');
-ERROR:  invalid input syntax for type double precision: "123           5"
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('123           5');
-                                           ^
+ERROR:  invalid input syntax for type floating: "123           5"
 -- Also try it with non-error-throwing API
 SELECT pg_input_is_valid('34.5', 'float8');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('xyz', 'float8');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('1e4000', 'float8');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('1e4000', 'float8');
-                      message                       | detail | hint | sql_error_code 
-----------------------------------------------------+--------+------+----------------
- "1e4000" is out of range for type double precision |        |      | 22003
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 -- special inputs
 SELECT 'NaN'::float8;
  float8 
 --------
-    NaN
+    nan
 (1 row)
 
 SELECT 'nan'::float8;
  float8 
 --------
-    NaN
+    nan
 (1 row)
 
 SELECT '   NAN  '::float8;
  float8 
 --------
-    NaN
+    nan
 (1 row)
 
 SELECT 'infinity'::float8;
-  float8  
-----------
- Infinity
+ float8 
+--------
+    inf
 (1 row)
 
 SELECT '          -INFINiTY   '::float8;
-  float8   
------------
- -Infinity
+ float8 
+--------
+   -inf
 (1 row)
 
 -- bad special inputs
 SELECT 'N A N'::float8;
-ERROR:  invalid input syntax for type double precision: "N A N"
-LINE 1: SELECT 'N A N'::float8;
-               ^
+ERROR:  invalid input syntax for type floating: "N A N"
 SELECT 'NaN x'::float8;
-ERROR:  invalid input syntax for type double precision: "NaN x"
-LINE 1: SELECT 'NaN x'::float8;
-               ^
+ERROR:  invalid input syntax for type floating: "NaN x"
 SELECT ' INFINITY    x'::float8;
-ERROR:  invalid input syntax for type double precision: " INFINITY    x"
-LINE 1: SELECT ' INFINITY    x'::float8;
-               ^
+ERROR:  invalid input syntax for type floating: "INFINITY    x"
 SELECT 'Infinity'::float8 + 100.0;
  ?column? 
 ----------
- Infinity
+      inf
 (1 row)
 
 SELECT 'Infinity'::float8 / 'Infinity'::float8;
  ?column? 
 ----------
-      NaN
+     -nan
 (1 row)
 
 SELECT '42'::float8 / 'Infinity'::float8;
@@ -158,39 +109,45 @@
 SELECT 'nan'::float8 / 'nan'::float8;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::float8 / '0'::float8;
  ?column? 
 ----------
-      NaN
+      nan
 (1 row)
 
 SELECT 'nan'::numeric::float8;
- float8 
---------
-    NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT * FROM FLOAT8_TBL;
-          f1          
-----------------------
-                    0
-               1004.3
-               -34.84
- 1.2345678901234e+200
- 1.2345678901234e-200
-(5 rows)
+          f1           
+-----------------------
+                     0
+  1.2345678901234e-200
+  1.2345678901234e+200
+                1004.3
+                -34.84
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+(10 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE f.f1 <> '1004.3';
-          f1          
-----------------------
-                    0
-               -34.84
- 1.2345678901234e+200
- 1.2345678901234e-200
-(4 rows)
+          f1           
+-----------------------
+                     0
+  1.2345678901234e-200
+  1.2345678901234e+200
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+                -34.84
+(9 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE f.f1 = '1004.3';
    f1   
@@ -199,38 +156,58 @@
 (1 row)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE '1004.3' > f.f1;
-          f1          
-----------------------
-                    0
-               -34.84
- 1.2345678901234e-200
-(3 rows)
+          f1           
+-----------------------
+  1.2345678901234e-200
+                     0
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+                -34.84
+(8 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE  f.f1 < '1004.3';
-          f1          
-----------------------
-                    0
-               -34.84
- 1.2345678901234e-200
-(3 rows)
+          f1           
+-----------------------
+                     0
+  1.2345678901234e-200
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+                -34.84
+(8 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE '1004.3' >= f.f1;
-          f1          
-----------------------
-                    0
-               1004.3
-               -34.84
- 1.2345678901234e-200
-(4 rows)
+          f1           
+-----------------------
+  1.2345678901234e-200
+                     0
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+                1004.3
+                -34.84
+(9 rows)
 
 SELECT f.* FROM FLOAT8_TBL f WHERE  f.f1 <= '1004.3';
-          f1          
-----------------------
-                    0
-               1004.3
-               -34.84
- 1.2345678901234e-200
-(4 rows)
+          f1           
+-----------------------
+                     0
+  1.2345678901234e-200
+                1004.3
+                -34.84
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+(9 rows)
 
 SELECT f.f1, f.f1 * '-10' AS x
    FROM FLOAT8_TBL f
@@ -238,8 +215,8 @@
           f1          |           x           
 ----------------------+-----------------------
                1004.3 |                -10043
- 1.2345678901234e+200 | -1.2345678901234e+201
  1.2345678901234e-200 | -1.2345678901234e-199
+ 1.2345678901234e+200 | -1.2345678901234e+201
 (3 rows)
 
 SELECT f.f1, f.f1 + '-10' AS x
@@ -248,8 +225,8 @@
           f1          |          x           
 ----------------------+----------------------
                1004.3 |                994.3
- 1.2345678901234e+200 | 1.2345678901234e+200
  1.2345678901234e-200 |                  -10
+ 1.2345678901234e+200 | 1.2345678901234e+200
 (3 rows)
 
 SELECT f.f1, f.f1 / '-10' AS x
@@ -258,8 +235,8 @@
           f1          |           x           
 ----------------------+-----------------------
                1004.3 |   -100.42999999999999
- 1.2345678901234e+200 | -1.2345678901234e+199
  1.2345678901234e-200 | -1.2345678901234e-201
+ 1.2345678901234e+200 | -1.2345678901234e+199
 (3 rows)
 
 SELECT f.f1, f.f1 - '-10' AS x
@@ -268,532 +245,250 @@
           f1          |          x           
 ----------------------+----------------------
                1004.3 |               1014.3
- 1.2345678901234e+200 | 1.2345678901234e+200
  1.2345678901234e-200 |                   10
+ 1.2345678901234e+200 | 1.2345678901234e+200
 (3 rows)
 
 SELECT f.f1 ^ '2.0' AS square_f1
    FROM FLOAT8_TBL f where f.f1 = '1004.3';
-     square_f1      
---------------------
- 1008618.4899999999
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 -- absolute value
 SELECT f.f1, @f.f1 AS abs_f1
    FROM FLOAT8_TBL f;
-          f1          |        abs_f1        
-----------------------+----------------------
-                    0 |                    0
-               1004.3 |               1004.3
-               -34.84 |                34.84
- 1.2345678901234e+200 | 1.2345678901234e+200
- 1.2345678901234e-200 | 1.2345678901234e-200
-(5 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=@]
 -- truncate
 SELECT f.f1, trunc(f.f1) AS trunc_f1
    FROM FLOAT8_TBL f;
-          f1          |       trunc_f1       
-----------------------+----------------------
-                    0 |                    0
-               1004.3 |                 1004
-               -34.84 |                  -34
- 1.2345678901234e+200 | 1.2345678901234e+200
- 1.2345678901234e-200 |                    0
-(5 rows)
-
+ERROR:  function trunc does not exist
 -- round
 SELECT f.f1, round(f.f1) AS round_f1
    FROM FLOAT8_TBL f;
-          f1          |       round_f1       
-----------------------+----------------------
-                    0 |                    0
-               1004.3 |                 1004
-               -34.84 |                  -35
- 1.2345678901234e+200 | 1.2345678901234e+200
- 1.2345678901234e-200 |                    0
-(5 rows)
-
+ERROR:  function round does not exist
 -- ceil / ceiling
 select ceil(f1) as ceil_f1 from float8_tbl f;
-       ceil_f1        
-----------------------
-                    0
-                 1005
-                  -34
- 1.2345678901234e+200
-                    1
-(5 rows)
-
+ERROR:  function ceil does not exist
 select ceiling(f1) as ceiling_f1 from float8_tbl f;
-      ceiling_f1      
-----------------------
-                    0
-                 1005
-                  -34
- 1.2345678901234e+200
-                    1
-(5 rows)
-
+ERROR:  function ceiling does not exist
 -- floor
 select floor(f1) as floor_f1 from float8_tbl f;
-       floor_f1       
-----------------------
-                    0
-                 1004
-                  -35
- 1.2345678901234e+200
-                    0
-(5 rows)
-
+ERROR:  function floor does not exist
 -- sign
 select sign(f1) as sign_f1 from float8_tbl f;
- sign_f1 
----------
-       0
-       1
-      -1
-       1
-       1
-(5 rows)
-
+ERROR:  function sign does not exist
 -- avoid bit-exact output here because operations may not be bit-exact.
 SET extra_float_digits = 0;
+ERROR:  only support select and create table statement
 -- square root
 SELECT sqrt(float8 '64') AS eight;
- eight 
--------
-     8
-(1 row)
-
+ERROR:  function sqrt does not exist
 SELECT |/ float8 '64' AS eight;
- eight 
--------
-     8
-(1 row)
-
+ERROR:  unary_optr only support +/-, [optr_str=|/]
 SELECT f.f1, |/f.f1 AS sqrt_f1
    FROM FLOAT8_TBL f
    WHERE f.f1 > '0.0';
-          f1          |        sqrt_f1        
-----------------------+-----------------------
-               1004.3 |      31.6906926399535
- 1.2345678901234e+200 | 1.11111110611109e+100
- 1.2345678901234e-200 | 1.11111110611109e-100
-(3 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=|/]
 -- power
 SELECT power(float8 '144', float8 '0.5');
- power 
--------
-    12
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'NaN', float8 '0.5');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '144', float8 'NaN');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'NaN', float8 'NaN');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1', float8 'NaN');
- power 
--------
-   NaN
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1', float8 'NaN');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'NaN', float8 '0');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '0');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '0');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0', float8 'inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0', float8 '-inf');
-ERROR:  zero raised to a negative power is undefined
+ERROR:  function power does not exist
 SELECT power(float8 '1', float8 'inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1', float8 '-inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1', float8 'inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1', float8 '-inf');
- power 
--------
-     1
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0.1', float8 'inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-0.1', float8 'inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1.1', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1.1', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '0.1', float8 '-inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-0.1', float8 '-inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '1.1', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-1.1', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '-2');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '2');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 'inf', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 -- Intel's icc misoptimizes the code that controls the sign of this result,
 -- even with -mp1.  Pending a fix for that, only test for "is it zero".
 SELECT power(float8 '-inf', float8 '-2') = '0';
- ?column? 
-----------
- t
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '-3');
- power 
--------
-    -0
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '2');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '3');
-   power   
------------
- -Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '3.5');
-ERROR:  a negative number raised to a non-integer power yields a complex result
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 'inf');
-  power   
-----------
- Infinity
-(1 row)
-
+ERROR:  function power does not exist
 SELECT power(float8 '-inf', float8 '-inf');
- power 
--------
-     0
-(1 row)
-
+ERROR:  function power does not exist
 -- take exp of ln(f.f1)
 SELECT f.f1, exp(ln(f.f1)) AS exp_ln_f1
    FROM FLOAT8_TBL f
    WHERE f.f1 > '0.0';
-          f1          |       exp_ln_f1       
-----------------------+-----------------------
-               1004.3 |                1004.3
- 1.2345678901234e+200 | 1.23456789012338e+200
- 1.2345678901234e-200 | 1.23456789012339e-200
-(3 rows)
-
+ERROR:  function exp does not exist
 -- check edge cases for exp
 SELECT exp('inf'::float8), exp('-inf'::float8), exp('nan'::float8);
-   exp    | exp | exp 
-----------+-----+-----
- Infinity |   0 | NaN
-(1 row)
-
+ERROR:  function exp does not exist
 -- cube root
 SELECT ||/ float8 '27' AS three;
- three 
--------
-     3
-(1 row)
-
+ERROR:  unary_optr only support +/-, [optr_str=||/]
 SELECT f.f1, ||/f.f1 AS cbrt_f1 FROM FLOAT8_TBL f;
-          f1          |       cbrt_f1        
-----------------------+----------------------
-                    0 |                    0
-               1004.3 |      10.014312837827
-               -34.84 |    -3.26607421344208
- 1.2345678901234e+200 | 4.97933859234765e+66
- 1.2345678901234e-200 |  2.3112042409018e-67
-(5 rows)
-
+ERROR:  unary_optr only support +/-, [optr_str=||/]
 SELECT * FROM FLOAT8_TBL;
-          f1          
-----------------------
-                    0
-               1004.3
-               -34.84
- 1.2345678901234e+200
- 1.2345678901234e-200
-(5 rows)
+          f1           
+-----------------------
+                     0
+  1.2345678901234e-200
+  1.2345678901234e+200
+                1004.3
+                -34.84
+                     0
+                -34.84
+               -1004.3
+ -1.2345678901234e+200
+ -1.2345678901234e-200
+(10 rows)
 
 UPDATE FLOAT8_TBL
    SET f1 = FLOAT8_TBL.f1 * '-1'
    WHERE FLOAT8_TBL.f1 > '0.0';
+ERROR:  only support select and create table statement
 SELECT f.f1 * '1e200' from FLOAT8_TBL f;
-ERROR:  value out of range: overflow
+         ?column?         
+--------------------------
+  1.0042999999999999e+203
+              -3.484e+201
+                        0
+          1.2345678901234
+                      inf
+                        0
+              -3.484e+201
+ -1.0042999999999999e+203
+                     -inf
+         -1.2345678901234
+(10 rows)
+
 SELECT f.f1 ^ '1e200' from FLOAT8_TBL f;
-ERROR:  value out of range: overflow
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 SELECT 0 ^ 0 + 0 ^ 1 + 0 ^ 0.0 + 0 ^ 0.5;
- ?column? 
-----------
-        2
-(1 row)
-
+ERROR:  binary_optr only support binary optr = [optr_str=^]
 SELECT ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0' ;
-ERROR:  cannot take logarithm of zero
+ERROR:  function ln does not exist
 SELECT ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0' ;
-ERROR:  cannot take logarithm of a negative number
+ERROR:  function ln does not exist
 SELECT exp(f.f1) from FLOAT8_TBL f;
-ERROR:  value out of range: underflow
+ERROR:  function exp does not exist
 SELECT f.f1 / '0.0' from FLOAT8_TBL f;
-ERROR:  division by zero
+ERROR:  div zero [func=func_14505943978776108846]
 SELECT * FROM FLOAT8_TBL;
           f1           
 -----------------------
                      0
+                1004.3
+                -34.84
+  1.2345678901234e-200
+  1.2345678901234e+200
+                     0
                 -34.84
                -1004.3
  -1.2345678901234e+200
  -1.2345678901234e-200
-(5 rows)
+(10 rows)
 
 -- hyperbolic functions
 -- we run these with extra_float_digits = 0 too, since different platforms
 -- tend to produce results that vary in the last place.
 SELECT sinh(float8 '1');
-      sinh       
------------------
- 1.1752011936438
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT cosh(float8 '1');
-       cosh       
-------------------
- 1.54308063481524
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT tanh(float8 '1');
-       tanh        
--------------------
- 0.761594155955765
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT asinh(float8 '1');
-       asinh       
--------------------
- 0.881373587019543
-(1 row)
-
+ERROR:  function asinh does not exist
 SELECT acosh(float8 '2');
-      acosh       
-------------------
- 1.31695789692482
-(1 row)
-
+ERROR:  function acosh does not exist
 SELECT atanh(float8 '0.5');
-       atanh       
--------------------
- 0.549306144334055
-(1 row)
-
+ERROR:  function atanh does not exist
 -- test Inf/NaN cases for hyperbolic functions
 SELECT sinh(float8 'infinity');
-   sinh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT sinh(float8 '-infinity');
-   sinh    
------------
- -Infinity
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT sinh(float8 'nan');
- sinh 
-------
-  NaN
-(1 row)
-
+ERROR:  function sinh does not exist
 SELECT cosh(float8 'infinity');
-   cosh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT cosh(float8 '-infinity');
-   cosh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT cosh(float8 'nan');
- cosh 
-------
-  NaN
-(1 row)
-
+ERROR:  function cosh does not exist
 SELECT tanh(float8 'infinity');
- tanh 
-------
-    1
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT tanh(float8 '-infinity');
- tanh 
-------
-   -1
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT tanh(float8 'nan');
- tanh 
-------
-  NaN
-(1 row)
-
+ERROR:  function tanh does not exist
 SELECT asinh(float8 'infinity');
-  asinh   
-----------
- Infinity
-(1 row)
-
+ERROR:  function asinh does not exist
 SELECT asinh(float8 '-infinity');
-   asinh   
------------
- -Infinity
-(1 row)
-
+ERROR:  function asinh does not exist
 SELECT asinh(float8 'nan');
- asinh 
--------
-   NaN
-(1 row)
-
+ERROR:  function asinh does not exist
 -- acosh(Inf) should be Inf, but some mingw versions produce NaN, so skip test
 -- SELECT acosh(float8 'infinity');
 SELECT acosh(float8 '-infinity');
-ERROR:  input is out of range
+ERROR:  function acosh does not exist
 SELECT acosh(float8 'nan');
- acosh 
--------
-   NaN
-(1 row)
-
+ERROR:  function acosh does not exist
 SELECT atanh(float8 'infinity');
-ERROR:  input is out of range
+ERROR:  function atanh does not exist
 SELECT atanh(float8 '-infinity');
-ERROR:  input is out of range
+ERROR:  function atanh does not exist
 SELECT atanh(float8 'nan');
- atanh 
--------
-   NaN
-(1 row)
-
+ERROR:  function atanh does not exist
 -- error functions
 -- we run these with extra_float_digits = -1, to get consistently rounded
 -- results on all platforms.
 SET extra_float_digits = -1;
+ERROR:  only support select and create table statement
 SELECT x,
        erf(x),
        erfc(x)
@@ -803,61 +498,35 @@
       (1.2e-17), (2.3e-13), (1.2e-9),
       (0.45), (1.1), (2.1), (3.4), (6), (28),
       (float8 'infinity'), (float8 'nan')) AS t(x);
-     x     |         erf          |        erfc         
------------+----------------------+---------------------
- -Infinity |                   -1 |                   2
-       -28 |                   -1 |                   2
-        -6 |                   -1 |                   2
-      -3.4 |    -0.99999847800664 |     1.9999984780066
-      -2.1 |    -0.99702053334367 |     1.9970205333437
-      -1.1 |    -0.88020506957408 |     1.8802050695741
-     -0.45 |    -0.47548171978692 |     1.4754817197869
-  -1.2e-09 | -1.3540550005146e-09 |     1.0000000013541
-  -2.3e-13 | -2.5952720843197e-13 |     1.0000000000003
-  -1.2e-17 | -1.3540550005146e-17 |                   1
-         0 |                    0 |                   1
-   1.2e-17 |  1.3540550005146e-17 |                   1
-   2.3e-13 |  2.5952720843197e-13 |    0.99999999999974
-   1.2e-09 |  1.3540550005146e-09 |    0.99999999864595
-      0.45 |     0.47548171978692 |    0.52451828021308
-       1.1 |     0.88020506957408 |    0.11979493042592
-       2.1 |     0.99702053334367 |   0.002979466656333
-       3.4 |     0.99999847800664 | 1.5219933628623e-06
-         6 |                    1 | 2.1519736712499e-17
-        28 |                    1 |                   0
-  Infinity |                    1 |                   0
-       NaN |                  NaN |                 NaN
-(22 rows)
-
+ERROR:  function erf does not exist
 RESET extra_float_digits;
+ERROR:  only support select and create table statement
 -- test for over- and underflow
 INSERT INTO FLOAT8_TBL(f1) VALUES ('10e400');
-ERROR:  "10e400" is out of range for type double precision
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('10e400');
-                                           ^
+ERROR:  value "10e400" is out of range for type floating
 INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e400');
-ERROR:  "-10e400" is out of range for type double precision
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e400');
-                                           ^
+ERROR:  value "-10e400" is out of range for type floating
 INSERT INTO FLOAT8_TBL(f1) VALUES ('10e-400');
-ERROR:  "10e-400" is out of range for type double precision
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('10e-400');
-                                           ^
+ERROR:  value "10e-400" is out of range for type floating
 INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e-400');
-ERROR:  "-10e-400" is out of range for type double precision
-LINE 1: INSERT INTO FLOAT8_TBL(f1) VALUES ('-10e-400');
-                                           ^
+ERROR:  value "-10e-400" is out of range for type floating
 DROP TABLE FLOAT8_TBL;
+ERROR:  only support select and create table statement
 -- Check the float8 values exported for use by other tests
 SELECT * FROM FLOAT8_TBL;
           f1           
 -----------------------
                      0
+                1004.3
+                -34.84
+  1.2345678901234e-200
+  1.2345678901234e+200
+                     0
                 -34.84
                -1004.3
  -1.2345678901234e+200
  -1.2345678901234e-200
-(5 rows)
+(10 rows)
 
 -- test edge-case coercions to integer
 SELECT '32767.4'::float8::int2;
@@ -867,7 +536,11 @@
 (1 row)
 
 SELECT '32767.6'::float8::int2;
-ERROR:  smallint out of range
+ int2  
+-------
+ 32767
+(1 row)
+
 SELECT '-32768.4'::float8::int2;
   int2  
 --------
@@ -875,7 +548,11 @@
 (1 row)
 
 SELECT '-32768.6'::float8::int2;
-ERROR:  smallint out of range
+  int2  
+--------
+ -32768
+(1 row)
+
 SELECT '2147483647.4'::float8::int4;
     int4    
 ------------
@@ -883,7 +560,11 @@
 (1 row)
 
 SELECT '2147483647.6'::float8::int4;
-ERROR:  integer out of range
+    int4    
+------------
+ 2147483647
+(1 row)
+
 SELECT '-2147483648.4'::float8::int4;
     int4     
 -------------
@@ -891,60 +572,32 @@
 (1 row)
 
 SELECT '-2147483648.6'::float8::int4;
-ERROR:  integer out of range
-SELECT '9223372036854773760'::float8::int8;
-        int8         
----------------------
- 9223372036854773760
+    int4     
+-------------
+ -2147483648
 (1 row)
 
+SELECT '9223372036854773760'::float8::int8;
+ERROR:  signed char out of range
 SELECT '9223372036854775807'::float8::int8;
-ERROR:  bigint out of range
+ERROR:  signed char out of range
 SELECT '-9223372036854775808.5'::float8::int8;
-         int8         
-----------------------
- -9223372036854775808
-(1 row)
-
+ERROR:  signed char out of range
 SELECT '-9223372036854780000'::float8::int8;
-ERROR:  bigint out of range
+ERROR:  signed char out of range
 -- test exact cases for trigonometric functions in degrees
 SELECT x,
        sind(x),
        sind(x) IN (-1,-0.5,0,0.5,1) AS sind_exact
 FROM (VALUES (0), (30), (90), (150), (180),
       (210), (270), (330), (360)) AS t(x);
-  x  | sind | sind_exact 
------+------+------------
-   0 |    0 | t
-  30 |  0.5 | t
-  90 |    1 | t
- 150 |  0.5 | t
- 180 |    0 | t
- 210 | -0.5 | t
- 270 |   -1 | t
- 330 | -0.5 | t
- 360 |    0 | t
-(9 rows)
-
+ERROR:  function sind does not exist
 SELECT x,
        cosd(x),
        cosd(x) IN (-1,-0.5,0,0.5,1) AS cosd_exact
 FROM (VALUES (0), (60), (90), (120), (180),
       (240), (270), (300), (360)) AS t(x);
-  x  | cosd | cosd_exact 
------+------+------------
-   0 |    1 | t
-  60 |  0.5 | t
-  90 |    0 | t
- 120 | -0.5 | t
- 180 |   -1 | t
- 240 | -0.5 | t
- 270 |    0 | t
- 300 |  0.5 | t
- 360 |    1 | t
-(9 rows)
-
+ERROR:  function cosd does not exist
 SELECT x,
        tand(x),
        tand(x) IN ('-Infinity'::float8,-1,0,
@@ -954,79 +607,49 @@
                    1,'Infinity'::float8) AS cotd_exact
 FROM (VALUES (0), (45), (90), (135), (180),
       (225), (270), (315), (360)) AS t(x);
-  x  |   tand    | tand_exact |   cotd    | cotd_exact 
------+-----------+------------+-----------+------------
-   0 |         0 | t          |  Infinity | t
-  45 |         1 | t          |         1 | t
-  90 |  Infinity | t          |         0 | t
- 135 |        -1 | t          |        -1 | t
- 180 |         0 | t          | -Infinity | t
- 225 |         1 | t          |         1 | t
- 270 | -Infinity | t          |         0 | t
- 315 |        -1 | t          |        -1 | t
- 360 |         0 | t          |  Infinity | t
-(9 rows)
-
+ERROR:  function tand does not exist
 SELECT x,
        asind(x),
        asind(x) IN (-90,-30,0,30,90) AS asind_exact,
        acosd(x),
        acosd(x) IN (0,60,90,120,180) AS acosd_exact
 FROM (VALUES (-1), (-0.5), (0), (0.5), (1)) AS t(x);
-  x   | asind | asind_exact | acosd | acosd_exact 
-------+-------+-------------+-------+-------------
-   -1 |   -90 | t           |   180 | t
- -0.5 |   -30 | t           |   120 | t
-    0 |     0 | t           |    90 | t
-  0.5 |    30 | t           |    60 | t
-    1 |    90 | t           |     0 | t
-(5 rows)
-
+ERROR:  function asind does not exist
 SELECT x,
        atand(x),
        atand(x) IN (-90,-45,0,45,90) AS atand_exact
 FROM (VALUES ('-Infinity'::float8), (-1), (0), (1),
       ('Infinity'::float8)) AS t(x);
-     x     | atand | atand_exact 
------------+-------+-------------
- -Infinity |   -90 | t
-        -1 |   -45 | t
-         0 |     0 | t
-         1 |    45 | t
-  Infinity |    90 | t
-(5 rows)
-
+ERROR:  function atand does not exist
 SELECT x, y,
        atan2d(y, x),
        atan2d(y, x) IN (-90,0,90,180) AS atan2d_exact
 FROM (SELECT 10*cosd(a), 10*sind(a)
       FROM generate_series(0, 360, 90) AS t(a)) AS t(x,y);
-  x  |  y  | atan2d | atan2d_exact 
------+-----+--------+--------------
-  10 |   0 |      0 | t
-   0 |  10 |     90 | t
- -10 |   0 |    180 | t
-   0 | -10 |    -90 | t
-  10 |   0 |      0 | t
-(5 rows)
-
+ERROR:  function generate_series does not exist
 --
 -- test output (and round-trip safety) of various values.
 -- To ensure we're testing what we think we're testing, start with
 -- float values specified by bit patterns (as a useful side effect,
 -- this means we'll fail on non-IEEE platforms).
 create type xfloat8;
+ERROR:  only support select and create table statement
 create function xfloat8in(cstring) returns xfloat8 immutable strict
   language internal as 'int8in';
-NOTICE:  return type xfloat8 is only a shell
+ERROR:  only support select and create table statement
 create function xfloat8out(xfloat8) returns cstring immutable strict
   language internal as 'int8out';
-NOTICE:  argument type xfloat8 is only a shell
+ERROR:  only support select and create table statement
 create type xfloat8 (input = xfloat8in, output = xfloat8out, like = float8);
+ERROR:  only support select and create table statement
 create cast (xfloat8 as float8) without function;
+ERROR:  only support select and create table statement
 create cast (float8 as xfloat8) without function;
+ERROR:  only support select and create table statement
 create cast (xfloat8 as bigint) without function;
+ERROR:  only support select and create table statement
 create cast (bigint as xfloat8) without function;
+ERROR:  only support select and create table statement
 -- float8: seeeeeee eeeeeeee eeeeeeee mmmmmmmm mmmmmmmm(x4)
 -- we don't care to assume the platform's strtod() handles subnormals
 -- correctly; those are "use at your own risk". However we do test
@@ -1051,28 +674,7 @@
   from (select bits::bigint::xfloat8::float8 as flt
           from testdata
 	offset 0) s;
-       ibits        |           flt           
---------------------+-------------------------
- \x0000000000000001 |                  5e-324
- \x0000000000000002 |                  1e-323
- \x0000000000000003 |                1.5e-323
- \x0000000000001000 |             2.0237e-320
- \x0000000100000000 |        2.121995791e-314
- \x0000010000000000 |      5.43230922487e-312
- \x0000010100000000 |      5.45352918278e-312
- \x0000400000000000 |    3.4766779039175e-310
- \x0000400100000000 |    3.4768901034966e-310
- \x0000800000000000 |     6.953355807835e-310
- \x0000800000000001 |   6.95335580783505e-310
- \x00000000000f4240 |           4.940656e-318
- \x00000000016e3600 |         1.18575755e-316
- \x0000008cdcdea440 |     2.989102097996e-312
- \x000ffffffffffff0 | 2.2250738585071935e-308
- \x000ffffffffffff1 |  2.225073858507194e-308
- \x000ffffffffffffe | 2.2250738585072004e-308
- \x000fffffffffffff |  2.225073858507201e-308
-(18 rows)
-
+ERROR:  not implemented type_cast case [to=xfloat8]
 -- round-trip tests
 with testdata(bits) as (values
   (x'0000000000000000'),
@@ -1220,225 +822,7 @@
   from (select bits::bigint::xfloat8::float8 as flt
           from testdata
 	offset 0) s;
-       ibits        |           flt           |          r_flt          |       obits        | correct 
---------------------+-------------------------+-------------------------+--------------------+---------
- \x0000000000000000 |                       0 |                       0 | \x0000000000000000 | t
- \x0010000000000000 | 2.2250738585072014e-308 | 2.2250738585072014e-308 | \x0010000000000000 | t
- \x0010000000000001 |  2.225073858507202e-308 |  2.225073858507202e-308 | \x0010000000000001 | t
- \x0010000000000002 | 2.2250738585072024e-308 | 2.2250738585072024e-308 | \x0010000000000002 | t
- \x0018000000000000 |  3.337610787760802e-308 |  3.337610787760802e-308 | \x0018000000000000 | t
- \x3ddb7cdfd9d7bdba |   9.999999999999999e-11 |   9.999999999999999e-11 | \x3ddb7cdfd9d7bdba | t
- \x3ddb7cdfd9d7bdbb |                   1e-10 |                   1e-10 | \x3ddb7cdfd9d7bdbb | t
- \x3ddb7cdfd9d7bdbc |  1.0000000000000002e-10 |  1.0000000000000002e-10 | \x3ddb7cdfd9d7bdbc | t
- \x3e112e0be826d694 |   9.999999999999999e-10 |   9.999999999999999e-10 | \x3e112e0be826d694 | t
- \x3e112e0be826d695 |                   1e-09 |                   1e-09 | \x3e112e0be826d695 | t
- \x3e112e0be826d696 |  1.0000000000000003e-09 |  1.0000000000000003e-09 | \x3e112e0be826d696 | t
- \x3e45798ee2308c39 |   9.999999999999999e-09 |   9.999999999999999e-09 | \x3e45798ee2308c39 | t
- \x3e45798ee2308c3a |                   1e-08 |                   1e-08 | \x3e45798ee2308c3a | t
- \x3e45798ee2308c3b |  1.0000000000000002e-08 |  1.0000000000000002e-08 | \x3e45798ee2308c3b | t
- \x3e7ad7f29abcaf47 |   9.999999999999998e-08 |   9.999999999999998e-08 | \x3e7ad7f29abcaf47 | t
- \x3e7ad7f29abcaf48 |                   1e-07 |                   1e-07 | \x3e7ad7f29abcaf48 | t
- \x3e7ad7f29abcaf49 |  1.0000000000000001e-07 |  1.0000000000000001e-07 | \x3e7ad7f29abcaf49 | t
- \x3eb0c6f7a0b5ed8c |   9.999999999999997e-07 |   9.999999999999997e-07 | \x3eb0c6f7a0b5ed8c | t
- \x3eb0c6f7a0b5ed8d |                   1e-06 |                   1e-06 | \x3eb0c6f7a0b5ed8d | t
- \x3eb0c6f7a0b5ed8e |  1.0000000000000002e-06 |  1.0000000000000002e-06 | \x3eb0c6f7a0b5ed8e | t
- \x3ee4f8b588e368ef |   9.999999999999997e-06 |   9.999999999999997e-06 | \x3ee4f8b588e368ef | t
- \x3ee4f8b588e368f0 |   9.999999999999999e-06 |   9.999999999999999e-06 | \x3ee4f8b588e368f0 | t
- \x3ee4f8b588e368f1 |                   1e-05 |                   1e-05 | \x3ee4f8b588e368f1 | t
- \x3f1a36e2eb1c432c |   9.999999999999999e-05 |   9.999999999999999e-05 | \x3f1a36e2eb1c432c | t
- \x3f1a36e2eb1c432d |                  0.0001 |                  0.0001 | \x3f1a36e2eb1c432d | t
- \x3f1a36e2eb1c432e |  0.00010000000000000002 |  0.00010000000000000002 | \x3f1a36e2eb1c432e | t
- \x3f50624dd2f1a9fb |   0.0009999999999999998 |   0.0009999999999999998 | \x3f50624dd2f1a9fb | t
- \x3f50624dd2f1a9fc |                   0.001 |                   0.001 | \x3f50624dd2f1a9fc | t
- \x3f50624dd2f1a9fd |   0.0010000000000000002 |   0.0010000000000000002 | \x3f50624dd2f1a9fd | t
- \x3f847ae147ae147a |    0.009999999999999998 |    0.009999999999999998 | \x3f847ae147ae147a | t
- \x3f847ae147ae147b |                    0.01 |                    0.01 | \x3f847ae147ae147b | t
- \x3f847ae147ae147c |    0.010000000000000002 |    0.010000000000000002 | \x3f847ae147ae147c | t
- \x3fb9999999999999 |     0.09999999999999999 |     0.09999999999999999 | \x3fb9999999999999 | t
- \x3fb999999999999a |                     0.1 |                     0.1 | \x3fb999999999999a | t
- \x3fb999999999999b |     0.10000000000000002 |     0.10000000000000002 | \x3fb999999999999b | t
- \x3feffffffffffff0 |      0.9999999999999982 |      0.9999999999999982 | \x3feffffffffffff0 | t
- \x3feffffffffffff1 |      0.9999999999999983 |      0.9999999999999983 | \x3feffffffffffff1 | t
- \x3feffffffffffff2 |      0.9999999999999984 |      0.9999999999999984 | \x3feffffffffffff2 | t
- \x3feffffffffffff3 |      0.9999999999999986 |      0.9999999999999986 | \x3feffffffffffff3 | t
- \x3feffffffffffff4 |      0.9999999999999987 |      0.9999999999999987 | \x3feffffffffffff4 | t
- \x3feffffffffffff5 |      0.9999999999999988 |      0.9999999999999988 | \x3feffffffffffff5 | t
- \x3feffffffffffff6 |      0.9999999999999989 |      0.9999999999999989 | \x3feffffffffffff6 | t
- \x3feffffffffffff7 |       0.999999999999999 |       0.999999999999999 | \x3feffffffffffff7 | t
- \x3feffffffffffff8 |      0.9999999999999991 |      0.9999999999999991 | \x3feffffffffffff8 | t
- \x3feffffffffffff9 |      0.9999999999999992 |      0.9999999999999992 | \x3feffffffffffff9 | t
- \x3feffffffffffffa |      0.9999999999999993 |      0.9999999999999993 | \x3feffffffffffffa | t
- \x3feffffffffffffb |      0.9999999999999994 |      0.9999999999999994 | \x3feffffffffffffb | t
- \x3feffffffffffffc |      0.9999999999999996 |      0.9999999999999996 | \x3feffffffffffffc | t
- \x3feffffffffffffd |      0.9999999999999997 |      0.9999999999999997 | \x3feffffffffffffd | t
- \x3feffffffffffffe |      0.9999999999999998 |      0.9999999999999998 | \x3feffffffffffffe | t
- \x3fefffffffffffff |      0.9999999999999999 |      0.9999999999999999 | \x3fefffffffffffff | t
- \x3ff0000000000000 |                       1 |                       1 | \x3ff0000000000000 | t
- \x3ff0000000000001 |      1.0000000000000002 |      1.0000000000000002 | \x3ff0000000000001 | t
- \x3ff0000000000002 |      1.0000000000000004 |      1.0000000000000004 | \x3ff0000000000002 | t
- \x3ff0000000000003 |      1.0000000000000007 |      1.0000000000000007 | \x3ff0000000000003 | t
- \x3ff0000000000004 |      1.0000000000000009 |      1.0000000000000009 | \x3ff0000000000004 | t
- \x3ff0000000000005 |       1.000000000000001 |       1.000000000000001 | \x3ff0000000000005 | t
- \x3ff0000000000006 |      1.0000000000000013 |      1.0000000000000013 | \x3ff0000000000006 | t
- \x3ff0000000000007 |      1.0000000000000016 |      1.0000000000000016 | \x3ff0000000000007 | t
- \x3ff0000000000008 |      1.0000000000000018 |      1.0000000000000018 | \x3ff0000000000008 | t
- \x3ff0000000000009 |       1.000000000000002 |       1.000000000000002 | \x3ff0000000000009 | t
- \x3ff921fb54442d18 |      1.5707963267948966 |      1.5707963267948966 | \x3ff921fb54442d18 | t
- \x4005bf0a8b14576a |      2.7182818284590455 |      2.7182818284590455 | \x4005bf0a8b14576a | t
- \x400921fb54442d18 |       3.141592653589793 |       3.141592653589793 | \x400921fb54442d18 | t
- \x4023ffffffffffff |       9.999999999999998 |       9.999999999999998 | \x4023ffffffffffff | t
- \x4024000000000000 |                      10 |                      10 | \x4024000000000000 | t
- \x4024000000000001 |      10.000000000000002 |      10.000000000000002 | \x4024000000000001 | t
- \x4058ffffffffffff |       99.99999999999999 |       99.99999999999999 | \x4058ffffffffffff | t
- \x4059000000000000 |                     100 |                     100 | \x4059000000000000 | t
- \x4059000000000001 |      100.00000000000001 |      100.00000000000001 | \x4059000000000001 | t
- \x408f3fffffffffff |       999.9999999999999 |       999.9999999999999 | \x408f3fffffffffff | t
- \x408f400000000000 |                    1000 |                    1000 | \x408f400000000000 | t
- \x408f400000000001 |      1000.0000000000001 |      1000.0000000000001 | \x408f400000000001 | t
- \x40c387ffffffffff |       9999.999999999998 |       9999.999999999998 | \x40c387ffffffffff | t
- \x40c3880000000000 |                   10000 |                   10000 | \x40c3880000000000 | t
- \x40c3880000000001 |      10000.000000000002 |      10000.000000000002 | \x40c3880000000001 | t
- \x40f869ffffffffff |       99999.99999999999 |       99999.99999999999 | \x40f869ffffffffff | t
- \x40f86a0000000000 |                  100000 |                  100000 | \x40f86a0000000000 | t
- \x40f86a0000000001 |      100000.00000000001 |      100000.00000000001 | \x40f86a0000000001 | t
- \x412e847fffffffff |       999999.9999999999 |       999999.9999999999 | \x412e847fffffffff | t
- \x412e848000000000 |                 1000000 |                 1000000 | \x412e848000000000 | t
- \x412e848000000001 |      1000000.0000000001 |      1000000.0000000001 | \x412e848000000001 | t
- \x416312cfffffffff |       9999999.999999998 |       9999999.999999998 | \x416312cfffffffff | t
- \x416312d000000000 |                10000000 |                10000000 | \x416312d000000000 | t
- \x416312d000000001 |      10000000.000000002 |      10000000.000000002 | \x416312d000000001 | t
- \x4197d783ffffffff |       99999999.99999999 |       99999999.99999999 | \x4197d783ffffffff | t
- \x4197d78400000000 |               100000000 |               100000000 | \x4197d78400000000 | t
- \x4197d78400000001 |      100000000.00000001 |      100000000.00000001 | \x4197d78400000001 | t
- \x41cdcd64ffffffff |       999999999.9999999 |       999999999.9999999 | \x41cdcd64ffffffff | t
- \x41cdcd6500000000 |              1000000000 |              1000000000 | \x41cdcd6500000000 | t
- \x41cdcd6500000001 |      1000000000.0000001 |      1000000000.0000001 | \x41cdcd6500000001 | t
- \x4202a05f1fffffff |       9999999999.999998 |       9999999999.999998 | \x4202a05f1fffffff | t
- \x4202a05f20000000 |             10000000000 |             10000000000 | \x4202a05f20000000 | t
- \x4202a05f20000001 |      10000000000.000002 |      10000000000.000002 | \x4202a05f20000001 | t
- \x42374876e7ffffff |       99999999999.99998 |       99999999999.99998 | \x42374876e7ffffff | t
- \x42374876e8000000 |            100000000000 |            100000000000 | \x42374876e8000000 | t
- \x42374876e8000001 |      100000000000.00002 |      100000000000.00002 | \x42374876e8000001 | t
- \x426d1a94a1ffffff |       999999999999.9999 |       999999999999.9999 | \x426d1a94a1ffffff | t
- \x426d1a94a2000000 |           1000000000000 |           1000000000000 | \x426d1a94a2000000 | t
- \x426d1a94a2000001 |      1000000000000.0001 |      1000000000000.0001 | \x426d1a94a2000001 | t
- \x42a2309ce53fffff |       9999999999999.998 |       9999999999999.998 | \x42a2309ce53fffff | t
- \x42a2309ce5400000 |          10000000000000 |          10000000000000 | \x42a2309ce5400000 | t
- \x42a2309ce5400001 |      10000000000000.002 |      10000000000000.002 | \x42a2309ce5400001 | t
- \x42d6bcc41e8fffff |       99999999999999.98 |       99999999999999.98 | \x42d6bcc41e8fffff | t
- \x42d6bcc41e900000 |         100000000000000 |         100000000000000 | \x42d6bcc41e900000 | t
- \x42d6bcc41e900001 |      100000000000000.02 |      100000000000000.02 | \x42d6bcc41e900001 | t
- \x430c6bf52633ffff |       999999999999999.9 |       999999999999999.9 | \x430c6bf52633ffff | t
- \x430c6bf526340000 |                   1e+15 |                   1e+15 | \x430c6bf526340000 | t
- \x430c6bf526340001 |  1.0000000000000001e+15 |  1.0000000000000001e+15 | \x430c6bf526340001 | t
- \x4341c37937e07fff |   9.999999999999998e+15 |   9.999999999999998e+15 | \x4341c37937e07fff | t
- \x4341c37937e08000 |                   1e+16 |                   1e+16 | \x4341c37937e08000 | t
- \x4341c37937e08001 |  1.0000000000000002e+16 |  1.0000000000000002e+16 | \x4341c37937e08001 | t
- \x4376345785d89fff |   9.999999999999998e+16 |   9.999999999999998e+16 | \x4376345785d89fff | t
- \x4376345785d8a000 |                   1e+17 |                   1e+17 | \x4376345785d8a000 | t
- \x4376345785d8a001 |  1.0000000000000002e+17 |  1.0000000000000002e+17 | \x4376345785d8a001 | t
- \x43abc16d674ec7ff |   9.999999999999999e+17 |   9.999999999999999e+17 | \x43abc16d674ec7ff | t
- \x43abc16d674ec800 |                   1e+18 |                   1e+18 | \x43abc16d674ec800 | t
- \x43abc16d674ec801 |  1.0000000000000001e+18 |  1.0000000000000001e+18 | \x43abc16d674ec801 | t
- \x43e158e460913cff |   9.999999999999998e+18 |   9.999999999999998e+18 | \x43e158e460913cff | t
- \x43e158e460913d00 |                   1e+19 |                   1e+19 | \x43e158e460913d00 | t
- \x43e158e460913d01 |  1.0000000000000002e+19 |  1.0000000000000002e+19 | \x43e158e460913d01 | t
- \x4415af1d78b58c3f |   9.999999999999998e+19 |   9.999999999999998e+19 | \x4415af1d78b58c3f | t
- \x4415af1d78b58c40 |                   1e+20 |                   1e+20 | \x4415af1d78b58c40 | t
- \x4415af1d78b58c41 |  1.0000000000000002e+20 |  1.0000000000000002e+20 | \x4415af1d78b58c41 | t
- \x444b1ae4d6e2ef4f |   9.999999999999999e+20 |   9.999999999999999e+20 | \x444b1ae4d6e2ef4f | t
- \x444b1ae4d6e2ef50 |                   1e+21 |                   1e+21 | \x444b1ae4d6e2ef50 | t
- \x444b1ae4d6e2ef51 |  1.0000000000000001e+21 |  1.0000000000000001e+21 | \x444b1ae4d6e2ef51 | t
- \x4480f0cf064dd591 |   9.999999999999998e+21 |   9.999999999999998e+21 | \x4480f0cf064dd591 | t
- \x4480f0cf064dd592 |                   1e+22 |                   1e+22 | \x4480f0cf064dd592 | t
- \x4480f0cf064dd593 |  1.0000000000000002e+22 |  1.0000000000000002e+22 | \x4480f0cf064dd593 | t
- \x44b52d02c7e14af5 |   9.999999999999997e+22 |   9.999999999999997e+22 | \x44b52d02c7e14af5 | t
- \x44b52d02c7e14af6 |   9.999999999999999e+22 |   9.999999999999999e+22 | \x44b52d02c7e14af6 | t
- \x44b52d02c7e14af7 |  1.0000000000000001e+23 |  1.0000000000000001e+23 | \x44b52d02c7e14af7 | t
- \x44ea784379d99db3 |   9.999999999999998e+23 |   9.999999999999998e+23 | \x44ea784379d99db3 | t
- \x44ea784379d99db4 |                   1e+24 |                   1e+24 | \x44ea784379d99db4 | t
- \x44ea784379d99db5 |  1.0000000000000001e+24 |  1.0000000000000001e+24 | \x44ea784379d99db5 | t
- \x45208b2a2c280290 |   9.999999999999999e+24 |   9.999999999999999e+24 | \x45208b2a2c280290 | t
- \x45208b2a2c280291 |                   1e+25 |                   1e+25 | \x45208b2a2c280291 | t
- \x45208b2a2c280292 |  1.0000000000000003e+25 |  1.0000000000000003e+25 | \x45208b2a2c280292 | t
- \x7feffffffffffffe | 1.7976931348623155e+308 | 1.7976931348623155e+308 | \x7feffffffffffffe | t
- \x7fefffffffffffff | 1.7976931348623157e+308 | 1.7976931348623157e+308 | \x7fefffffffffffff | t
- \x4350000000000002 |  1.8014398509481992e+16 |  1.8014398509481992e+16 | \x4350000000000002 | t
- \x4350000000002e06 |  1.8014398509529112e+16 |  1.8014398509529112e+16 | \x4350000000002e06 | t
- \x4352000000000003 |  2.0266198323167244e+16 |  2.0266198323167244e+16 | \x4352000000000003 | t
- \x4352000000000004 |  2.0266198323167248e+16 |  2.0266198323167248e+16 | \x4352000000000004 | t
- \x4358000000000003 |  2.7021597764222988e+16 |  2.7021597764222988e+16 | \x4358000000000003 | t
- \x4358000000000004 |  2.7021597764222992e+16 |  2.7021597764222992e+16 | \x4358000000000004 | t
- \x435f000000000020 |  3.4902897112121472e+16 |  3.4902897112121472e+16 | \x435f000000000020 | t
- \xc350000000000002 | -1.8014398509481992e+16 | -1.8014398509481992e+16 | \xc350000000000002 | t
- \xc350000000002e06 | -1.8014398509529112e+16 | -1.8014398509529112e+16 | \xc350000000002e06 | t
- \xc352000000000003 | -2.0266198323167244e+16 | -2.0266198323167244e+16 | \xc352000000000003 | t
- \xc352000000000004 | -2.0266198323167248e+16 | -2.0266198323167248e+16 | \xc352000000000004 | t
- \xc358000000000003 | -2.7021597764222988e+16 | -2.7021597764222988e+16 | \xc358000000000003 | t
- \xc358000000000004 | -2.7021597764222992e+16 | -2.7021597764222992e+16 | \xc358000000000004 | t
- \xc35f000000000020 | -3.4902897112121472e+16 | -3.4902897112121472e+16 | \xc35f000000000020 | t
- \x42dc12218377de66 |       123456789012345.6 |       123456789012345.6 | \x42dc12218377de66 | t
- \x42a674e79c5fe51f |       12345678901234.56 |       12345678901234.56 | \x42a674e79c5fe51f | t
- \x4271f71fb04cb74c |       1234567890123.456 |       1234567890123.456 | \x4271f71fb04cb74c | t
- \x423cbe991a145879 |       123456789012.3456 |       123456789012.3456 | \x423cbe991a145879 | t
- \x4206fee0e1a9e061 |       12345678901.23456 |       12345678901.23456 | \x4206fee0e1a9e061 | t
- \x41d26580b487e6b4 |       1234567890.123456 |       1234567890.123456 | \x41d26580b487e6b4 | t
- \x419d6f34540ca453 |       123456789.0123456 |       123456789.0123456 | \x419d6f34540ca453 | t
- \x41678c29dcd6e9dc |       12345678.90123456 |       12345678.90123456 | \x41678c29dcd6e9dc | t
- \x4132d687e3df217d |       1234567.890123456 |       1234567.890123456 | \x4132d687e3df217d | t
- \x40fe240c9fcb68c8 |       123456.7890123456 |       123456.7890123456 | \x40fe240c9fcb68c8 | t
- \x40c81cd6e63c53d3 |       12345.67890123456 |       12345.67890123456 | \x40c81cd6e63c53d3 | t
- \x40934a4584fd0fdc |       1234.567890123456 |       1234.567890123456 | \x40934a4584fd0fdc | t
- \x405edd3c07fb4c93 |       123.4567890123456 |       123.4567890123456 | \x405edd3c07fb4c93 | t
- \x4028b0fcd32f7076 |       12.34567890123456 |       12.34567890123456 | \x4028b0fcd32f7076 | t
- \x3ff3c0ca428c59f8 |       1.234567890123456 |       1.234567890123456 | \x3ff3c0ca428c59f8 | t
- \x3e60000000000000 |  2.9802322387695312e-08 |  2.9802322387695312e-08 | \x3e60000000000000 | t
- \xc352bd2668e077c4 | -2.1098088986959632e+16 | -2.1098088986959632e+16 | \xc352bd2668e077c4 | t
- \x434018601510c000 |     9.0608011534336e+15 |     9.0608011534336e+15 | \x434018601510c000 | t
- \x43d055dc36f24000 |   4.708356024711512e+18 |   4.708356024711512e+18 | \x43d055dc36f24000 | t
- \x43e052961c6f8000 |   9.409340012568248e+18 |   9.409340012568248e+18 | \x43e052961c6f8000 | t
- \x3ff3c0ca2a5b1d5d |               1.2345678 |               1.2345678 | \x3ff3c0ca2a5b1d5d | t
- \x4830f0cf064dd592 |   5.764607523034235e+39 |   5.764607523034235e+39 | \x4830f0cf064dd592 | t
- \x4840f0cf064dd592 |   1.152921504606847e+40 |   1.152921504606847e+40 | \x4840f0cf064dd592 | t
- \x4850f0cf064dd592 |   2.305843009213694e+40 |   2.305843009213694e+40 | \x4850f0cf064dd592 | t
- \x3ff3333333333333 |                     1.2 |                     1.2 | \x3ff3333333333333 | t
- \x3ff3ae147ae147ae |                    1.23 |                    1.23 | \x3ff3ae147ae147ae | t
- \x3ff3be76c8b43958 |                   1.234 |                   1.234 | \x3ff3be76c8b43958 | t
- \x3ff3c083126e978d |                  1.2345 |                  1.2345 | \x3ff3c083126e978d | t
- \x3ff3c0c1fc8f3238 |                 1.23456 |                 1.23456 | \x3ff3c0c1fc8f3238 | t
- \x3ff3c0c9539b8887 |                1.234567 |                1.234567 | \x3ff3c0c9539b8887 | t
- \x3ff3c0ca2a5b1d5d |               1.2345678 |               1.2345678 | \x3ff3c0ca2a5b1d5d | t
- \x3ff3c0ca4283de1b |              1.23456789 |              1.23456789 | \x3ff3c0ca4283de1b | t
- \x3ff3c0ca43db770a |             1.234567895 |             1.234567895 | \x3ff3c0ca43db770a | t
- \x3ff3c0ca428abd53 |            1.2345678901 |            1.2345678901 | \x3ff3c0ca428abd53 | t
- \x3ff3c0ca428c1d2b |           1.23456789012 |           1.23456789012 | \x3ff3c0ca428c1d2b | t
- \x3ff3c0ca428c51f2 |          1.234567890123 |          1.234567890123 | \x3ff3c0ca428c51f2 | t
- \x3ff3c0ca428c58fc |         1.2345678901234 |         1.2345678901234 | \x3ff3c0ca428c58fc | t
- \x3ff3c0ca428c59dd |        1.23456789012345 |        1.23456789012345 | \x3ff3c0ca428c59dd | t
- \x3ff3c0ca428c59f8 |       1.234567890123456 |       1.234567890123456 | \x3ff3c0ca428c59f8 | t
- \x3ff3c0ca428c59fb |      1.2345678901234567 |      1.2345678901234567 | \x3ff3c0ca428c59fb | t
- \x40112e0be8047a7d |             4.294967294 |             4.294967294 | \x40112e0be8047a7d | t
- \x40112e0be815a889 |             4.294967295 |             4.294967295 | \x40112e0be815a889 | t
- \x40112e0be826d695 |             4.294967296 |             4.294967296 | \x40112e0be826d695 | t
- \x40112e0be83804a1 |             4.294967297 |             4.294967297 | \x40112e0be83804a1 | t
- \x40112e0be84932ad |             4.294967298 |             4.294967298 | \x40112e0be84932ad | t
- \x0040000000000000 | 1.7800590868057611e-307 | 1.7800590868057611e-307 | \x0040000000000000 | t
- \x007fffffffffffff | 2.8480945388892175e-306 | 2.8480945388892175e-306 | \x007fffffffffffff | t
- \x0290000000000000 |  2.446494580089078e-296 |  2.446494580089078e-296 | \x0290000000000000 | t
- \x029fffffffffffff | 4.8929891601781557e-296 | 4.8929891601781557e-296 | \x029fffffffffffff | t
- \x4350000000000000 |  1.8014398509481984e+16 |  1.8014398509481984e+16 | \x4350000000000000 | t
- \x435fffffffffffff |  3.6028797018963964e+16 |  3.6028797018963964e+16 | \x435fffffffffffff | t
- \x1330000000000000 |  2.900835519859558e-216 |  2.900835519859558e-216 | \x1330000000000000 | t
- \x133fffffffffffff |  5.801671039719115e-216 |  5.801671039719115e-216 | \x133fffffffffffff | t
- \x3a6fa7161a4d6e0c |   3.196104012172126e-27 |   3.196104012172126e-27 | \x3a6fa7161a4d6e0c | t
-(209 rows)
-
+ERROR:  not implemented type_cast case [to=xfloat8]
 -- clean up, lest opr_sanity complain
 drop type xfloat8 cascade;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to function xfloat8in(cstring)
-drop cascades to function xfloat8out(xfloat8)
-drop cascades to cast from xfloat8 to double precision
-drop cascades to cast from double precision to xfloat8
-drop cascades to cast from xfloat8 to bigint
-drop cascades to cast from bigint to xfloat8
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/pg_regress_input/expected/date.out /home/longqimin/pg_regress_input/results/date.out
--- /home/longqimin/pg_regress_input/expected/date.out	2024-02-27 09:30:35.079460297 +0800
+++ /home/longqimin/pg_regress_input/results/date.out	2024-03-08 13:59:14.810479455 +0800
@@ -10,9 +10,6 @@
 INSERT INTO DATE_TBL VALUES ('1996-03-02');
 INSERT INTO DATE_TBL VALUES ('1997-02-28');
 INSERT INTO DATE_TBL VALUES ('1997-02-29');
-ERROR:  date/time field value out of range: "1997-02-29"
-LINE 1: INSERT INTO DATE_TBL VALUES ('1997-02-29');
-                                     ^
 INSERT INTO DATE_TBL VALUES ('1997-03-01');
 INSERT INTO DATE_TBL VALUES ('1997-03-02');
 INSERT INTO DATE_TBL VALUES ('2000-04-01');
@@ -23,61 +20,61 @@
 INSERT INTO DATE_TBL VALUES ('2040-04-10');
 INSERT INTO DATE_TBL VALUES ('2040-04-10 BC');
 SELECT f1 FROM DATE_TBL;
-      f1       
----------------
- 04-09-1957
- 06-13-1957
- 02-28-1996
- 02-29-1996
- 03-01-1996
- 03-02-1996
- 02-28-1997
- 03-01-1997
- 03-02-1997
- 04-01-2000
- 04-02-2000
- 04-03-2000
- 04-08-2038
- 04-09-2039
- 04-10-2040
- 04-10-2040 BC
-(16 rows)
+     f1      
+-------------
+ 2000-04-03
+ 2038-04-08
+ 1997-03-01
+ 1996-03-01
+ 1996-03-02
+ 1997-02-28
+ -2039-04-10
+ 1997-03-02
+ 1996-02-29
+ 2000-04-01
+ 1997-03-01
+ 2040-04-10
+ 1957-06-13
+ 1996-02-28
+ 1957-04-09
+ 2039-04-09
+ 2000-04-02
+(17 rows)
 
 SELECT f1 FROM DATE_TBL WHERE f1 < '2000-01-01';
-      f1       
----------------
- 04-09-1957
- 06-13-1957
- 02-28-1996
- 02-29-1996
- 03-01-1996
- 03-02-1996
- 02-28-1997
- 03-01-1997
- 03-02-1997
- 04-10-2040 BC
-(10 rows)
+     f1      
+-------------
+ 1996-03-02
+ 1996-03-01
+ 1997-03-01
+ 1996-02-29
+ -2039-04-10
+ 1997-02-28
+ 1997-03-02
+ 1997-03-01
+ 1996-02-28
+ 1957-06-13
+ 1957-04-09
+(11 rows)
 
 SELECT f1 FROM DATE_TBL
   WHERE f1 BETWEEN '2000-01-01' AND '2001-01-01';
      f1     
 ------------
- 04-01-2000
- 04-02-2000
- 04-03-2000
+ 2000-04-03
+ 2000-04-02
+ 2000-04-01
 (3 rows)
 
 --
 -- Check all the documented input formats
 --
 SET datestyle TO iso;  -- display results in ISO
+ERROR:  only support select and create table statement
 SET datestyle TO ymd;
+ERROR:  only support select and create table statement
 SELECT date 'January 8, 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "January 8, 1999"
 SELECT date '1999-01-08';
     date    
 ------------
@@ -91,61 +88,37 @@
 (1 row)
 
 SELECT date '1/8/1999';
-ERROR:  date/time field value out of range: "1/8/1999"
-LINE 1: SELECT date '1/8/1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '1/18/1999';
-ERROR:  date/time field value out of range: "1/18/1999"
-LINE 1: SELECT date '1/18/1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '18/1/1999';
-ERROR:  date/time field value out of range: "18/1/1999"
-LINE 1: SELECT date '18/1/1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '01/02/03';
-    date    
-------------
- 2001-02-03
-(1 row)
-
-SELECT date '19990108';
     date    
 ------------
  1999-01-08
 (1 row)
 
-SELECT date '990108';
+SELECT date '1/18/1999';
     date    
 ------------
- 1999-01-08
+ 1999-01-18
 (1 row)
 
-SELECT date '1999.008';
+SELECT date '18/1/1999';
     date    
 ------------
- 1999-01-08
+ 1999-01-18
 (1 row)
 
+SELECT date '01/02/03';
+ERROR:  invalid date literal: "01/02/03"
+SELECT date '19990108';
+ERROR:  invalid date literal: "19990108"
+SELECT date '990108';
+ERROR:  invalid date literal: "990108"
+SELECT date '1999.008';
+ERROR:  invalid date literal: "1999.008"
 SELECT date 'J2451187';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "J2451187"
 SELECT date 'January 8, 99 BC';
-ERROR:  date/time field value out of range: "January 8, 99 BC"
-LINE 1: SELECT date 'January 8, 99 BC';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "January 8, 99 BC"
 SELECT date '99-Jan-08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "99-Jan-08"
 SELECT date '1999-Jan-08';
     date    
 ------------
@@ -153,10 +126,7 @@
 (1 row)
 
 SELECT date '08-Jan-99';
-ERROR:  date/time field value out of range: "08-Jan-99"
-LINE 1: SELECT date '08-Jan-99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "08-Jan-99"
 SELECT date '08-Jan-1999';
     date    
 ------------
@@ -164,10 +134,7 @@
 (1 row)
 
 SELECT date 'Jan-08-99';
-ERROR:  date/time field value out of range: "Jan-08-99"
-LINE 1: SELECT date 'Jan-08-99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "Jan-08-99"
 SELECT date 'Jan-08-1999';
     date    
 ------------
@@ -175,97 +142,51 @@
 (1 row)
 
 SELECT date '99-08-Jan';
-ERROR:  invalid input syntax for type date: "99-08-Jan"
-LINE 1: SELECT date '99-08-Jan';
-                    ^
+ERROR:  invalid date literal: "99-08-Jan"
 SELECT date '1999-08-Jan';
-ERROR:  invalid input syntax for type date: "1999-08-Jan"
-LINE 1: SELECT date '1999-08-Jan';
-                    ^
+ERROR:  invalid date literal: "1999-08-Jan"
 SELECT date '99 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "99 Jan 08"
 SELECT date '1999 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 Jan 08"
 SELECT date '08 Jan 99';
-ERROR:  date/time field value out of range: "08 Jan 99"
-LINE 1: SELECT date '08 Jan 99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "08 Jan 99"
 SELECT date '08 Jan 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 Jan 1999"
 SELECT date 'Jan 08 99';
-ERROR:  date/time field value out of range: "Jan 08 99"
-LINE 1: SELECT date 'Jan 08 99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "Jan 08 99"
 SELECT date 'Jan 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan 08 1999"
 SELECT date '99 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "99 08 Jan"
 SELECT date '1999 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 08 Jan"
 SELECT date '99-01-08';
+ERROR:  invalid date literal: "99-01-08"
+SELECT date '1999-01-08';
     date    
 ------------
  1999-01-08
 (1 row)
 
-SELECT date '1999-01-08';
+SELECT date '08-01-99';
+ERROR:  invalid date literal: "08-01-99"
+SELECT date '08-01-1999';
     date    
 ------------
- 1999-01-08
+ 1999-08-01
 (1 row)
 
-SELECT date '08-01-99';
-ERROR:  date/time field value out of range: "08-01-99"
-LINE 1: SELECT date '08-01-99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '08-01-1999';
-ERROR:  date/time field value out of range: "08-01-1999"
-LINE 1: SELECT date '08-01-1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
 SELECT date '01-08-99';
-ERROR:  date/time field value out of range: "01-08-99"
-LINE 1: SELECT date '01-08-99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "01-08-99"
 SELECT date '01-08-1999';
-ERROR:  date/time field value out of range: "01-08-1999"
-LINE 1: SELECT date '01-08-1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '99-08-01';
     date    
 ------------
- 1999-08-01
+ 1999-01-08
 (1 row)
 
+SELECT date '99-08-01';
+ERROR:  invalid date literal: "99-08-01"
 SELECT date '1999-08-01';
     date    
 ------------
@@ -273,56 +194,25 @@
 (1 row)
 
 SELECT date '99 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "99 01 08"
 SELECT date '1999 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 01 08"
 SELECT date '08 01 99';
-ERROR:  date/time field value out of range: "08 01 99"
-LINE 1: SELECT date '08 01 99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "08 01 99"
 SELECT date '08 01 1999';
-ERROR:  date/time field value out of range: "08 01 1999"
-LINE 1: SELECT date '08 01 1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "08 01 1999"
 SELECT date '01 08 99';
-ERROR:  date/time field value out of range: "01 08 99"
-LINE 1: SELECT date '01 08 99';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "01 08 99"
 SELECT date '01 08 1999';
-ERROR:  date/time field value out of range: "01 08 1999"
-LINE 1: SELECT date '01 08 1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "01 08 1999"
 SELECT date '99 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "99 08 01"
 SELECT date '1999 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "1999 08 01"
 SET datestyle TO dmy;
+ERROR:  only support select and create table statement
 SELECT date 'January 8, 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "January 8, 1999"
 SELECT date '1999-01-08';
     date    
 ------------
@@ -338,61 +228,35 @@
 SELECT date '1/8/1999';
     date    
 ------------
- 1999-08-01
+ 1999-01-08
 (1 row)
 
 SELECT date '1/18/1999';
-ERROR:  date/time field value out of range: "1/18/1999"
-LINE 1: SELECT date '1/18/1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '18/1/1999';
     date    
 ------------
  1999-01-18
 (1 row)
 
-SELECT date '01/02/03';
+SELECT date '18/1/1999';
     date    
 ------------
- 2003-02-01
+ 1999-01-18
 (1 row)
 
+SELECT date '01/02/03';
+ERROR:  invalid date literal: "01/02/03"
 SELECT date '19990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "19990108"
 SELECT date '990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "990108"
 SELECT date '1999.008';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999.008"
 SELECT date 'J2451187';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "J2451187"
 SELECT date 'January 8, 99 BC';
-     date      
----------------
- 0099-01-08 BC
-(1 row)
-
+ERROR:  invalid date literal: "January 8, 99 BC"
 SELECT date '99-Jan-08';
-ERROR:  date/time field value out of range: "99-Jan-08"
-LINE 1: SELECT date '99-Jan-08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99-Jan-08"
 SELECT date '1999-Jan-08';
     date    
 ------------
@@ -400,11 +264,7 @@
 (1 row)
 
 SELECT date '08-Jan-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08-Jan-99"
 SELECT date '08-Jan-1999';
     date    
 ------------
@@ -412,11 +272,7 @@
 (1 row)
 
 SELECT date 'Jan-08-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan-08-99"
 SELECT date 'Jan-08-1999';
     date    
 ------------
@@ -424,63 +280,27 @@
 (1 row)
 
 SELECT date '99-08-Jan';
-ERROR:  invalid input syntax for type date: "99-08-Jan"
-LINE 1: SELECT date '99-08-Jan';
-                    ^
+ERROR:  invalid date literal: "99-08-Jan"
 SELECT date '1999-08-Jan';
-ERROR:  invalid input syntax for type date: "1999-08-Jan"
-LINE 1: SELECT date '1999-08-Jan';
-                    ^
+ERROR:  invalid date literal: "1999-08-Jan"
 SELECT date '99 Jan 08';
-ERROR:  date/time field value out of range: "99 Jan 08"
-LINE 1: SELECT date '99 Jan 08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99 Jan 08"
 SELECT date '1999 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 Jan 08"
 SELECT date '08 Jan 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 Jan 99"
 SELECT date '08 Jan 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 Jan 1999"
 SELECT date 'Jan 08 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan 08 99"
 SELECT date 'Jan 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan 08 1999"
 SELECT date '99 08 Jan';
-ERROR:  invalid input syntax for type date: "99 08 Jan"
-LINE 1: SELECT date '99 08 Jan';
-                    ^
+ERROR:  invalid date literal: "99 08 Jan"
 SELECT date '1999 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 08 Jan"
 SELECT date '99-01-08';
-ERROR:  date/time field value out of range: "99-01-08"
-LINE 1: SELECT date '99-01-08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99-01-08"
 SELECT date '1999-01-08';
     date    
 ------------
@@ -488,34 +308,23 @@
 (1 row)
 
 SELECT date '08-01-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08-01-99"
 SELECT date '08-01-1999';
     date    
 ------------
- 1999-01-08
-(1 row)
-
-SELECT date '01-08-99';
-    date    
-------------
  1999-08-01
 (1 row)
 
+SELECT date '01-08-99';
+ERROR:  invalid date literal: "01-08-99"
 SELECT date '01-08-1999';
     date    
 ------------
- 1999-08-01
+ 1999-01-08
 (1 row)
 
 SELECT date '99-08-01';
-ERROR:  date/time field value out of range: "99-08-01"
-LINE 1: SELECT date '99-08-01';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99-08-01"
 SELECT date '1999-08-01';
     date    
 ------------
@@ -523,58 +332,25 @@
 (1 row)
 
 SELECT date '99 01 08';
-ERROR:  date/time field value out of range: "99 01 08"
-LINE 1: SELECT date '99 01 08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99 01 08"
 SELECT date '1999 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 01 08"
 SELECT date '08 01 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 01 99"
 SELECT date '08 01 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 01 1999"
 SELECT date '01 08 99';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "01 08 99"
 SELECT date '01 08 1999';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "01 08 1999"
 SELECT date '99 08 01';
-ERROR:  date/time field value out of range: "99 08 01"
-LINE 1: SELECT date '99 08 01';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99 08 01"
 SELECT date '1999 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "1999 08 01"
 SET datestyle TO mdy;
+ERROR:  only support select and create table statement
 SELECT date 'January 8, 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "January 8, 1999"
 SELECT date '1999-01-08';
     date    
 ------------
@@ -600,51 +376,25 @@
 (1 row)
 
 SELECT date '18/1/1999';
-ERROR:  date/time field value out of range: "18/1/1999"
-LINE 1: SELECT date '18/1/1999';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
-SELECT date '01/02/03';
     date    
 ------------
- 2003-01-02
+ 1999-01-18
 (1 row)
 
+SELECT date '01/02/03';
+ERROR:  invalid date literal: "01/02/03"
 SELECT date '19990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "19990108"
 SELECT date '990108';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "990108"
 SELECT date '1999.008';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999.008"
 SELECT date 'J2451187';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "J2451187"
 SELECT date 'January 8, 99 BC';
-     date      
----------------
- 0099-01-08 BC
-(1 row)
-
+ERROR:  invalid date literal: "January 8, 99 BC"
 SELECT date '99-Jan-08';
-ERROR:  date/time field value out of range: "99-Jan-08"
-LINE 1: SELECT date '99-Jan-08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99-Jan-08"
 SELECT date '1999-Jan-08';
     date    
 ------------
@@ -652,11 +402,7 @@
 (1 row)
 
 SELECT date '08-Jan-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08-Jan-99"
 SELECT date '08-Jan-1999';
     date    
 ------------
@@ -664,11 +410,7 @@
 (1 row)
 
 SELECT date 'Jan-08-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan-08-99"
 SELECT date 'Jan-08-1999';
     date    
 ------------
@@ -676,62 +418,27 @@
 (1 row)
 
 SELECT date '99-08-Jan';
-ERROR:  invalid input syntax for type date: "99-08-Jan"
-LINE 1: SELECT date '99-08-Jan';
-                    ^
+ERROR:  invalid date literal: "99-08-Jan"
 SELECT date '1999-08-Jan';
-ERROR:  invalid input syntax for type date: "1999-08-Jan"
-LINE 1: SELECT date '1999-08-Jan';
-                    ^
+ERROR:  invalid date literal: "1999-08-Jan"
 SELECT date '99 Jan 08';
-ERROR:  invalid input syntax for type date: "99 Jan 08"
-LINE 1: SELECT date '99 Jan 08';
-                    ^
+ERROR:  invalid date literal: "99 Jan 08"
 SELECT date '1999 Jan 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 Jan 08"
 SELECT date '08 Jan 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 Jan 99"
 SELECT date '08 Jan 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "08 Jan 1999"
 SELECT date 'Jan 08 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan 08 99"
 SELECT date 'Jan 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "Jan 08 1999"
 SELECT date '99 08 Jan';
-ERROR:  invalid input syntax for type date: "99 08 Jan"
-LINE 1: SELECT date '99 08 Jan';
-                    ^
+ERROR:  invalid date literal: "99 08 Jan"
 SELECT date '1999 08 Jan';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 08 Jan"
 SELECT date '99-01-08';
-ERROR:  date/time field value out of range: "99-01-08"
-LINE 1: SELECT date '99-01-08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99-01-08"
 SELECT date '1999-01-08';
     date    
 ------------
@@ -739,11 +446,7 @@
 (1 row)
 
 SELECT date '08-01-99';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "08-01-99"
 SELECT date '08-01-1999';
     date    
 ------------
@@ -751,11 +454,7 @@
 (1 row)
 
 SELECT date '01-08-99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "01-08-99"
 SELECT date '01-08-1999';
     date    
 ------------
@@ -763,10 +462,7 @@
 (1 row)
 
 SELECT date '99-08-01';
-ERROR:  date/time field value out of range: "99-08-01"
-LINE 1: SELECT date '99-08-01';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99-08-01"
 SELECT date '1999-08-01';
     date    
 ------------
@@ -774,186 +470,71 @@
 (1 row)
 
 SELECT date '99 01 08';
-ERROR:  date/time field value out of range: "99 01 08"
-LINE 1: SELECT date '99 01 08';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99 01 08"
 SELECT date '1999 01 08';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "1999 01 08"
 SELECT date '08 01 99';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "08 01 99"
 SELECT date '08 01 1999';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "08 01 1999"
 SELECT date '01 08 99';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "01 08 99"
 SELECT date '01 08 1999';
-    date    
-------------
- 1999-01-08
-(1 row)
-
+ERROR:  invalid date literal: "01 08 1999"
 SELECT date '99 08 01';
-ERROR:  date/time field value out of range: "99 08 01"
-LINE 1: SELECT date '99 08 01';
-                    ^
-HINT:  Perhaps you need a different "datestyle" setting.
+ERROR:  invalid date literal: "99 08 01"
 SELECT date '1999 08 01';
-    date    
-------------
- 1999-08-01
-(1 row)
-
+ERROR:  invalid date literal: "1999 08 01"
 -- Check upper and lower limits of date range
 SELECT date '4714-11-24 BC';
-     date      
----------------
- 4714-11-24 BC
+    date     
+-------------
+ -4713-11-24
 (1 row)
 
 SELECT date '4714-11-23 BC';  -- out of range
-ERROR:  date out of range: "4714-11-23 BC"
-LINE 1: SELECT date '4714-11-23 BC';
-                    ^
-SELECT date '5874897-12-31';
-     date      
----------------
- 5874897-12-31
+    date     
+-------------
+ -4713-11-23
 (1 row)
 
+SELECT date '5874897-12-31';
+ERROR:  invalid date literal: "5874897-12-31"
 SELECT date '5874898-01-01';  -- out of range
-ERROR:  date out of range: "5874898-01-01"
-LINE 1: SELECT date '5874898-01-01';
-                    ^
+ERROR:  invalid date literal: "5874898-01-01"
 -- Test non-error-throwing API
 SELECT pg_input_is_valid('now', 'date');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('garbage', 'date');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('6874898-01-01', 'date');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('garbage', 'date');
-                    message                    | detail | hint | sql_error_code 
------------------------------------------------+--------+------+----------------
- invalid input syntax for type date: "garbage" |        |      | 22007
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('6874898-01-01', 'date');
-              message               | detail | hint | sql_error_code 
-------------------------------------+--------+------+----------------
- date out of range: "6874898-01-01" |        |      | 22008
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 RESET datestyle;
+ERROR:  only support select and create table statement
 --
 -- Simple math
 -- Leave most of it for the horology tests
 --
 SELECT f1 - date '2000-01-01' AS "Days From 2K" FROM DATE_TBL;
- Days From 2K 
---------------
-       -15607
-       -15542
-        -1403
-        -1402
-        -1401
-        -1400
-        -1037
-        -1036
-        -1035
-           91
-           92
-           93
-        13977
-        14343
-        14710
-     -1475115
-(16 rows)
-
+ERROR:  operator does not exist: Date SUB Date
 SELECT f1 - date 'epoch' AS "Days From Epoch" FROM DATE_TBL;
- Days From Epoch 
------------------
-           -4650
-           -4585
-            9554
-            9555
-            9556
-            9557
-            9920
-            9921
-            9922
-           11048
-           11049
-           11050
-           24934
-           25300
-           25667
-        -1464158
-(16 rows)
-
+ERROR:  invalid date literal: "epoch"
 SELECT date 'yesterday' - date 'today' AS "One day";
- One day 
----------
-      -1
-(1 row)
-
+ERROR:  invalid date literal: "yesterday"
 SELECT date 'today' - date 'tomorrow' AS "One day";
- One day 
----------
-      -1
-(1 row)
-
+ERROR:  invalid date literal: "today"
 SELECT date 'yesterday' - date 'tomorrow' AS "Two days";
- Two days 
-----------
-       -2
-(1 row)
-
+ERROR:  invalid date literal: "yesterday"
 SELECT date 'tomorrow' - date 'today' AS "One day";
- One day 
----------
-       1
-(1 row)
-
+ERROR:  invalid date literal: "tomorrow"
 SELECT date 'today' - date 'yesterday' AS "One day";
- One day 
----------
-       1
-(1 row)
-
+ERROR:  invalid date literal: "today"
 SELECT date 'tomorrow' - date 'yesterday' AS "Two days";
- Two days 
-----------
-        2
-(1 row)
-
+ERROR:  invalid date literal: "tomorrow"
 --
 -- test extract!
 --
@@ -973,562 +554,227 @@
     date_part('julian', f1) AS julian,
     date_part('epoch', f1) AS epoch
     FROM date_tbl;
-     date      | year  | month | day | quarter | decade | century | millennium | isoyear | week | dow | isodow | doy | julian  |     epoch     
----------------+-------+-------+-----+---------+--------+---------+------------+---------+------+-----+--------+-----+---------+---------------
- 04-09-1957    |  1957 |     4 |   9 |       2 |    195 |      20 |          2 |    1957 |   15 |   2 |      2 |  99 | 2435938 |    -401760000
- 06-13-1957    |  1957 |     6 |  13 |       2 |    195 |      20 |          2 |    1957 |   24 |   4 |      4 | 164 | 2436003 |    -396144000
- 02-28-1996    |  1996 |     2 |  28 |       1 |    199 |      20 |          2 |    1996 |    9 |   3 |      3 |  59 | 2450142 |     825465600
- 02-29-1996    |  1996 |     2 |  29 |       1 |    199 |      20 |          2 |    1996 |    9 |   4 |      4 |  60 | 2450143 |     825552000
- 03-01-1996    |  1996 |     3 |   1 |       1 |    199 |      20 |          2 |    1996 |    9 |   5 |      5 |  61 | 2450144 |     825638400
- 03-02-1996    |  1996 |     3 |   2 |       1 |    199 |      20 |          2 |    1996 |    9 |   6 |      6 |  62 | 2450145 |     825724800
- 02-28-1997    |  1997 |     2 |  28 |       1 |    199 |      20 |          2 |    1997 |    9 |   5 |      5 |  59 | 2450508 |     857088000
- 03-01-1997    |  1997 |     3 |   1 |       1 |    199 |      20 |          2 |    1997 |    9 |   6 |      6 |  60 | 2450509 |     857174400
- 03-02-1997    |  1997 |     3 |   2 |       1 |    199 |      20 |          2 |    1997 |    9 |   0 |      7 |  61 | 2450510 |     857260800
- 04-01-2000    |  2000 |     4 |   1 |       2 |    200 |      20 |          2 |    2000 |   13 |   6 |      6 |  92 | 2451636 |     954547200
- 04-02-2000    |  2000 |     4 |   2 |       2 |    200 |      20 |          2 |    2000 |   13 |   0 |      7 |  93 | 2451637 |     954633600
- 04-03-2000    |  2000 |     4 |   3 |       2 |    200 |      20 |          2 |    2000 |   14 |   1 |      1 |  94 | 2451638 |     954720000
- 04-08-2038    |  2038 |     4 |   8 |       2 |    203 |      21 |          3 |    2038 |   14 |   4 |      4 |  98 | 2465522 |    2154297600
- 04-09-2039    |  2039 |     4 |   9 |       2 |    203 |      21 |          3 |    2039 |   14 |   6 |      6 |  99 | 2465888 |    2185920000
- 04-10-2040    |  2040 |     4 |  10 |       2 |    204 |      21 |          3 |    2040 |   15 |   2 |      2 | 101 | 2466255 |    2217628800
- 04-10-2040 BC | -2040 |     4 |  10 |       2 |   -204 |     -21 |         -3 |   -2040 |   15 |   1 |      1 | 100 |  976430 | -126503251200
-(16 rows)
-
+ERROR:  function date_part does not exist
 --
 -- epoch
 --
 SELECT EXTRACT(EPOCH FROM DATE        '1970-01-01');     --  0
- extract 
----------
-       0
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- century
 --
 SELECT EXTRACT(CENTURY FROM DATE '0101-12-31 BC'); -- -2
- extract 
----------
-      -2
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '0100-12-31 BC'); -- -1
- extract 
----------
-      -1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC'); -- -1
- extract 
----------
-      -1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '0001-01-01');    --  1
- extract 
----------
-       1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD'); --  1
- extract 
----------
-       1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '1900-12-31');    -- 19
- extract 
----------
-      19
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '1901-01-01');    -- 20
- extract 
----------
-      20
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '2000-12-31');    -- 20
- extract 
----------
-      20
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM DATE '2001-01-01');    -- 21
- extract 
----------
-      21
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY FROM CURRENT_DATE)>=21 AS True;     -- true
- true 
-------
- t
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- millennium
 --
 SELECT EXTRACT(MILLENNIUM FROM DATE '0001-12-31 BC'); -- -1
- extract 
----------
-      -1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM FROM DATE '0001-01-01 AD'); --  1
- extract 
----------
-       1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM FROM DATE '1000-12-31');    --  1
- extract 
----------
-       1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM FROM DATE '1001-01-01');    --  2
- extract 
----------
-       2
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM FROM DATE '2000-12-31');    --  2
- extract 
----------
-       2
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM FROM DATE '2001-01-01');    --  3
- extract 
----------
-       3
-(1 row)
-
+ERROR:  function extract does not exist
 -- next test to be fixed on the turn of the next millennium;-)
 SELECT EXTRACT(MILLENNIUM FROM CURRENT_DATE);         --  3
- extract 
----------
-       3
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- decade
 --
 SELECT EXTRACT(DECADE FROM DATE '1994-12-25');    -- 199
- extract 
----------
-     199
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE FROM DATE '0010-01-01');    --   1
- extract 
----------
-       1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE FROM DATE '0009-12-31');    --   0
- extract 
----------
-       0
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE FROM DATE '0001-01-01 BC'); --   0
- extract 
----------
-       0
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE FROM DATE '0002-12-31 BC'); --  -1
- extract 
----------
-      -1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE FROM DATE '0011-01-01 BC'); --  -1
- extract 
----------
-      -1
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE FROM DATE '0012-12-31 BC'); --  -2
- extract 
----------
-      -2
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- all possible fields
 --
 SELECT EXTRACT(MICROSECONDS  FROM DATE '2020-08-11');
-ERROR:  unit "microseconds" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLISECONDS  FROM DATE '2020-08-11');
-ERROR:  unit "milliseconds" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(SECOND        FROM DATE '2020-08-11');
-ERROR:  unit "second" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(MINUTE        FROM DATE '2020-08-11');
-ERROR:  unit "minute" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(HOUR          FROM DATE '2020-08-11');
-ERROR:  unit "hour" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(DAY           FROM DATE '2020-08-11');
- extract 
----------
-      11
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MONTH         FROM DATE '2020-08-11');
- extract 
----------
-       8
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(YEAR          FROM DATE '2020-08-11');
- extract 
----------
-    2020
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(YEAR          FROM DATE '2020-08-11 BC');
- extract 
----------
-   -2020
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE        FROM DATE '2020-08-11');
- extract 
----------
-     202
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY       FROM DATE '2020-08-11');
- extract 
----------
-      21
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM    FROM DATE '2020-08-11');
- extract 
----------
-       3
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11');
- extract 
----------
-    2020
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11 BC');
- extract 
----------
-   -2020
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(QUARTER       FROM DATE '2020-08-11');
- extract 
----------
-       3
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(WEEK          FROM DATE '2020-08-11');
- extract 
----------
-      33
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DOW           FROM DATE '2020-08-11');
- extract 
----------
-       2
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DOW           FROM DATE '2020-08-16');
- extract 
----------
-       0
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(ISODOW        FROM DATE '2020-08-11');
- extract 
----------
-       2
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(ISODOW        FROM DATE '2020-08-16');
- extract 
----------
-       7
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DOY           FROM DATE '2020-08-11');
- extract 
----------
-     224
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(TIMEZONE      FROM DATE '2020-08-11');
-ERROR:  unit "timezone" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(TIMEZONE_M    FROM DATE '2020-08-11');
-ERROR:  unit "timezone_m" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(TIMEZONE_H    FROM DATE '2020-08-11');
-ERROR:  unit "timezone_h" not supported for type date
+ERROR:  function extract does not exist
 SELECT EXTRACT(EPOCH         FROM DATE '2020-08-11');
-  extract   
-------------
- 1597104000
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(JULIAN        FROM DATE '2020-08-11');
- extract 
----------
- 2459073
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- test trunc function!
 --
 SELECT DATE_TRUNC('MILLENNIUM', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1001
-        date_trunc        
---------------------------
- Thu Jan 01 00:00:00 1001
-(1 row)
-
+ERROR:  unit "MILLENNIUM" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('MILLENNIUM', DATE '1970-03-20'); -- 1001-01-01
-          date_trunc          
-------------------------------
- Thu Jan 01 00:00:00 1001 PST
-(1 row)
-
+ERROR:  unit "MILLENNIUM" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('CENTURY', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1901
-        date_trunc        
---------------------------
- Tue Jan 01 00:00:00 1901
-(1 row)
-
+ERROR:  unit "CENTURY" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('CENTURY', DATE '1970-03-20'); -- 1901
-          date_trunc          
-------------------------------
- Tue Jan 01 00:00:00 1901 PST
-(1 row)
-
+ERROR:  unit "CENTURY" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('CENTURY', DATE '2004-08-10'); -- 2001-01-01
-          date_trunc          
-------------------------------
- Mon Jan 01 00:00:00 2001 PST
-(1 row)
-
+ERROR:  unit "CENTURY" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('CENTURY', DATE '0002-02-04'); -- 0001-01-01
-          date_trunc          
-------------------------------
- Mon Jan 01 00:00:00 0001 PST
-(1 row)
-
+ERROR:  unit "CENTURY" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('CENTURY', DATE '0055-08-10 BC'); -- 0100-01-01 BC
-           date_trunc            
----------------------------------
- Tue Jan 01 00:00:00 0100 PST BC
-(1 row)
-
+ERROR:  unit "CENTURY" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('DECADE', DATE '1993-12-25'); -- 1990-01-01
-          date_trunc          
-------------------------------
- Mon Jan 01 00:00:00 1990 PST
-(1 row)
-
+ERROR:  unit "DECADE" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('DECADE', DATE '0004-12-25'); -- 0001-01-01 BC
-           date_trunc            
----------------------------------
- Sat Jan 01 00:00:00 0001 PST BC
-(1 row)
-
+ERROR:  unit "DECADE" not recognized for type timestamp without time zone
 SELECT DATE_TRUNC('DECADE', DATE '0002-12-31 BC'); -- 0011-01-01 BC
-           date_trunc            
----------------------------------
- Mon Jan 01 00:00:00 0011 PST BC
-(1 row)
-
+ERROR:  unit "DECADE" not recognized for type timestamp without time zone
 --
 -- test infinity
 --
 select 'infinity'::date, '-infinity'::date;
-   date   |   date    
-----------+-----------
- infinity | -infinity
-(1 row)
-
+ERROR:  invalid date literal: "infinity"
 select 'infinity'::date > 'today'::date as t;
- t 
----
- t
-(1 row)
-
+ERROR:  invalid date literal: "infinity"
 select '-infinity'::date < 'today'::date as t;
- t 
----
- t
-(1 row)
-
+ERROR:  invalid date literal: "-infinity"
 select isfinite('infinity'::date), isfinite('-infinity'::date), isfinite('today'::date);
- isfinite | isfinite | isfinite 
-----------+----------+----------
- f        | f        | t
-(1 row)
-
+ERROR:  function isfinite does not exist
 select 'infinity'::date = '+infinity'::date as t;
- t 
----
- t
-(1 row)
-
+ERROR:  invalid date literal: "infinity"
 --
 -- oscillating fields from non-finite date:
 --
 SELECT EXTRACT(DAY FROM DATE 'infinity');      -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DAY FROM DATE '-infinity');     -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 -- all supported fields
 SELECT EXTRACT(DAY           FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MONTH         FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(QUARTER       FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(WEEK          FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DOW           FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(ISODOW        FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DOY           FROM DATE 'infinity');    -- NULL
- extract 
----------
-        
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- monotonic fields from non-finite date:
 --
 SELECT EXTRACT(EPOCH FROM DATE 'infinity');         --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(EPOCH FROM DATE '-infinity');        -- -Infinity
-  extract  
------------
- -Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 -- all supported fields
 SELECT EXTRACT(YEAR       FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DECADE     FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(CENTURY    FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLENNIUM FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(JULIAN     FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(ISOYEAR    FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(EPOCH      FROM DATE 'infinity');    --  Infinity
- extract  
-----------
- Infinity
-(1 row)
-
+ERROR:  function extract does not exist
 --
 -- wrong fields from non-finite date:
 --
 SELECT EXTRACT(MICROSEC  FROM DATE 'infinity');     -- error
-ERROR:  unit "microsec" not recognized for type date
+ERROR:  function extract does not exist
 -- test constructors
 select make_date(2013, 7, 15);
- make_date  
-------------
- 07-15-2013
-(1 row)
-
+ERROR:  function make_date does not exist
 select make_date(-44, 3, 15);
-   make_date   
----------------
- 03-15-0044 BC
-(1 row)
-
+ERROR:  function make_date does not exist
 select make_time(8, 20, 0.0);
- make_time 
------------
- 08:20:00
-(1 row)
-
+ERROR:  function make_time does not exist
 -- should fail
 select make_date(0, 7, 15);
-ERROR:  date field value out of range: 0-07-15
+ERROR:  function make_date does not exist
 select make_date(2013, 2, 30);
-ERROR:  date field value out of range: 2013-02-30
+ERROR:  function make_date does not exist
 select make_date(2013, 13, 1);
-ERROR:  date field value out of range: 2013-13-01
+ERROR:  function make_date does not exist
 select make_date(2013, 11, -1);
-ERROR:  date field value out of range: 2013-11--1
+ERROR:  function make_date does not exist
 select make_time(10, 55, 100.1);
-ERROR:  time field value out of range: 10:55:100.1
+ERROR:  function make_time does not exist
 select make_time(24, 0, 2.1);
-ERROR:  time field value out of range: 24:00:2.1
+ERROR:  function make_time does not exist
diff -U3 /home/longqimin/pg_regress_input/expected/time.out /home/longqimin/pg_regress_input/results/time.out
--- /home/longqimin/pg_regress_input/expected/time.out	2024-02-27 09:30:35.103460309 +0800
+++ /home/longqimin/pg_regress_input/results/time.out	2024-03-08 13:59:19.999478946 +0800
@@ -6,52 +6,45 @@
 INSERT INTO TIME_TBL VALUES ('01:00');
 -- as of 7.4, timezone spec should be accepted and ignored
 INSERT INTO TIME_TBL VALUES ('02:03 PST');
+ERROR:  invalid time literal: "02:03 PST"
 INSERT INTO TIME_TBL VALUES ('11:59 EDT');
+ERROR:  invalid time literal: "11:59 EDT"
 INSERT INTO TIME_TBL VALUES ('12:00');
 INSERT INTO TIME_TBL VALUES ('12:01');
 INSERT INTO TIME_TBL VALUES ('23:59');
 INSERT INTO TIME_TBL VALUES ('11:59:59.99 PM');
+ERROR:  invalid time literal: "11:59:59.99 PM"
 INSERT INTO TIME_TBL VALUES ('2003-03-07 15:36:39 America/New_York');
+ERROR:  invalid time literal: "2003-03-07 15:36:39 America/New_York"
 INSERT INTO TIME_TBL VALUES ('2003-07-07 15:36:39 America/New_York');
+ERROR:  invalid time literal: "2003-07-07 15:36:39 America/New_York"
 -- this should fail (the timezone offset is not known)
 INSERT INTO TIME_TBL VALUES ('15:36:39 America/New_York');
-ERROR:  invalid input syntax for type time: "15:36:39 America/New_York"
-LINE 1: INSERT INTO TIME_TBL VALUES ('15:36:39 America/New_York');
-                                     ^
+ERROR:  invalid time literal: "15:36:39 America/New_York"
 SELECT f1 AS "Time" FROM TIME_TBL;
-    Time     
--------------
- 00:00:00
- 01:00:00
- 02:03:00
- 11:59:00
- 12:00:00
- 12:01:00
- 23:59:00
- 23:59:59.99
- 15:36:39
- 15:36:39
-(10 rows)
+      Time       
+-----------------
+ 00:00:00.000000
+ 01:00:00.000000
+ 12:01:00.000000
+ 12:00:00.000000
+ 23:59:00.000000
+(5 rows)
 
 SELECT f1 AS "Three" FROM TIME_TBL WHERE f1 < '05:06:07';
-  Three   
-----------
- 00:00:00
- 01:00:00
- 02:03:00
-(3 rows)
+      Three      
+-----------------
+ 00:00:00.000000
+ 01:00:00.000000
+(2 rows)
 
 SELECT f1 AS "Five" FROM TIME_TBL WHERE f1 > '05:06:07';
-    Five     
--------------
- 11:59:00
- 12:00:00
- 12:01:00
- 23:59:00
- 23:59:59.99
- 15:36:39
- 15:36:39
-(7 rows)
+      Five       
+-----------------
+ 12:00:00.000000
+ 23:59:00.000000
+ 12:01:00.000000
+(3 rows)
 
 SELECT f1 AS "None" FROM TIME_TBL WHERE f1 < '00:00';
  None 
@@ -59,92 +52,43 @@
 (0 rows)
 
 SELECT f1 AS "Eight" FROM TIME_TBL WHERE f1 >= '00:00';
-    Eight    
--------------
- 00:00:00
- 01:00:00
- 02:03:00
- 11:59:00
- 12:00:00
- 12:01:00
- 23:59:00
- 23:59:59.99
- 15:36:39
- 15:36:39
-(10 rows)
+      Eight      
+-----------------
+ 00:00:00.000000
+ 01:00:00.000000
+ 23:59:00.000000
+ 12:01:00.000000
+ 12:00:00.000000
+(5 rows)
 
 -- Check edge cases
 SELECT '23:59:59.999999'::time;
-      time       
------------------
- 23:59:59.999999
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '23:59:59.9999999'::time;  -- rounds up
-   time   
-----------
- 24:00:00
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '23:59:60'::time;  -- rounds up
-   time   
-----------
- 24:00:00
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '24:00:00'::time;  -- allowed
-   time   
-----------
- 24:00:00
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '24:00:00.01'::time;  -- not allowed
-ERROR:  date/time field value out of range: "24:00:00.01"
-LINE 1: SELECT '24:00:00.01'::time;
-               ^
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '23:59:60.01'::time;  -- not allowed
-ERROR:  date/time field value out of range: "23:59:60.01"
-LINE 1: SELECT '23:59:60.01'::time;
-               ^
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '24:01:00'::time;  -- not allowed
-ERROR:  date/time field value out of range: "24:01:00"
-LINE 1: SELECT '24:01:00'::time;
-               ^
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 SELECT '25:00:00'::time;  -- not allowed
-ERROR:  date/time field value out of range: "25:00:00"
-LINE 1: SELECT '25:00:00'::time;
-               ^
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 -- Test non-error-throwing API
 SELECT pg_input_is_valid('12:00:00', 'time');
- pg_input_is_valid 
--------------------
- t
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('25:00:00', 'time');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT pg_input_is_valid('15:36:39 America/New_York', 'time');
- pg_input_is_valid 
--------------------
- f
-(1 row)
-
+ERROR:  function pg_input_is_valid does not exist
 SELECT * FROM pg_input_error_info('25:00:00', 'time');
-                    message                     | detail | hint | sql_error_code 
-------------------------------------------------+--------+------+----------------
- date/time field value out of range: "25:00:00" |        |      | 22008
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 SELECT * FROM pg_input_error_info('15:36:39 America/New_York', 'time');
-                             message                             | detail | hint | sql_error_code 
------------------------------------------------------------------+--------+------+----------------
- invalid input syntax for type time: "15:36:39 America/New_York" |        |      | 22007
-(1 row)
-
+ERROR:  function pg_input_error_info does not exist
 --
 -- TIME simple math
 --
@@ -154,78 +98,35 @@
 -- and do the rest of the testing in horology.sql
 -- where we do mixed-type arithmetic. - thomas 2000-12-02
 SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL;
-ERROR:  operator is not unique: time without time zone + time without time zone
-LINE 1: SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL;
-                  ^
-HINT:  Could not choose a best candidate operator. You might need to add explicit type casts.
+ERROR:  not processed pg_catalog type [pg_catalog_type=time]
 --
 -- test EXTRACT
 --
 SELECT EXTRACT(MICROSECOND FROM TIME '2020-05-26 13:30:25.575401');
- extract  
-----------
- 25575401
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MILLISECOND FROM TIME '2020-05-26 13:30:25.575401');
-  extract  
------------
- 25575.401
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(SECOND      FROM TIME '2020-05-26 13:30:25.575401');
-  extract  
------------
- 25.575401
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(MINUTE      FROM TIME '2020-05-26 13:30:25.575401');
- extract 
----------
-      30
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(HOUR        FROM TIME '2020-05-26 13:30:25.575401');
- extract 
----------
-      13
-(1 row)
-
+ERROR:  function extract does not exist
 SELECT EXTRACT(DAY         FROM TIME '2020-05-26 13:30:25.575401');  -- error
-ERROR:  unit "day" not supported for type time without time zone
+ERROR:  function extract does not exist
 SELECT EXTRACT(FORTNIGHT   FROM TIME '2020-05-26 13:30:25.575401');  -- error
-ERROR:  unit "fortnight" not recognized for type time without time zone
+ERROR:  function extract does not exist
 SELECT EXTRACT(TIMEZONE    FROM TIME '2020-05-26 13:30:25.575401');  -- error
-ERROR:  unit "timezone" not supported for type time without time zone
+ERROR:  function extract does not exist
 SELECT EXTRACT(EPOCH       FROM TIME '2020-05-26 13:30:25.575401');
-   extract    
---------------
- 48625.575401
-(1 row)
-
+ERROR:  function extract does not exist
 -- date_part implementation is mostly the same as extract, so only
 -- test a few cases for additional coverage.
 SELECT date_part('microsecond', TIME '2020-05-26 13:30:25.575401');
- date_part 
------------
-  25575401
-(1 row)
-
+ERROR:  function date_part does not exist
 SELECT date_part('millisecond', TIME '2020-05-26 13:30:25.575401');
- date_part 
------------
- 25575.401
-(1 row)
-
+ERROR:  function date_part does not exist
 SELECT date_part('second',      TIME '2020-05-26 13:30:25.575401');
- date_part 
------------
- 25.575401
-(1 row)
-
+ERROR:  function date_part does not exist
 SELECT date_part('epoch',       TIME '2020-05-26 13:30:25.575401');
-  date_part   
---------------
- 48625.575401
-(1 row)
-
+ERROR:  function date_part does not exist
diff -U3 /home/longqimin/pg_regress_input/expected/select.out /home/longqimin/pg_regress_input/results/select.out
--- /home/longqimin/pg_regress_input/expected/select.out	2024-03-08 12:19:19.529430515 +0800
+++ /home/longqimin/pg_regress_input/results/select.out	2024-03-08 13:59:21.561478792 +0800
@@ -219,16 +219,16 @@
 SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10;
  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
 ---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-       0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
+       9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
        1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
        2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx
        3 |     431 |   1 |    3 |   3 |      3 |       3 |        3 |           3 |         3 |        3 |   6 |    7 | DAAAAA   | PQAAAA   | VVVVxx
-       4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
        5 |     541 |   1 |    1 |   5 |      5 |       5 |        5 |           5 |         5 |        5 |  10 |   11 | FAAAAA   | VUAAAA   | HHHHxx
-       6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
        7 |     647 |   1 |    3 |   7 |      7 |       7 |        7 |           7 |         7 |        7 |  14 |   15 | HAAAAA   | XYAAAA   | VVVVxx
        8 |     653 |   0 |    0 |   8 |      8 |       8 |        8 |           8 |         8 |        8 |  16 |   17 | IAAAAA   | DZAAAA   | HHHHxx
-       9 |      49 |   1 |    1 |   9 |      9 |       9 |        9 |           9 |         9 |        9 |  18 |   19 | JAAAAA   | XBAAAA   | HHHHxx
+       4 |     833 |   0 |    0 |   4 |      4 |       4 |        4 |           4 |         4 |        4 |   8 |    9 | EAAAAA   | BGBAAA   | HHHHxx
+       6 |     978 |   0 |    2 |   6 |      6 |       6 |        6 |           6 |         6 |        6 |  12 |   13 | GAAAAA   | QLBAAA   | OOOOxx
+       0 |     998 |   0 |    0 |   0 |      0 |       0 |        0 |           0 |         0 |        0 |   0 |    1 | AAAAAA   | KMBAAA   | OOOOxx
 (10 rows)
 
 --
@@ -268,25 +268,25 @@
    WHERE onek2.unique1 > 980;
  unique1 | stringu1 
 ---------+----------
-     981 | TLAAAA
-     982 | ULAAAA
+     997 | JMAAAA
+     995 | HMAAAA
+     999 | LMAAAA
      983 | VLAAAA
-     984 | WLAAAA
-     985 | XLAAAA
-     986 | YLAAAA
-     987 | ZLAAAA
-     988 | AMAAAA
      989 | BMAAAA
+     986 | YLAAAA
+     996 | IMAAAA
+     982 | ULAAAA
+     992 | EMAAAA
      990 | CMAAAA
      991 | DMAAAA
-     992 | EMAAAA
+     984 | WLAAAA
+     981 | TLAAAA
+     998 | KMAAAA
      993 | FMAAAA
      994 | GMAAAA
-     995 | HMAAAA
-     996 | IMAAAA
-     997 | JMAAAA
-     998 | KMAAAA
-     999 | LMAAAA
+     988 | AMAAAA
+     987 | ZLAAAA
+     985 | XLAAAA
 (19 rows)
 
 --RESET enable_seqscan;
@@ -300,68 +300,7 @@
 --
 -- SELECT name, age FROM person*; ??? check if different
 SELECT p.name, p.age FROM person* p;
-  name   | age 
----------+-----
- mike    |  40
- joe     |  20
- sally   |  34
- sandra  |  19
- alex    |  30
- sue     |  50
- denise  |  24
- sarah   |  88
- teresa  |  38
- nan     |  28
- leah    |  68
- wendy   |  78
- melissa |  28
- joan    |  18
- mary    |   8
- jane    |  58
- liza    |  38
- jean    |  28
- jenifer |  38
- juanita |  58
- susan   |  78
- zena    |  98
- martie  |  88
- chris   |  78
- pat     |  18
- zola    |  58
- louise  |  98
- edna    |  18
- bertha  |  88
- sumi    |  38
- koko    |  88
- gina    |  18
- rean    |  48
- sharon  |  78
- paula   |  68
- julie   |  68
- belinda |  38
- karen   |  48
- carina  |  58
- diane   |  18
- esther  |  98
- trudy   |  88
- fanny   |   8
- carmen  |  78
- lita    |  25
- pamela  |  48
- sandy   |  38
- trisha  |  88
- uma     |  78
- velma   |  68
- sharon  |  25
- sam     |  30
- bill    |  20
- fred    |  28
- larry   |  60
- jeff    |  23
- cim     |  30
- linda   |  19
-(58 rows)
-
+ERROR:  can't find table : public.person
 --
 -- awk '{print $1,$2;}' person.data |
 -- awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
@@ -370,100 +309,22 @@
 -- sort +1nr -2
 --
 SELECT p.name, p.age FROM person* p ORDER BY age DESC, name;
-  name   | age 
----------+-----
- esther  |  98
- louise  |  98
- zena    |  98
- bertha  |  88
- koko    |  88
- martie  |  88
- sarah   |  88
- trisha  |  88
- trudy   |  88
- carmen  |  78
- chris   |  78
- sharon  |  78
- susan   |  78
- uma     |  78
- wendy   |  78
- julie   |  68
- leah    |  68
- paula   |  68
- velma   |  68
- larry   |  60
- carina  |  58
- jane    |  58
- juanita |  58
- zola    |  58
- sue     |  50
- karen   |  48
- pamela  |  48
- rean    |  48
- mike    |  40
- belinda |  38
- jenifer |  38
- liza    |  38
- sandy   |  38
- sumi    |  38
- teresa  |  38
- sally   |  34
- alex    |  30
- cim     |  30
- sam     |  30
- fred    |  28
- jean    |  28
- melissa |  28
- nan     |  28
- lita    |  25
- sharon  |  25
- denise  |  24
- jeff    |  23
- bill    |  20
- joe     |  20
- linda   |  19
- sandra  |  19
- diane   |  18
- edna    |  18
- gina    |  18
- joan    |  18
- pat     |  18
- fanny   |   8
- mary    |   8
-(58 rows)
-
+ERROR:  can't find table : public.person
 --
 -- Test some cases involving whole-row Var referencing a subquery
 --
 select foo from (select 1 offset 0) as foo;
- foo 
------
- (1)
-(1 row)
-
+ERROR:  column "foo" not exist
 select foo from (select null offset 0) as foo;
- foo 
------
- ()
-(1 row)
-
+ERROR:  column "foo" not exist
 select foo from (select 'xyzzy',1,null offset 0) as foo;
-    foo     
-------------
- (xyzzy,1,)
-(1 row)
-
+ERROR:  column "foo" not exist
 --
 -- Test VALUES lists
 --
 select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
     WHERE onek.unique1 = v.i and onek.stringu1 = v.j;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 |  i  |   j    
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----+--------
-     147 |       0 |   1 |    3 |   7 |      7 |       7 |       47 |         147 |       147 |      147 |  14 |   15 | RFAAAA   | AAAAAA   | AAAAxx  | 147 | RFAAAA
-     931 |       1 |   1 |    3 |   1 |     11 |       1 |       31 |         131 |       431 |      931 |   2 |    3 | VJAAAA   | BAAAAA   | HHHHxx  | 931 | VJAAAA
-(2 rows)
-
+ERROR:  missing FROM-clause entry for table "v"
 -- a more complex case
 -- looks like we're coding lisp :-)
 select * from onek,
@@ -471,56 +332,27 @@
     (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
     order by i asc limit 1))) bar (i)
   where onek.unique1 = bar.i;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | i 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+---
-       2 |     326 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | OMAAAA   | OOOOxx  | 2
-(1 row)
-
+ERROR:  missing FROM-clause entry for table "bar"
 -- try VALUES in a subquery
 select * from onek
     where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
     order by unique1;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-       1 |     214 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | GIAAAA   | OOOOxx
-      20 |     306 |   0 |    0 |   0 |      0 |       0 |       20 |          20 |        20 |       20 |   0 |    1 | UAAAAA   | ULAAAA   | OOOOxx
-      99 |     101 |   1 |    3 |   9 |     19 |       9 |       99 |          99 |        99 |       99 |  18 |   19 | VDAAAA   | XDAAAA   | HHHHxx
-(3 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=31]
 -- VALUES is also legal as a standalone query or a set-operation member
 VALUES (1,2), (3,4+4), (7,77.7);
- column1 | column2 
----------+---------
-       1 |       2
-       3 |       8
-       7 |    77.7
-(3 rows)
-
+ERROR:  select list can't be empty currently
 VALUES (1,2), (3,4+4), (7,77.7)
 UNION ALL
 SELECT 2+2, 57
 UNION ALL
 TABLE int8_tbl;
-     column1      |      column2      
-------------------+-------------------
-                1 |                 2
-                3 |                 8
-                7 |              77.7
-                4 |                57
-              123 |               456
-              123 |  4567890123456789
- 4567890123456789 |               123
- 4567890123456789 |  4567890123456789
- 4567890123456789 | -4567890123456789
-(9 rows)
-
+ERROR:  select list can't be empty currently
 -- corner case: VALUES with no columns
 CREATE TEMP TABLE nocols();
 INSERT INTO nocols DEFAULT VALUES;
+ERROR:  std::get: wrong index for variant
 SELECT * FROM nocols n, LATERAL (VALUES(n.*)) v;
---
-(1 row)
-
+ERROR:  select list can't be empty currently
 --
 -- Test ORDER BY options
 --
@@ -588,6 +420,7 @@
 
 -- check if indexscans do the right things
 CREATE INDEX fooi ON foo (f1);
+ERROR:  only support select and create table statement
 --SET enable_sort = false;
 SELECT * FROM foo ORDER BY f1;
  f1 
@@ -638,7 +471,9 @@
 (7 rows)
 
 DROP INDEX fooi;
+ERROR:  only support select and create table statement
 CREATE INDEX fooi ON foo (f1 DESC);
+ERROR:  only support select and create table statement
 SELECT * FROM foo ORDER BY f1;
  f1 
 ----
@@ -688,7 +523,9 @@
 (7 rows)
 
 DROP INDEX fooi;
+ERROR:  only support select and create table statement
 CREATE INDEX fooi ON foo (f1 DESC NULLS LAST);
+ERROR:  only support select and create table statement
 SELECT * FROM foo ORDER BY f1;
  f1 
 ----
@@ -842,51 +679,30 @@
 -- But ORDER BY on a set-valued expression does
 create function sillysrf(int) returns setof int as
   'values (1),(10),(2),($1)' language sql immutable;
+ERROR:  only support select and create table statement
 select sillysrf(42);
- sillysrf 
-----------
-        1
-       10
-        2
-       42
-(4 rows)
-
+ERROR:  function sillysrf does not exist
 select sillysrf(-1) order by 1;
- sillysrf 
-----------
-       -1
-        1
-        2
-       10
-(4 rows)
-
+ERROR:  function sillysrf does not exist
 drop function sillysrf(int);
+ERROR:  only support select and create table statement
 -- X = X isn't a no-op, it's effectively X IS NOT NULL assuming = is strict
 -- (see bug #5084)
 select * from (values (2),(null),(1)) v(k) where k = k order by k;
- k 
----
- 1
- 2
-(2 rows)
-
+ERROR:  select list can't be empty currently
 select * from (values (2),(null),(1)) v(k) where k = k;
- k 
----
- 2
- 1
-(2 rows)
-
+ERROR:  select list can't be empty currently
 -- Test partitioned tables with no partitions, which should be handled the
 -- same as the non-inheritance case when expanding its RTE.
 create table list_parted_tbl (a int,b int) partition by list (a);
 create table list_parted_tbl1 partition of list_parted_tbl
   for values in (1) partition by list(b);
---explain (costs off) select * from list_parted_tbl;
---        QUERY PLAN
---------------------------
- Result
-   One-Time Filter: false
+explain (costs off) select * from list_parted_tbl;
+                        QUERY PLAN                        | TIME/ms 
+----------------------------------------------------------+---------
+ tuple(table_0) = ProjectOnEmptyTable([], [Int32, Int32]) |       0
+ return tuple(table_0)                                    |       0
 (2 rows)
 
 drop table list_parted_tbl;
+ERROR:  only support select and create table statement
diff -U3 /home/longqimin/pg_regress_input/expected/select_distinct.out /home/longqimin/pg_regress_input/results/select_distinct.out
--- /home/longqimin/pg_regress_input/expected/select_distinct.out	2024-02-27 09:30:35.100460308 +0800
+++ /home/longqimin/pg_regress_input/results/select_distinct.out	2024-03-08 13:59:25.796478378 +0800
@@ -48,50 +48,7 @@
 SELECT DISTINCT two, string4, ten
    FROM onek
    ORDER BY two using <, string4 using <, ten using <;
- two | string4 | ten 
------+---------+-----
-   0 | AAAAxx  |   0
-   0 | AAAAxx  |   2
-   0 | AAAAxx  |   4
-   0 | AAAAxx  |   6
-   0 | AAAAxx  |   8
-   0 | HHHHxx  |   0
-   0 | HHHHxx  |   2
-   0 | HHHHxx  |   4
-   0 | HHHHxx  |   6
-   0 | HHHHxx  |   8
-   0 | OOOOxx  |   0
-   0 | OOOOxx  |   2
-   0 | OOOOxx  |   4
-   0 | OOOOxx  |   6
-   0 | OOOOxx  |   8
-   0 | VVVVxx  |   0
-   0 | VVVVxx  |   2
-   0 | VVVVxx  |   4
-   0 | VVVVxx  |   6
-   0 | VVVVxx  |   8
-   1 | AAAAxx  |   1
-   1 | AAAAxx  |   3
-   1 | AAAAxx  |   5
-   1 | AAAAxx  |   7
-   1 | AAAAxx  |   9
-   1 | HHHHxx  |   1
-   1 | HHHHxx  |   3
-   1 | HHHHxx  |   5
-   1 | HHHHxx  |   7
-   1 | HHHHxx  |   9
-   1 | OOOOxx  |   1
-   1 | OOOOxx  |   3
-   1 | OOOOxx  |   5
-   1 | OOOOxx  |   7
-   1 | OOOOxx  |   9
-   1 | VVVVxx  |   1
-   1 | VVVVxx  |   3
-   1 | VVVVxx  |   5
-   1 | VVVVxx  |   7
-   1 | VVVVxx  |   9
-(40 rows)
-
+ERROR:  order by not support using
 --
 -- awk '{print $2;}' person.data |
 -- awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
@@ -100,52 +57,25 @@
 -- sort -n -r | uniq
 --
 SELECT DISTINCT p.age FROM person* p ORDER BY age using >;
- age 
------
-  98
-  88
-  78
-  68
-  60
-  58
-  50
-  48
-  40
-  38
-  34
-  30
-  28
-  25
-  24
-  23
-  20
-  19
-  18
-   8
-(20 rows)
-
+ERROR:  order by not support using
 --
 -- Check mentioning same column more than once
 --
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT count(*) FROM
   (SELECT DISTINCT two, four, two FROM tenk1) ss;
-                       QUERY PLAN                       
---------------------------------------------------------
- Aggregate
-   Output: count(*)
-   ->  HashAggregate
-         Output: tenk1.two, tenk1.four, tenk1.two
-         Group Key: tenk1.two, tenk1.four
-         ->  Seq Scan on public.tenk1
-               Output: tenk1.two, tenk1.four, tenk1.two
-(7 rows)
+                         QUERY PLAN                         | TIME/ms 
+------------------------------------------------------------+---------
+ datum(col_0_literal) = LiteralAggregate(COUNT_NOT_NULL(0)) |       0
+ tuple(table_0) = [datum(col_0_literal)]                    |       0
+ return tuple(table_0)                                      |       0
+(3 rows)
 
 SELECT count(*) FROM
   (SELECT DISTINCT two, four, two FROM tenk1) ss;
  count 
 -------
-     4
+ 10000
 (1 row)
 
 --
@@ -153,96 +83,95 @@
 -- aggregation. Force spilling in both cases by setting work_mem low.
 --
 SET work_mem='64kB';
+ERROR:  only support select and create table statement
 -- Produce results with sorting.
 SET enable_hashagg=FALSE;
+ERROR:  only support select and create table statement
 SET jit_above_cost=0;
+ERROR:  only support select and create table statement
 EXPLAIN (costs off)
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
-                   QUERY PLAN                   
-------------------------------------------------
- Unique
-   ->  Sort
-         Sort Key: ((g % 1000))
-         ->  Function Scan on generate_series g
-(4 rows)
-
+ERROR:  function generate_series does not exist
 CREATE TABLE distinct_group_1 AS
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET jit_above_cost TO DEFAULT;
+ERROR:  only support select and create table statement
 CREATE TABLE distinct_group_2 AS
 SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET enable_seqscan = 0;
+ERROR:  only support select and create table statement
 -- Check to see we get an incremental sort plan
 EXPLAIN (costs off)
 SELECT DISTINCT hundred, two FROM tenk1;
-                     QUERY PLAN                      
------------------------------------------------------
- Unique
-   ->  Incremental Sort
-         Sort Key: hundred, two
-         Presorted Key: hundred
-         ->  Index Scan using tenk1_hundred on tenk1
-(5 rows)
+                                                        QUERY PLAN                                                        | TIME/ms 
+--------------------------------------------------------------------------------------------------------------------------+---------
+ tuple(table_0) = parallel: [tuple(table_0) = IndexScan([column(hundred), column(two)]) + unique), return tuple(table_0)] |      18
+ tuple(table_0) = Unique(tuple(table_0))                                                                                  |       0
+ return tuple(table_0)                                                                                                    |       0
+(3 rows)
 
 RESET enable_seqscan;
+ERROR:  only support select and create table statement
 SET enable_hashagg=TRUE;
+ERROR:  only support select and create table statement
 -- Produce results with hash aggregation.
 SET enable_sort=FALSE;
+ERROR:  only support select and create table statement
 SET jit_above_cost=0;
+ERROR:  only support select and create table statement
 EXPLAIN (costs off)
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
-                QUERY PLAN                
-------------------------------------------
- HashAggregate
-   Group Key: (g % 1000)
-   ->  Function Scan on generate_series g
-(3 rows)
-
+ERROR:  function generate_series does not exist
 CREATE TABLE distinct_hash_1 AS
 SELECT DISTINCT g%1000 FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET jit_above_cost TO DEFAULT;
+ERROR:  only support select and create table statement
 CREATE TABLE distinct_hash_2 AS
 SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g;
+ERROR:  only support select and create table statement
 SET enable_sort=TRUE;
+ERROR:  only support select and create table statement
 SET work_mem TO DEFAULT;
+ERROR:  only support select and create table statement
 -- Compare results
 (SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
   UNION ALL
 (SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1);
- ?column? 
-----------
-(0 rows)
-
+ERROR:  select list can't be empty currently
 (SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
   UNION ALL
 (SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1);
- ?column? 
-----------
-(0 rows)
-
+ERROR:  select list can't be empty currently
 DROP TABLE distinct_hash_1;
+ERROR:  only support select and create table statement
 DROP TABLE distinct_hash_2;
+ERROR:  only support select and create table statement
 DROP TABLE distinct_group_1;
+ERROR:  only support select and create table statement
 DROP TABLE distinct_group_2;
+ERROR:  only support select and create table statement
 -- Test parallel DISTINCT
 SET parallel_tuple_cost=0;
+ERROR:  only support select and create table statement
 SET parallel_setup_cost=0;
+ERROR:  only support select and create table statement
 SET min_parallel_table_scan_size=0;
+ERROR:  only support select and create table statement
 SET max_parallel_workers_per_gather=2;
+ERROR:  only support select and create table statement
 -- Ensure we get a parallel plan
 EXPLAIN (costs off)
 SELECT DISTINCT four FROM tenk1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Unique
-   ->  Gather Merge
-         Workers Planned: 2
-         ->  Sort
-               Sort Key: four
-               ->  HashAggregate
-                     Group Key: four
-                     ->  Parallel Seq Scan on tenk1
-(8 rows)
+                                                 QUERY PLAN                                                  | TIME/ms 
+-------------------------------------------------------------------------------------------------------------+---------
+ tuple(table_0) = parallel: [tuple(var_5_1) = IndexTopN([columns(four ASC)], unique), return tuple(var_5_1)] |       2
+ tuple(table_0) = Unique(tuple(table_0))                                                                     |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])                                                     |       0
+ return tuple(table_0)                                                                                       |       0
+(4 rows)
 
 -- Ensure the parallel plan produces the correct results
 SELECT DISTINCT four FROM tenk1;
@@ -259,41 +188,30 @@
     RETURN a;
   END;
 $$ LANGUAGE plpgsql PARALLEL UNSAFE;
+ERROR:  only support select and create table statement
 -- Ensure we don't do parallel distinct with a parallel unsafe function
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT distinct_func(1) FROM tenk1;
-                        QUERY PLAN                        
-----------------------------------------------------------
- Unique
-   ->  Sort
-         Sort Key: (distinct_func(1))
-         ->  Index Only Scan using tenk1_hundred on tenk1
-(4 rows)
-
+ERROR:  function distinct_func does not exist
 -- make the function parallel safe
 CREATE OR REPLACE FUNCTION distinct_func(a INT) RETURNS INT AS $$
   BEGIN
     RETURN a;
   END;
 $$ LANGUAGE plpgsql PARALLEL SAFE;
+ERROR:  only support select and create table statement
 -- Ensure we do parallel distinct now that the function is parallel safe
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT distinct_func(1) FROM tenk1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Unique
-   ->  Gather Merge
-         Workers Planned: 2
-         ->  Unique
-               ->  Sort
-                     Sort Key: (distinct_func(1))
-                     ->  Parallel Seq Scan on tenk1
-(7 rows)
-
+ERROR:  function distinct_func does not exist
 RESET max_parallel_workers_per_gather;
+ERROR:  only support select and create table statement
 RESET min_parallel_table_scan_size;
+ERROR:  only support select and create table statement
 RESET parallel_setup_cost;
+ERROR:  only support select and create table statement
 RESET parallel_tuple_cost;
+ERROR:  only support select and create table statement
 --
 -- Test the planner's ability to use a LIMIT 1 instead of a Unique node when
 -- all of the distinct_pathkeys have been marked as redundant
@@ -301,12 +219,14 @@
 -- Ensure we get a plan with a Limit 1
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four FROM tenk1 WHERE four = 0;
-         QUERY PLAN         
-----------------------------
- Limit
-   ->  Seq Scan on tenk1
-         Filter: (four = 0)
-(3 rows)
+                                                                   QUERY PLAN                                                                    | TIME/ms 
+-------------------------------------------------------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_5_1) = IndexFilter(column(four) == 0), return tid(var_5_1)]                                                     |       0
+ tuple(table_0) = broadcast: [tid(where)] parallel: [tuple(var_6_1) = IndexTopN([columns(four ASC)], tid(where), unique), return tuple(var_6_1)] |       0
+ tuple(table_0) = Unique(tuple(table_0))                                                                                                         |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])                                                                                         |       0
+ return tuple(table_0)                                                                                                                           |       0
+(5 rows)
 
 -- Ensure the above gives us the correct result
 SELECT DISTINCT four FROM tenk1 WHERE four = 0;
@@ -318,56 +238,54 @@
 -- Ensure we get a plan with a Limit 1
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0;
-                 QUERY PLAN                  
----------------------------------------------
- Limit
-   ->  Seq Scan on tenk1
-         Filter: ((two <> 0) AND (four = 0))
-(3 rows)
+                                                                   QUERY PLAN                                                                    | TIME/ms 
+-------------------------------------------------------------------------------------------------------------------------------------------------+---------
+ tid(var_5_1) = parallel: [tid(var_5_2) = IndexFilter(column(four) == 0), return tid(var_5_2)]                                                   |       0
+ tid(var_5_3) = parallel: [tid(var_5_4) = IndexFilter(column(two) != 0), return tid(var_5_4)]                                                    |       1
+ tid(where) = [tid(var_5_3) and tid(var_5_1)]                                                                                                    |       0
+ tuple(table_0) = broadcast: [tid(where)] parallel: [tuple(var_6_1) = IndexTopN([columns(four ASC)], tid(where), unique), return tuple(var_6_1)] |       1
+ tuple(table_0) = Unique(tuple(table_0))                                                                                                         |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])                                                                                         |       0
+ return tuple(table_0)                                                                                                                           |       0
+(7 rows)
 
 -- Ensure no rows are returned
 SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0;
- four 
-------
+--
 (0 rows)
 
 -- Ensure we get a plan with a Limit 1 when the SELECT list contains constants
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0;
-         QUERY PLAN         
-----------------------------
- Limit
-   ->  Seq Scan on tenk1
-         Filter: (four = 0)
-(3 rows)
-
+ERROR:  load unexist tuple_with_tid [name=select]
 -- Ensure we only get 1 row
 SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0;
- four | ?column? | ?column? | ?column? 
-------+----------+----------+----------
-    0 |        1 |        2 |        3
-(1 row)
-
+ERROR:  load unexist tuple_with_tid [name=select]
 SET parallel_setup_cost=0;
+ERROR:  only support select and create table statement
 SET min_parallel_table_scan_size=0;
+ERROR:  only support select and create table statement
 SET max_parallel_workers_per_gather=2;
+ERROR:  only support select and create table statement
 -- Ensure we get a plan with a Limit 1 in both partial distinct and final
 -- distinct
 EXPLAIN (COSTS OFF)
 SELECT DISTINCT four FROM tenk1 WHERE four = 10;
-                  QUERY PLAN                  
-----------------------------------------------
- Limit
-   ->  Gather
-         Workers Planned: 2
-         ->  Limit
-               ->  Parallel Seq Scan on tenk1
-                     Filter: (four = 10)
-(6 rows)
+                                                                   QUERY PLAN                                                                    | TIME/ms 
+-------------------------------------------------------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_5_1) = IndexFilter(column(four) == 10), return tid(var_5_1)]                                                    |       0
+ tuple(table_0) = broadcast: [tid(where)] parallel: [tuple(var_6_1) = IndexTopN([columns(four ASC)], tid(where), unique), return tuple(var_6_1)] |       0
+ tuple(table_0) = Unique(tuple(table_0))                                                                                                         |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])                                                                                         |       0
+ return tuple(table_0)                                                                                                                           |       0
+(5 rows)
 
 RESET max_parallel_workers_per_gather;
+ERROR:  only support select and create table statement
 RESET min_parallel_table_scan_size;
+ERROR:  only support select and create table statement
 RESET parallel_setup_cost;
+ERROR:  only support select and create table statement
 --
 -- Also, some tests of IS DISTINCT FROM, which doesn't quite deserve its
 -- very own regression file.
@@ -379,88 +297,28 @@
 INSERT INTO DISTTABLE VALUES(NULL);
 -- basic cases
 SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable;
- f1 | not 2 
-----+-------
-  1 | t
-  2 | f
-  3 | t
-    | t
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable;
- f1 | not null 
-----+----------
-  1 | t
-  2 | t
-  3 | t
-    | f
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable;
- f1 | false 
-----+-------
-  1 | f
-  2 | f
-  3 | f
-    | f
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable;
- f1 | not null 
-----+----------
-  1 | t
-  2 | t
-  3 | t
-    | f
-(4 rows)
-
+ERROR:  a_expr only support op and between [kind=4]
 -- check that optimizer constant-folds it properly
 SELECT 1 IS DISTINCT FROM 2 as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT 2 IS DISTINCT FROM 2 as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT 2 IS DISTINCT FROM null as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 SELECT null IS DISTINCT FROM null as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=4]
 -- negated form
 SELECT 1 IS NOT DISTINCT FROM 2 as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
 SELECT 2 IS NOT DISTINCT FROM 2 as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
 SELECT 2 IS NOT DISTINCT FROM null as "no";
- no 
-----
- f
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
 SELECT null IS NOT DISTINCT FROM null as "yes";
- yes 
------
- t
-(1 row)
-
+ERROR:  a_expr only support op and between [kind=5]
diff -U3 /home/longqimin/pg_regress_input/expected/aggregates.out /home/longqimin/pg_regress_input/results/aggregates.out
--- /home/longqimin/pg_regress_input/expected/aggregates.out	2024-03-08 12:19:19.528430515 +0800
+++ /home/longqimin/pg_regress_input/results/aggregates.out	2024-03-08 13:59:38.300477148 +0800
@@ -5,6 +5,7 @@
 \getenv abs_srcdir PG_ABS_SRCDIR
 -- avoid bit-exact output here because operations may not be bit-exact.
 SET extra_float_digits = 0;
+ERROR:  only support select and create table statement
 -- prepare some test data
 CREATE TABLE aggtest (
 	a 			int2,
@@ -13,6 +14,7 @@
 \set filename :abs_srcdir '/data/agg.data'
 COPY aggtest FROM :'filename';
 ANALYZE aggtest;
+ERROR:  only support select and create table statement
 SELECT avg(four) AS avg_1 FROM onek;
        avg_1        
 --------------------
@@ -26,43 +28,19 @@
 (1 row)
 
 SELECT any_value(v) FROM (VALUES (1), (2), (3)) AS v (v);
- any_value 
------------
-         1
-(1 row)
-
+ERROR:  function any_value does not exist
 SELECT any_value(v) FROM (VALUES (NULL)) AS v (v);
- any_value 
------------
- 
-(1 row)
-
+ERROR:  function any_value does not exist
 SELECT any_value(v) FROM (VALUES (NULL), (1), (2)) AS v (v);
- any_value 
------------
-         1
-(1 row)
-
+ERROR:  function any_value does not exist
 SELECT any_value(v) FROM (VALUES (array['hello', 'world'])) AS v (v);
-   any_value   
----------------
- {hello,world}
-(1 row)
-
+ERROR:  function any_value does not exist
 -- In 7.1, avg(float4) is computed using float8 arithmetic.
 -- Round the result to 3 digits to avoid platform-specific results.
 SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
- avg_107_943 
--------------
-     107.943
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
- avg_3_4 
----------
-     3.4
-(1 row)
-
+ERROR:  can't find table : public.student
 SELECT sum(four) AS sum_1500 FROM onek;
  sum_1500 
 ----------
@@ -78,15 +56,11 @@
 SELECT sum(b) AS avg_431_773 FROM aggtest;
  avg_431_773 
 -------------
-     431.773
+    431.7726
 (1 row)
 
 SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
- avg_6_8 
----------
-     6.8
-(1 row)
-
+ERROR:  can't find table : public.student
 SELECT max(four) AS max_3 FROM onek;
  max_3 
 -------
@@ -106,473 +80,182 @@
 (1 row)
 
 SELECT max(student.gpa) AS max_3_7 FROM student;
- max_3_7 
----------
-     3.7
-(1 row)
-
+ERROR:  can't find table : public.student
 SELECT stddev_pop(b) FROM aggtest;
-   stddev_pop    
------------------
- 131.10703231895
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT stddev_samp(b) FROM aggtest;
-   stddev_samp    
-------------------
- 151.389360803998
-(1 row)
-
+ERROR:  function stddev_samp does not exist
 SELECT var_pop(b) FROM aggtest;
-     var_pop      
-------------------
- 17189.0539234823
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT var_samp(b) FROM aggtest;
-     var_samp     
-------------------
- 22918.7385646431
-(1 row)
-
+ERROR:  function var_samp does not exist
 SELECT stddev_pop(b::numeric) FROM aggtest;
-    stddev_pop    
-------------------
- 131.107032862199
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT stddev_samp(b::numeric) FROM aggtest;
-   stddev_samp    
-------------------
- 151.389361431288
-(1 row)
-
+ERROR:  function stddev_samp does not exist
 SELECT var_pop(b::numeric) FROM aggtest;
-      var_pop       
---------------------
- 17189.054065929769
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT var_samp(b::numeric) FROM aggtest;
-      var_samp      
---------------------
- 22918.738754573025
-(1 row)
-
+ERROR:  function var_samp does not exist
 -- population variance is defined for a single tuple, sample variance
 -- is not
 SELECT var_pop(1.0::float8), var_samp(2.0::float8);
- var_pop | var_samp 
----------+----------
-       0 |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop(3.0::float8), stddev_samp(4.0::float8);
- stddev_pop | stddev_samp 
-------------+-------------
-          0 |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('inf'::float8), var_samp('inf'::float8);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('inf'::float8), stddev_samp('inf'::float8);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('nan'::float8), var_samp('nan'::float8);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('nan'::float8), stddev_samp('nan'::float8);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop(1.0::float4), var_samp(2.0::float4);
- var_pop | var_samp 
----------+----------
-       0 |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop(3.0::float4), stddev_samp(4.0::float4);
- stddev_pop | stddev_samp 
-------------+-------------
-          0 |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('inf'::float4), var_samp('inf'::float4);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('inf'::float4), stddev_samp('inf'::float4);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('nan'::float4), var_samp('nan'::float4);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('nan'::float4), stddev_samp('nan'::float4);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop(1.0::numeric), var_samp(2.0::numeric);
- var_pop | var_samp 
----------+----------
-       0 |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
- stddev_pop | stddev_samp 
-------------+-------------
-          0 |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('inf'::numeric), var_samp('inf'::numeric);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('inf'::numeric), stddev_samp('inf'::numeric);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 SELECT var_pop('nan'::numeric), var_samp('nan'::numeric);
- var_pop | var_samp 
----------+----------
-     NaN |         
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT stddev_pop('nan'::numeric), stddev_samp('nan'::numeric);
- stddev_pop | stddev_samp 
-------------+-------------
-        NaN |            
-(1 row)
-
+ERROR:  function stddev_pop does not exist
 -- verify correct results for null and NaN inputs
 select sum(null::int4) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum(null::int8) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum(null::numeric) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum(null::float8) from generate_series(1,3);
- sum 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::int4) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::int8) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::numeric) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg(null::float8) from generate_series(1,3);
- avg 
------
-    
-(1 row)
-
+ERROR:  function generate_series does not exist
 select sum('NaN'::numeric) from generate_series(1,3);
- sum 
------
- NaN
-(1 row)
-
+ERROR:  function generate_series does not exist
 select avg('NaN'::numeric) from generate_series(1,3);
- avg 
------
- NaN
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- verify correct results for infinite inputs
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('1'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('infinity'), ('1')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('infinity'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('-infinity'), ('infinity')) v(x);
- sum | avg | var_pop 
------+-----+---------
- NaN | NaN |     NaN
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
 FROM (VALUES ('-infinity'), ('-infinity')) v(x);
-    sum    |    avg    | var_pop 
------------+-----------+---------
- -Infinity | -Infinity |     NaN
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('1'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('infinity'), ('1')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('infinity'), ('infinity')) v(x);
-   sum    |   avg    | var_pop 
-----------+----------+---------
- Infinity | Infinity |     NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('-infinity'), ('infinity')) v(x);
- sum | avg | var_pop 
------+-----+---------
- NaN | NaN |     NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
 FROM (VALUES ('-infinity'), ('-infinity')) v(x);
-    sum    |    avg    | var_pop 
------------+-----------+---------
- -Infinity | -Infinity |     NaN
-(1 row)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 -- test accuracy with a large input offset
 SELECT avg(x::float8), var_pop(x::float8)
 FROM (VALUES (100000003), (100000004), (100000006), (100000007)) v(x);
-    avg    | var_pop 
------------+---------
- 100000005 |     2.5
-(1 row)
-
+ERROR:  function var_pop does not exist
 SELECT avg(x::float8), var_pop(x::float8)
 FROM (VALUES (7000000000005), (7000000000007)) v(x);
-      avg      | var_pop 
----------------+---------
- 7000000000006 |       1
-(1 row)
-
+ERROR:  function var_pop does not exist
 -- SQL2003 binary aggregates
 SELECT regr_count(b, a) FROM aggtest;
- regr_count 
-------------
-          4
-(1 row)
-
+ERROR:  function regr_count does not exist
 SELECT regr_sxx(b, a) FROM aggtest;
- regr_sxx 
-----------
-     5099
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT regr_syy(b, a) FROM aggtest;
-     regr_syy     
-------------------
- 68756.2156939293
-(1 row)
-
+ERROR:  function regr_syy does not exist
 SELECT regr_sxy(b, a) FROM aggtest;
-     regr_sxy     
-------------------
- 2614.51582155004
-(1 row)
-
+ERROR:  function regr_sxy does not exist
 SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
- regr_avgx |    regr_avgy     
------------+------------------
-      49.5 | 107.943152273074
-(1 row)
-
+ERROR:  function regr_avgx does not exist
 SELECT regr_r2(b, a) FROM aggtest;
-      regr_r2       
---------------------
- 0.0194977982031803
-(1 row)
-
+ERROR:  function regr_r2 does not exist
 SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
-    regr_slope     |  regr_intercept  
--------------------+------------------
- 0.512750700441271 | 82.5619926012309
-(1 row)
-
+ERROR:  function regr_slope does not exist
 SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
-    covar_pop    |    covar_samp    
------------------+------------------
- 653.62895538751 | 871.505273850014
-(1 row)
-
+ERROR:  function covar_pop does not exist
 SELECT corr(b, a) FROM aggtest;
-       corr        
--------------------
- 0.139634516517873
-(1 row)
-
+ERROR:  function corr does not exist
 -- check single-tuple behavior
 SELECT covar_pop(1::float8,2::float8), covar_samp(3::float8,4::float8);
- covar_pop | covar_samp 
------------+------------
-         0 |           
-(1 row)
-
+ERROR:  function covar_pop does not exist
 SELECT covar_pop(1::float8,'inf'::float8), covar_samp(3::float8,'inf'::float8);
- covar_pop | covar_samp 
------------+------------
-       NaN |           
-(1 row)
-
+ERROR:  function covar_pop does not exist
 SELECT covar_pop(1::float8,'nan'::float8), covar_samp(3::float8,'nan'::float8);
- covar_pop | covar_samp 
------------+------------
-       NaN |           
-(1 row)
-
+ERROR:  function covar_pop does not exist
 -- test accum and combine functions directly
 CREATE TABLE regr_test (x float8, y float8);
 INSERT INTO regr_test VALUES (10,150),(20,250),(30,350),(80,540),(100,200);
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test WHERE x IN (10,20,30,80);
- count | sum | regr_sxx | sum  | regr_syy | regr_sxy 
--------+-----+----------+------+----------+----------
-     4 | 140 |     2900 | 1290 |    83075 |    15050
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test;
- count | sum | regr_sxx | sum  | regr_syy | regr_sxy 
--------+-----+----------+------+----------+----------
-     5 | 240 |     6280 | 1490 |    95080 |     8680
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT float8_accum('{4,140,2900}'::float8[], 100);
- float8_accum 
---------------
- {5,240,6280}
-(1 row)
-
+ERROR:  function float8_accum does not exist
 SELECT float8_regr_accum('{4,140,2900,1290,83075,15050}'::float8[], 200, 100);
-      float8_regr_accum       
-------------------------------
- {5,240,6280,1490,95080,8680}
-(1 row)
-
+ERROR:  function float8_regr_accum does not exist
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test WHERE x IN (10,20,30);
- count | sum | regr_sxx | sum | regr_syy | regr_sxy 
--------+-----+----------+-----+----------+----------
-     3 |  60 |      200 | 750 |    20000 |     2000
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
 FROM regr_test WHERE x IN (80,100);
- count | sum | regr_sxx | sum | regr_syy | regr_sxy 
--------+-----+----------+-----+----------+----------
-     2 | 180 |      200 | 740 |    57800 |    -3400
-(1 row)
-
+ERROR:  function regr_sxx does not exist
 SELECT float8_combine('{3,60,200}'::float8[], '{0,0,0}'::float8[]);
- float8_combine 
-----------------
- {3,60,200}
-(1 row)
-
+ERROR:  function float8_combine does not exist
 SELECT float8_combine('{0,0,0}'::float8[], '{2,180,200}'::float8[]);
- float8_combine 
-----------------
- {2,180,200}
-(1 row)
-
+ERROR:  function float8_combine does not exist
 SELECT float8_combine('{3,60,200}'::float8[], '{2,180,200}'::float8[]);
- float8_combine 
-----------------
- {5,240,6280}
-(1 row)
-
+ERROR:  function float8_combine does not exist
 SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                            '{0,0,0,0,0,0}'::float8[]);
-    float8_regr_combine    
----------------------------
- {3,60,200,750,20000,2000}
-(1 row)
-
+ERROR:  function float8_regr_combine does not exist
 SELECT float8_regr_combine('{0,0,0,0,0,0}'::float8[],
                            '{2,180,200,740,57800,-3400}'::float8[]);
-     float8_regr_combine     
------------------------------
- {2,180,200,740,57800,-3400}
-(1 row)
-
+ERROR:  function float8_regr_combine does not exist
 SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                            '{2,180,200,740,57800,-3400}'::float8[]);
-     float8_regr_combine      
-------------------------------
- {5,240,6280,1490,95080,8680}
-(1 row)
-
+ERROR:  function float8_regr_combine does not exist
 DROP TABLE regr_test;
+ERROR:  only support select and create table statement
 -- test count, distinct
 SELECT count(four) AS cnt_1000 FROM onek;
  cnt_1000 
@@ -620,73 +303,35 @@
 
 -- user-defined aggregates
 SELECT newavg(four) AS avg_1 FROM onek;
-       avg_1        
---------------------
- 1.5000000000000000
-(1 row)
-
+ERROR:  function newavg does not exist
 SELECT newsum(four) AS sum_1500 FROM onek;
- sum_1500 
-----------
-     1500
-(1 row)
-
+ERROR:  function newsum does not exist
 SELECT newcnt(four) AS cnt_1000 FROM onek;
- cnt_1000 
-----------
-     1000
-(1 row)
-
+ERROR:  function newcnt does not exist
 SELECT newcnt(*) AS cnt_1000 FROM onek;
- cnt_1000 
-----------
-     1000
-(1 row)
-
+ERROR:  function newcnt does not exist
 SELECT oldcnt(*) AS cnt_1000 FROM onek;
- cnt_1000 
-----------
-     1000
-(1 row)
-
+ERROR:  function oldcnt does not exist
 SELECT sum2(q1,q2) FROM int8_tbl;
-       sum2        
--------------------
- 18271560493827981
-(1 row)
-
+ERROR:  function sum2 does not exist
 -- test for outer-level aggregates
 -- this should work
 select ten, sum(distinct four) from onek a
 group by ten
 having exists (select 1 from onek b where sum(distinct a.four) = b.four);
- ten | sum 
------+-----
-   0 |   2
-   2 |   2
-   4 |   2
-   6 |   2
-   8 |   2
-(5 rows)
-
+ERROR:  split_condition_by_logical_operator bug! optr: AND
 -- this should fail because subquery has an agg of its own in WHERE
 select ten, sum(distinct four) from onek a
 group by ten
 having exists (select 1 from onek b
                where sum(distinct a.four + b.four) = b.four);
-ERROR:  aggregate functions are not allowed in WHERE
-LINE 4:                where sum(distinct a.four + b.four) = b.four)...
-                             ^
+ERROR:  split_condition_by_logical_operator bug! optr: AND
 -- Test handling of sublinks within outer-level aggregates.
 -- Per bug report from Daniel Grace.
 select
   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
 from tenk1 o;
- max  
-------
- 9999
-(1 row)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 -- Test handling of Params within aggregate arguments in hashed aggregation.
 -- Per bug report from Jeevan Chalke.
 explain (verbose, costs off)
@@ -695,73 +340,22 @@
      lateral (select s2, sum(s1 + s2) sm
               from generate_series(1, 3) s2 group by s2) ss
 order by 1, 2;
-                            QUERY PLAN                            
-------------------------------------------------------------------
- Sort
-   Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
-   Sort Key: s1.s1, s2.s2
-   ->  Nested Loop
-         Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
-         ->  Function Scan on pg_catalog.generate_series s1
-               Output: s1.s1
-               Function Call: generate_series(1, 3)
-         ->  HashAggregate
-               Output: s2.s2, sum((s1.s1 + s2.s2))
-               Group Key: s2.s2
-               ->  Function Scan on pg_catalog.generate_series s2
-                     Output: s2.s2
-                     Function Call: generate_series(1, 3)
-(14 rows)
-
+ERROR:  function generate_series does not exist
 select s1, s2, sm
 from generate_series(1, 3) s1,
      lateral (select s2, sum(s1 + s2) sm
               from generate_series(1, 3) s2 group by s2) ss
 order by 1, 2;
- s1 | s2 | sm 
-----+----+----
-  1 |  1 |  2
-  1 |  2 |  3
-  1 |  3 |  4
-  2 |  1 |  3
-  2 |  2 |  4
-  2 |  3 |  5
-  3 |  1 |  4
-  3 |  2 |  5
-  3 |  3 |  6
-(9 rows)
-
+ERROR:  function generate_series does not exist
 explain (verbose, costs off)
 select array(select sum(x+y) s
             from generate_series(1,3) y group by y order by s)
   from generate_series(1,3) x;
-                            QUERY PLAN                             
--------------------------------------------------------------------
- Function Scan on pg_catalog.generate_series x
-   Output: (SubPlan 1)
-   Function Call: generate_series(1, 3)
-   SubPlan 1
-     ->  Sort
-           Output: (sum((x.x + y.y))), y.y
-           Sort Key: (sum((x.x + y.y)))
-           ->  HashAggregate
-                 Output: sum((x.x + y.y)), y.y
-                 Group Key: y.y
-                 ->  Function Scan on pg_catalog.generate_series y
-                       Output: y.y
-                       Function Call: generate_series(1, 3)
-(13 rows)
-
+ERROR:  function generate_series does not exist
 select array(select sum(x+y) s
             from generate_series(1,3) y group by y order by s)
   from generate_series(1,3) x;
-  array  
----------
- {2,3,4}
- {3,4,5}
- {4,5,6}
-(3 rows)
-
+ERROR:  function generate_series does not exist
 --
 -- test for bitwise integer aggregates
 --
@@ -773,18 +367,21 @@
   x INT2,
   y BIT(4)
 );
+ERROR:  invalid column type [type_name=bit]
 -- empty case
 SELECT
   BIT_AND(i2) AS "?",
   BIT_OR(i4)  AS "?",
   BIT_XOR(i8) AS "?"
 FROM bitwise_test;
- ? | ? | ? 
----+---+---
-   |   |  
-(1 row)
-
+ERROR:  function bit_and does not exist
 COPY bitwise_test FROM STDIN NULL 'null';
+ERROR:  relation "public.bitwise_test" not exists
+1	1	1	1	1	B0101
+3	3	3	null	2	B0100
+7	7	7	3	4	B1100
+\.
+invalid command \.
 SELECT
   BIT_AND(i2) AS "1",
   BIT_AND(i4) AS "1",
@@ -805,11 +402,7 @@
   BIT_XOR(x)  AS "7",
   BIT_XOR(y)  AS "1101"
 FROM bitwise_test;
- 1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 | 5 | 5 | 5 | ? | 7 | 1101 
----+---+---+---+---+------+---+---+---+---+---+------+---+---+---+---+---+------
- 1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101 | 5 | 5 | 5 | 2 | 7 | 1101
-(1 row)
-
+ERROR:  syntax error at or near "1"
 --
 -- test boolean aggregates
 --
@@ -827,11 +420,7 @@
   NOT booland_statefunc(TRUE, FALSE) AS "t",
   NOT booland_statefunc(FALSE, TRUE) AS "t",
   NOT booland_statefunc(FALSE, FALSE) AS "t";
- t | t | t | t | t | t | t | t | t 
----+---+---+---+---+---+---+---+---
- t | t | t | t | t | t | t | t | t
-(1 row)
-
+ERROR:  function booland_statefunc does not exist
 SELECT
   -- boolean or transitions
   -- null because strict
@@ -845,11 +434,7 @@
   boolor_statefunc(TRUE, FALSE) AS "t",
   boolor_statefunc(FALSE, TRUE) AS "t",
   NOT boolor_statefunc(FALSE, FALSE) AS "t";
- t | t | t | t | t | t | t | t | t 
----+---+---+---+---+---+---+---+---
- t | t | t | t | t | t | t | t | t
-(1 row)
-
+ERROR:  function boolor_statefunc does not exist
 CREATE TEMPORARY TABLE bool_test(
   b1 BOOL,
   b2 BOOL,
@@ -860,12 +445,14 @@
   BOOL_AND(b1)   AS "n",
   BOOL_OR(b3)    AS "n"
 FROM bool_test;
- n | n 
----+---
-   | 
-(1 row)
-
+ERROR:  function bool_and does not exist
 COPY bool_test FROM STDIN NULL 'null';
+ERROR:  Can not open file "" because "No such file or directory".
+TRUE	null	FALSE	null
+FALSE	TRUE	null	null
+null	TRUE	FALSE	null
+\.
+invalid command \.
 SELECT
   BOOL_AND(b1)     AS "f",
   BOOL_AND(b2)     AS "t",
@@ -874,11 +461,7 @@
   BOOL_AND(NOT b2) AS "f",
   BOOL_AND(NOT b3) AS "t"
 FROM bool_test;
- f | t | f | n | f | t 
----+---+---+---+---+---
- f | t | f |   | f | t
-(1 row)
-
+ERROR:  syntax error at or near "TRUE"
 SELECT
   EVERY(b1)     AS "f",
   EVERY(b2)     AS "t",
@@ -887,11 +470,7 @@
   EVERY(NOT b2) AS "f",
   EVERY(NOT b3) AS "t"
 FROM bool_test;
- f | t | f | n | f | t 
----+---+---+---+---+---
- f | t | f |   | f | t
-(1 row)
-
+ERROR:  function every does not exist
 SELECT
   BOOL_OR(b1)      AS "t",
   BOOL_OR(b2)      AS "t",
@@ -900,11 +479,7 @@
   BOOL_OR(NOT b2)  AS "f",
   BOOL_OR(NOT b3)  AS "t"
 FROM bool_test;
- t | t | f | n | f | t 
----+---+---+---+---+---
- t | t | f |   | f | t
-(1 row)
-
+ERROR:  function bool_or does not exist
 --
 -- Test cases that should be optimized into indexscans instead of
 -- the generic aggregate implementation.
@@ -912,14 +487,12 @@
 -- Basic cases
 explain (costs off)
   select min(unique1) from tenk1;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan using tenk1_unique1 on tenk1
-                 Index Cond: (unique1 IS NOT NULL)
-(5 rows)
+                                 QUERY PLAN                                 | TIME/ms 
+----------------------------------------------------------------------------+---------
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MIN, column(unique1)) |       7
+ tuple(table_0) = [datum(col_0_unique1)]                                    |       0
+ return tuple(table_0)                                                      |       0
+(3 rows)
 
 select min(unique1) from tenk1;
  min 
@@ -929,14 +502,12 @@
 
 explain (costs off)
   select max(unique1) from tenk1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: (unique1 IS NOT NULL)
-(5 rows)
+                                 QUERY PLAN                                 | TIME/ms 
+----------------------------------------------------------------------------+---------
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1)) |       0
+ tuple(table_0) = [datum(col_0_unique1)]                                    |       0
+ return tuple(table_0)                                                      |       0
+(3 rows)
 
 select max(unique1) from tenk1;
  max  
@@ -946,14 +517,13 @@
 
 explain (costs off)
   select max(unique1) from tenk1 where unique1 < 42;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 < 42))
-(5 rows)
+                                           QUERY PLAN                                           | TIME/ms 
+------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(unique1) < 42), return tid(var_4_1)] |       1
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1), tid(where))         |       0
+ tuple(table_0) = [datum(col_0_unique1)]                                                        |       0
+ return tuple(table_0)                                                                          |       0
+(4 rows)
 
 select max(unique1) from tenk1 where unique1 < 42;
  max 
@@ -963,14 +533,13 @@
 
 explain (costs off)
   select max(unique1) from tenk1 where unique1 > 42;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42))
-(5 rows)
+                                           QUERY PLAN                                           | TIME/ms 
+------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(unique1) > 42), return tid(var_4_1)] |       0
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1), tid(where))         |       1
+ tuple(table_0) = [datum(col_0_unique1)]                                                        |       0
+ return tuple(table_0)                                                                          |       0
+(4 rows)
 
 select max(unique1) from tenk1 where unique1 > 42;
  max  
@@ -983,36 +552,36 @@
 -- plan, which has almost identical cost, will not be.  we want to test
 -- the optimized plan, so temporarily disable parallel query.
 begin;
+ERROR:  only support select and create table statement
 set local max_parallel_workers_per_gather = 0;
+ERROR:  only support select and create table statement
 explain (costs off)
   select max(unique1) from tenk1 where unique1 > 42000;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
-                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42000))
-(5 rows)
+                                            QUERY PLAN                                             | TIME/ms 
+---------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(unique1) > 42000), return tid(var_4_1)] |       1
+ datum(col_0_unique1) = IndexAggregateForMultiSegment(MAX, column(unique1), tid(where))            |       0
+ tuple(table_0) = [datum(col_0_unique1)]                                                           |       0
+ return tuple(table_0)                                                                             |       0
+(4 rows)
 
 select max(unique1) from tenk1 where unique1 > 42000;
  max 
 -----
-    
-(1 row)
+(0 rows)
 
 rollback;
+ERROR:  only support select and create table statement
 -- multi-column index (uses tenk1_thous_tenthous)
 explain (costs off)
   select max(tenthous) from tenk1 where thousand = 33;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1
-                 Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
-(5 rows)
+                                            QUERY PLAN                                            | TIME/ms 
+--------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(thousand) == 33), return tid(var_4_1)] |       5
+ datum(col_0_tenthous) = IndexAggregateForMultiSegment(MAX, column(tenthous), tid(where))         |       5
+ tuple(table_0) = [datum(col_0_tenthous)]                                                         |       0
+ return tuple(table_0)                                                                            |       0
+(4 rows)
 
 select max(tenthous) from tenk1 where thousand = 33;
  max  
@@ -1022,14 +591,13 @@
 
 explain (costs off)
   select min(tenthous) from tenk1 where thousand = 33;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan using tenk1_thous_tenthous on tenk1
-                 Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
-(5 rows)
+                                            QUERY PLAN                                            | TIME/ms 
+--------------------------------------------------------------------------------------------------+---------
+ tid(where) = parallel: [tid(var_4_1) = IndexFilter(column(thousand) == 33), return tid(var_4_1)] |       1
+ datum(col_0_tenthous) = IndexAggregateForMultiSegment(MIN, column(tenthous), tid(where))         |       0
+ tuple(table_0) = [datum(col_0_tenthous)]                                                         |       0
+ return tuple(table_0)                                                                            |       0
+(4 rows)
 
 select min(tenthous) from tenk1 where thousand = 33;
  min 
@@ -1041,41 +609,20 @@
 explain (costs off)
   select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
     from int4_tbl;
-                                       QUERY PLAN                                        
------------------------------------------------------------------------------------------
- Seq Scan on int4_tbl
-   SubPlan 2
-     ->  Result
-           InitPlan 1 (returns $1)
-             ->  Limit
-                   ->  Index Only Scan using tenk1_unique1 on tenk1
-                         Index Cond: ((unique1 IS NOT NULL) AND (unique1 > int4_tbl.f1))
-(7 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
   from int4_tbl;
-     f1      | gt 
--------------+----
-           0 |  1
-      123456 |   
-     -123456 |  0
-  2147483647 |   
- -2147483647 |  0
-(5 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 -- check some cases that were handled incorrectly in 8.3.0
 explain (costs off)
   select distinct max(unique2) from tenk1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- HashAggregate
-   Group Key: $0
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                            QUERY PLAN                                             | TIME/ms 
+---------------------------------------------------------------------------------------------------+---------
+ tuple(table_0) = parallel: [tuple(table_0) = IndexScan([column(unique2)]), return tuple(table_0)] |      11
+ hash_tuple(var_6_1) = TupleHash(tuple(table_0), groupby([]))                                      |       0
+ tuple(table_0) = HashTupleAggregate(hash_tuple(var_6_1) [MAX(0)])                                 |       0
+ return tuple(table_0)                                                                             |       0
+(4 rows)
 
 select distinct max(unique2) from tenk1;
  max  
@@ -1085,16 +632,13 @@
 
 explain (costs off)
   select max(unique2) from tenk1 order by 1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: ($0)
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 | TIME/ms 
+----------------------------------------------------------------------------+---------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2)) |       0
+ tuple(table_0) = [datum(col_0_unique2)]                                    |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])                    |       0
+ return tuple(table_0)                                                      |       1
+(4 rows)
 
 select max(unique2) from tenk1 order by 1;
  max  
@@ -1104,16 +648,13 @@
 
 explain (costs off)
   select max(unique2) from tenk1 order by max(unique2);
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: ($0)
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 | TIME/ms 
+----------------------------------------------------------------------------+---------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2)) |       1
+ tuple(table_0) = [datum(col_0_unique2)]                                    |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(0 ASC)])                    |       0
+ return tuple(table_0)                                                      |       0
+(4 rows)
 
 select max(unique2) from tenk1 order by max(unique2);
  max  
@@ -1123,16 +664,18 @@
 
 explain (costs off)
   select max(unique2) from tenk1 order by max(unique2)+1;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: (($0 + 1))
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  Result
-(7 rows)
+                                 QUERY PLAN                                 | TIME/ms 
+----------------------------------------------------------------------------+---------
+ datum(col_0_unique2) = IndexAggregateForMultiSegment(MAX, column(unique2)) |       0
+ tuple(table_0) = [datum(col_0_unique2)]                                    |       0
+ datum(var_7_1) = TupleAt(tuple(table_0) 0)                                 |       0
+ datum(var_7_2) = DatumMapJIT(cast(Int64, datum(var_7_1)) + 1)              |       0
+ tuple(tmp_order) = [datum(var_7_2)]                                        |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tmp_order))             |       0
+ tuple(table_0) = Sort(tuple(table_0), [columns(1 ASC)])                    |       0
+ tuple(table_0) = Erase(tuple(table_0), [1])                                |       0
+ return tuple(table_0)                                                      |       0
+(9 rows)
 
 select max(unique2) from tenk1 order by max(unique2)+1;
  max  
@@ -1142,38 +685,18 @@
 
 explain (costs off)
   select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
-                             QUERY PLAN                              
----------------------------------------------------------------------
- Sort
-   Sort Key: (generate_series(1, 3)) DESC
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
-                 Index Cond: (unique2 IS NOT NULL)
-   ->  ProjectSet
-         ->  Result
-(8 rows)
-
+ERROR:  function generate_series does not exist
 select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
- max  | g 
-------+---
- 9999 | 3
- 9999 | 2
- 9999 | 1
-(3 rows)
-
+ERROR:  function generate_series does not exist
 -- interesting corner case: constant gets optimized into a seqscan
 explain (costs off)
   select max(100) from tenk1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Result
-                 One-Time Filter: (100 IS NOT NULL)
-                 ->  Seq Scan on tenk1
-(6 rows)
+                    QUERY PLAN                     | TIME/ms 
+---------------------------------------------------+---------
+ datum(col_0_literal) = LiteralAggregate(MAX(100)) |       0
+ tuple(table_0) = [datum(col_0_literal)]           |       0
+ return tuple(table_0)                             |       0
+(3 rows)
 
 select max(100) from tenk1;
  max 
@@ -1187,191 +710,96 @@
 create table minmaxtest2(f1 int);
 create table minmaxtest3(f1 int);
 create index minmaxtesti on minmaxtest(f1);
+ERROR:  only support select and create table statement
 create index minmaxtest1i on minmaxtest1(f1);
+ERROR:  only support select and create table statement
 create index minmaxtest2i on minmaxtest2(f1 desc);
+ERROR:  only support select and create table statement
 create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
+ERROR:  only support select and create table statement
 insert into minmaxtest values(11), (12);
 insert into minmaxtest1 values(13), (14);
 insert into minmaxtest2 values(15), (16);
 insert into minmaxtest3 values(17), (18);
 explain (costs off)
   select min(f1), max(f1) from minmaxtest;
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
- Result
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest.f1
-                 ->  Index Only Scan using minmaxtesti on minmaxtest minmaxtest_1
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest1i on minmaxtest1 minmaxtest_2
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2 minmaxtest_3
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest3i on minmaxtest3 minmaxtest_4
-   InitPlan 2 (returns $1)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest_5.f1 DESC
-                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_6
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest_7
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest_8
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest_9
-(23 rows)
+                            QUERY PLAN                            | TIME/ms 
+------------------------------------------------------------------+---------
+ datum(col_0_f1) = IndexAggregateForMultiSegment(MIN, column(f1)) |       3
+ datum(col_1_f1) = IndexAggregateForMultiSegment(MAX, column(f1)) |       0
+ tuple(table_0) = [datum(col_0_f1), datum(col_1_f1)]              |       0
+ return tuple(table_0)                                            |       0
+(4 rows)
 
 select min(f1), max(f1) from minmaxtest;
  min | max 
 -----+-----
-  11 |  18
+  11 |  12
 (1 row)
 
 -- DISTINCT doesn't do anything useful here, but it shouldn't fail
 explain (costs off)
   select distinct min(f1), max(f1) from minmaxtest;
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
- Unique
-   InitPlan 1 (returns $0)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest.f1
-                 ->  Index Only Scan using minmaxtesti on minmaxtest minmaxtest_1
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest1i on minmaxtest1 minmaxtest_2
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2 minmaxtest_3
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest3i on minmaxtest3 minmaxtest_4
-   InitPlan 2 (returns $1)
-     ->  Limit
-           ->  Merge Append
-                 Sort Key: minmaxtest_5.f1 DESC
-                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_6
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest_7
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest_8
-                       Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest_9
-   ->  Sort
-         Sort Key: ($0), ($1)
-         ->  Result
-(26 rows)
+                            QUERY PLAN                            | TIME/ms 
+------------------------------------------------------------------+---------
+ datum(col_0_f1) = IndexAggregateForMultiSegment(MIN, column(f1)) |       0
+ datum(col_1_f1) = IndexAggregateForMultiSegment(MAX, column(f1)) |       0
+ tuple(table_0) = [datum(col_0_f1), datum(col_1_f1)]              |       0
+ return tuple(table_0)                                            |       0
+(4 rows)
 
 select distinct min(f1), max(f1) from minmaxtest;
  min | max 
 -----+-----
-  11 |  18
+  11 |  12
 (1 row)
 
 drop table minmaxtest cascade;
-NOTICE:  drop cascades to 3 other objects
-DETAIL:  drop cascades to table minmaxtest1
-drop cascades to table minmaxtest2
-drop cascades to table minmaxtest3
+ERROR:  only support select and create table statement
 -- check for correct detection of nested-aggregate errors
 select max(min(unique1)) from tenk1;
 ERROR:  aggregate function calls cannot be nested
-LINE 1: select max(min(unique1)) from tenk1;
-                   ^
 select (select max(min(unique1)) from int8_tbl) from tenk1;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select (select max(min(unique1)) from int8_tbl) from tenk1;
-                           ^
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 select avg((select avg(a1.col1 order by (select avg(a2.col2) from tenk1 a3))
             from tenk1 a1(col1)))
 from tenk1 a2(col2);
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select avg((select avg(a1.col1 order by (select avg(a2.col2)...
-                                                        ^
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 --
 -- Test removal of redundant GROUP BY columns
 --
 create temp table t1 (a int, b int, c int, d int, primary key (a, b));
+ERROR:  std::get: wrong index for variant
 create temp table t2 (x int, y int, z int, primary key (x, y));
+ERROR:  std::get: wrong index for variant
 create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
+ERROR:  std::get: wrong index for variant
 -- Non-primary-key columns can be removed from GROUP BY
 explain (costs off) select * from t1 group by a,b,c,d;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, b
-   ->  Seq Scan on t1
-(3 rows)
-
+ERROR:  can't find table : public.t1
 -- No removal can happen if the complete PK is not present in GROUP BY
 explain (costs off) select a,c from t1 group by a,c,d;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, c, d
-   ->  Seq Scan on t1
-(3 rows)
-
+ERROR:  can't find table : public.t1
 -- Test removal across multiple relations
 explain (costs off) select *
 from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
 group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
-                      QUERY PLAN                      
-------------------------------------------------------
- HashAggregate
-   Group Key: t1.a, t1.b
-   ->  Hash Join
-         Hash Cond: ((t2.x = t1.a) AND (t2.y = t1.b))
-         ->  Seq Scan on t2
-         ->  Hash
-               ->  Seq Scan on t1
-(7 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- Test case where t1 can be optimized but not t2
 explain (costs off) select t1.*,t2.x,t2.z
 from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
 group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
-                      QUERY PLAN                      
-------------------------------------------------------
- HashAggregate
-   Group Key: t1.a, t1.b, t2.z
-   ->  Hash Join
-         Hash Cond: ((t2.x = t1.a) AND (t2.y = t1.b))
-         ->  Seq Scan on t2
-         ->  Hash
-               ->  Seq Scan on t1
-(7 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- Cannot optimize when PK is deferrable
 explain (costs off) select * from t3 group by a,b,c;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, b, c
-   ->  Seq Scan on t3
-(3 rows)
-
+ERROR:  can't find table : public.t3
 create temp table t1c () inherits (t1);
 -- Ensure we don't remove any columns when t1 has a child table
 explain (costs off) select * from t1 group by a,b,c,d;
-             QUERY PLAN              
--------------------------------------
- HashAggregate
-   Group Key: t1.a, t1.b, t1.c, t1.d
-   ->  Append
-         ->  Seq Scan on t1 t1_1
-         ->  Seq Scan on t1c t1_2
-(5 rows)
-
+ERROR:  can't find table : public.t1
 -- Okay to remove columns if we're only querying the parent.
 explain (costs off) select * from only t1 group by a,b,c,d;
-      QUERY PLAN      
-----------------------
- HashAggregate
-   Group Key: a, b
-   ->  Seq Scan on t1
-(3 rows)
-
+ERROR:  can't find table : public.t1
 create temp table p_t1 (
   a int,
   b int,
@@ -1379,66 +807,47 @@
   d int,
   primary key(a,b)
 ) partition by list(a);
+ERROR:  std::get: wrong index for variant
 create temp table p_t1_1 partition of p_t1 for values in(1);
 create temp table p_t1_2 partition of p_t1 for values in(2);
 -- Ensure we can remove non-PK columns for partitioned tables.
 explain (costs off) select * from p_t1 group by a,b,c,d;
-           QUERY PLAN           
---------------------------------
- HashAggregate
-   Group Key: p_t1.a, p_t1.b
-   ->  Append
-         ->  Seq Scan on p_t1_1
-         ->  Seq Scan on p_t1_2
-(5 rows)
-
+ERROR:  can't find table : public.p_t1
 drop table t1 cascade;
-NOTICE:  drop cascades to table t1c
+ERROR:  only support select and create table statement
 drop table t2;
+ERROR:  only support select and create table statement
 drop table t3;
+ERROR:  only support select and create table statement
 drop table p_t1;
+ERROR:  only support select and create table statement
 --
 -- Test GROUP BY matching of join columns that are type-coerced due to USING
 --
 create temp table t1(f1 int, f2 int);
 create temp table t2(f1 bigint, f2 oid);
+ERROR:  invalid column type [type_name=oid]
 select f1 from t1 left join t2 using (f1) group by f1;
- f1 
-----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 select f1 from t1 left join t2 using (f1) group by t1.f1;
- f1 
-----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 select t1.f1 from t1 left join t2 using (f1) group by t1.f1;
- f1 
-----
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- only this one should fail:
 select t1.f1 from t1 left join t2 using (f1) group by f1;
-ERROR:  column "t1.f1" must appear in the GROUP BY clause or be used in an aggregate function
-LINE 1: select t1.f1 from t1 left join t2 using (f1) group by f1;
-               ^
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- check case where we have to inject nullingrels into coerced join alias
 select f1, count(*) from
 t1 x(x0,x1) left join (t1 left join t2 using(f1)) on (x0 = 0)
 group by f1;
- f1 | count 
-----+-------
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 -- same, for a RelabelType coercion
 select f2, count(*) from
 t1 x(x0,x1) left join (t1 left join t2 using(f2)) on (x0 = 0)
 group by f2;
- f2 | count 
-----+-------
-(0 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 drop table t1, t2;
+ERROR:  only support select and create table statement
 --
 -- Test planner's selection of pathkeys for ORDER BY aggregates
 --
@@ -1446,13 +855,14 @@
 explain (costs off)
 select sum(two order by two),max(four order by four), min(four order by four)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: four
-         ->  Seq Scan on tenk1
-(4 rows)
+                                QUERY PLAN                                 | TIME/ms 
+---------------------------------------------------------------------------+---------
+ datum(col_0_two) = IndexAggregateForMultiSegment(SUM, column(two))        |       1
+ datum(col_1_four) = IndexAggregateForMultiSegment(MAX, column(four))      |       0
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))      |       0
+ tuple(table_0) = [datum(col_0_two), datum(col_1_four), datum(col_2_four)] |       0
+ return tuple(table_0)                                                     |       0
+(5 rows)
 
 -- Ensure we order by two.  It's a tie between ordering by two and four but
 -- we tiebreak on the aggregate's position.
@@ -1461,13 +871,15 @@
   sum(two order by two), max(four order by four),
   min(four order by four), max(two order by two)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: two
-         ->  Seq Scan on tenk1
-(4 rows)
+                                         QUERY PLAN                                          | TIME/ms 
+---------------------------------------------------------------------------------------------+---------
+ datum(col_0_two) = IndexAggregateForMultiSegment(SUM, column(two))                          |       0
+ datum(col_1_four) = IndexAggregateForMultiSegment(MAX, column(four))                        |       1
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))                        |       0
+ datum(col_3_two) = IndexAggregateForMultiSegment(MAX, column(two))                          |       0
+ tuple(table_0) = [datum(col_0_two), datum(col_1_four), datum(col_2_four), datum(col_3_two)] |       0
+ return tuple(table_0)                                                                       |       0
+(6 rows)
 
 -- Similar to above, but tiebreak on ordering by four
 explain (costs off)
@@ -1475,13 +887,15 @@
   max(four order by four), sum(two order by two),
   min(four order by four), max(two order by two)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: four
-         ->  Seq Scan on tenk1
-(4 rows)
+                                         QUERY PLAN                                          | TIME/ms 
+---------------------------------------------------------------------------------------------+---------
+ datum(col_0_four) = IndexAggregateForMultiSegment(MAX, column(four))                        |       0
+ datum(col_1_two) = IndexAggregateForMultiSegment(SUM, column(two))                          |       0
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))                        |       0
+ datum(col_3_two) = IndexAggregateForMultiSegment(MAX, column(two))                          |       0
+ tuple(table_0) = [datum(col_0_four), datum(col_1_two), datum(col_2_four), datum(col_3_two)] |       0
+ return tuple(table_0)                                                                       |       0
+(6 rows)
 
 -- Ensure this one orders by ten since there are 3 aggregates that require ten
 -- vs two that suit two and four.
@@ -1491,13 +905,18 @@
   min(four order by four), max(two order by two),
   sum(ten order by ten), min(ten order by ten), max(ten order by ten)
 from tenk1;
-          QUERY PLAN           
--------------------------------
- Aggregate
-   ->  Sort
-         Sort Key: ten
-         ->  Seq Scan on tenk1
-(4 rows)
+                                                                    QUERY PLAN                                                                     | TIME/ms 
+---------------------------------------------------------------------------------------------------------------------------------------------------+---------
+ datum(col_0_four) = IndexAggregateForMultiSegment(MAX, column(four))                                                                              |       1
+ datum(col_1_two) = IndexAggregateForMultiSegment(SUM, column(two))                                                                                |       0
+ datum(col_2_four) = IndexAggregateForMultiSegment(MIN, column(four))                                                                              |       0
+ datum(col_3_two) = IndexAggregateForMultiSegment(MAX, column(two))                                                                                |       0
+ datum(col_4_ten) = IndexAggregateForMultiSegment(SUM, column(ten))                                                                                |       2
+ datum(col_5_ten) = IndexAggregateForMultiSegment(MIN, column(ten))                                                                                |       0
+ datum(col_6_ten) = IndexAggregateForMultiSegment(MAX, column(ten))                                                                                |       1
+ tuple(table_0) = [datum(col_0_four), datum(col_1_two), datum(col_2_four), datum(col_3_two), datum(col_4_ten), datum(col_5_ten), datum(col_6_ten)] |       0
+ return tuple(table_0)                                                                                                                             |       0
+(9 rows)
 
 -- Try a case involving a GROUP BY clause where the GROUP BY column is also
 -- part of an aggregate's ORDER BY clause.  We want a sort order that works
@@ -1508,14 +927,20 @@
   sum(unique1 order by two, four)
 from tenk1
 group by ten;
-            QUERY PLAN            
-----------------------------------
- GroupAggregate
-   Group Key: ten
-   ->  Sort
-         Sort Key: ten, two, four
-         ->  Seq Scan on tenk1
-(5 rows)
+                                                                              QUERY PLAN                                                                              | TIME/ms 
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------
+ FilterHistogram(histogram_tenk1_0) = parallel: [FilterHistogram(var_5_1) = IndexTopNGroup([Get(ten)], 10000, [ASC_AND_NULLS_LAST]), return FilterHistogram(var_5_1)] |       2
+ tuple(tuple_0_tenk1) = to_tuple(FilterHistogram(histogram_tenk1_0))                                                                                                  |       0
+ tuple(tuple_0_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       2
+ tuple(tuple_1_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       1
+ tuple(tuple_2_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       1
+ tuple(table_0) = TupleExpand(tuple(tuple_0_tenk1), tuple(tuple_0_unique1))                                                                                           |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_1_unique1))                                                                                                 |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_2_unique1))                                                                                                 |       0
+ tuple(table_0) = TupleReorder(tuple(table_0), [3, 0, 1, 2])                                                                                                          |       0
+ tuple(table_0) = Erase(tuple(table_0), [3])                                                                                                                          |       0
+ return tuple(table_0)                                                                                                                                                |       0
+(11 rows)
 
 -- Ensure that we never choose to provide presorted input to an Aggref with
 -- a volatile function in the ORDER BY / DISTINCT clause.  We want to ensure
@@ -1527,173 +952,110 @@
   sum(unique1 order by two, random(), random() + 1)
 from tenk1
 group by ten;
-            QUERY PLAN            
-----------------------------------
- GroupAggregate
-   Group Key: ten
-   ->  Sort
-         Sort Key: ten, four, two
-         ->  Seq Scan on tenk1
-(5 rows)
+                                                                              QUERY PLAN                                                                              | TIME/ms 
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------
+ FilterHistogram(histogram_tenk1_0) = parallel: [FilterHistogram(var_5_1) = IndexTopNGroup([Get(ten)], 10000, [ASC_AND_NULLS_LAST]), return FilterHistogram(var_5_1)] |       1
+ tuple(tuple_0_tenk1) = to_tuple(FilterHistogram(histogram_tenk1_0))                                                                                                  |       0
+ tuple(tuple_0_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       1
+ tuple(tuple_1_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       1
+ tuple(tuple_2_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       2
+ tuple(tuple_3_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       1
+ tuple(tuple_4_unique1) = IndexAggregateWithGroupForMultiSegment(SUM, column(unique1), FilterHistogram(histogram_tenk1_0))                                            |       1
+ tuple(table_0) = TupleExpand(tuple(tuple_0_tenk1), tuple(tuple_0_unique1))                                                                                           |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_1_unique1))                                                                                                 |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_2_unique1))                                                                                                 |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_3_unique1))                                                                                                 |       0
+ tuple(table_0) = TupleExpand(tuple(table_0), tuple(tuple_4_unique1))                                                                                                 |       0
+ tuple(table_0) = TupleReorder(tuple(table_0), [5, 0, 1, 2, 3, 4])                                                                                                    |       0
+ tuple(table_0) = Erase(tuple(table_0), [5])                                                                                                                          |       0
+ return tuple(table_0)                                                                                                                                                |       0
+(15 rows)
 
 -- Ensure consecutive NULLs are properly treated as distinct from each other
 select array_agg(distinct val)
 from (select null as val from generate_series(1, 2));
- array_agg 
------------
- {NULL}
-(1 row)
-
+ERROR:  subquery in FROM must have an alias
 -- Ensure no ordering is requested when enable_presorted_aggregate is off
 set enable_presorted_aggregate to off;
+ERROR:  only support select and create table statement
 explain (costs off)
 select sum(two order by two) from tenk1;
-       QUERY PLAN        
--------------------------
- Aggregate
-   ->  Seq Scan on tenk1
-(2 rows)
+                             QUERY PLAN                             | TIME/ms 
+--------------------------------------------------------------------+---------
+ datum(col_0_two) = IndexAggregateForMultiSegment(SUM, column(two)) |       0
+ tuple(table_0) = [datum(col_0_two)]                                |       0
+ return tuple(table_0)                                              |       0
+(3 rows)
 
 reset enable_presorted_aggregate;
+ERROR:  only support select and create table statement
 --
 -- Test combinations of DISTINCT and/or ORDER BY
 --
 select array_agg(a order by b)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {3,4,2,1}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(a order by a)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {1,2,3,4}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(a order by a desc)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {4,3,2,1}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(b order by a desc)
   from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
- array_agg 
------------
- {2,1,3,4}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(distinct a)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {1,2,3,NULL}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(distinct a order by a)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {1,2,3,NULL}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(distinct a order by a desc)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {NULL,3,2,1}
-(1 row)
-
+ERROR:  function array_agg does not exist
 select array_agg(distinct a order by a desc nulls last)
   from (values (1),(2),(1),(3),(null),(2)) v(a);
-  array_agg   
---------------
- {3,2,1,NULL}
-(1 row)
-
+ERROR:  function array_agg does not exist
 -- multi-arg aggs, strict/nonstrict, distinct/order by
 select aggfstr(a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
-                aggfstr                
----------------------------------------
- {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  function aggfstr does not exist
 select aggfns(a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
-                    aggfns                     
------------------------------------------------
- {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  function aggfns does not exist
 select aggfstr(distinct a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                aggfstr                
----------------------------------------
- {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,b,c)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select aggfstr(distinct a,b,c order by b)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                aggfstr                
----------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,b,c order by b)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,3) i;
-                    aggfns                     
------------------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- test specific code paths
 select aggfns(distinct a,a,c order by c using ~<~,a)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                     aggfns                     
-------------------------------------------------
- {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,a,c order by c using ~<~)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                     aggfns                     
-------------------------------------------------
- {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,a,c order by a)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                     aggfns                     
-------------------------------------------------
- {"(0,0,)","(1,1,foo)","(2,2,bar)","(3,3,baz)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,b,c order by a,c using ~<~,b)
   from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
        generate_series(1,2) i;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- test a more complex permutation that has previous caused issues
 select
     string_agg(distinct 'a', ','),
@@ -1702,244 +1064,137 @@
         from (values(1)) b(id)
         where a.id = b.id
 )) from unnest(array[1]) a(id);
- string_agg | sum 
-------------+-----
- a          |   1
-(1 row)
-
+ERROR:  function unnest does not exist
 -- check node I/O via view creation and usage, also deparsing logic
 create view agg_view1 as
   select aggfns(a,b,c)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, b, c) AS aggfns                                                                                  +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(distinct a,b,c)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
          generate_series(1,3) i;
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(DISTINCT v.a, v.b, v.c) AS aggfns                                                                   +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
-     generate_series(1, 3) i(i);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(distinct a,b,c order by b)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
          generate_series(1,3) i;
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.b) AS aggfns                                                      +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
-     generate_series(1, 3) i(i);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(a,b,c order by b+1)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, b, c ORDER BY (b + 1)) AS aggfns                                                                 +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(a,a,c order by b)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                     aggfns                     
-------------------------------------------------
- {"(3,3,baz)","(2,2,bar)","(1,1,foo)","(0,0,)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, a, c ORDER BY b) AS aggfns                                                                       +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(a,b,c order by c using ~<~)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(2,2,bar)","(3,1,baz)","(1,3,foo)","(0,,)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(a, b, c ORDER BY c USING ~<~ NULLS LAST) AS aggfns                                                  +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 create or replace view agg_view1 as
   select aggfns(distinct a,b,c order by a,c using ~<~,b)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
          generate_series(1,2) i;
+ERROR:  only support select and create table statement
 select * from agg_view1;
-                    aggfns                     
------------------------------------------------
- {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  can't find table : public.agg_view1
 select pg_get_viewdef('agg_view1'::regclass);
-                                                   pg_get_viewdef                                                    
----------------------------------------------------------------------------------------------------------------------
-  SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.a, v.c USING ~<~ NULLS LAST, v.b) AS aggfns                       +
-    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
-     generate_series(1, 2) i(i);
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 drop view agg_view1;
+ERROR:  only support select and create table statement
 -- incorrect DISTINCT usage errors
 select aggfns(distinct a,b,c order by i)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,b,c order by i)
-                                              ^
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,b,c order by a,b+1)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,b,c order by a,b+1)
-                                                ^
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,b,c order by a,b,i,c)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,b,c order by a,b,i,c)
-                                                  ^
+ERROR:  function generate_series does not exist
 select aggfns(distinct a,a,c order by a,b)
   from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select aggfns(distinct a,a,c order by a,b)
-                                                ^
+ERROR:  function generate_series does not exist
 -- string_agg tests
 select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
-   string_agg   
-----------------
- aaaa,bbbb,cccc
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
-   string_agg   
-----------------
- aaaa,bbbb,cccc
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
- string_agg 
-------------
- bbbbABcccc
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(a,',') from (values(null),(null)) g(a);
- string_agg 
-------------
- 
-(1 row)
-
+ERROR:  function string_agg does not exist
 -- check some implicit casting cases, as per bug #5564
 select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
- string_agg 
-------------
- a,ab,abcd
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
-                                                          ^
+ERROR:  function string_agg does not exist
 select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
-ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
-LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
-                                                    ^
+ERROR:  function string_agg does not exist
 select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
- string_agg 
-------------
- a,ab,abcd
-(1 row)
-
+ERROR:  function string_agg does not exist
 -- string_agg bytea tests
 create table bytea_test_table(v bytea);
+ERROR:  invalid column type [type_name=bytea]
 select string_agg(v, '') from bytea_test_table;
- string_agg 
-------------
- 
-(1 row)
-
+ERROR:  function string_agg does not exist
 insert into bytea_test_table values(decode('ff','hex'));
+ERROR:  relation "public.bytea_test_table" not exists
 select string_agg(v, '') from bytea_test_table;
- string_agg 
-------------
- \xff
-(1 row)
-
+ERROR:  function string_agg does not exist
 insert into bytea_test_table values(decode('aa','hex'));
+ERROR:  relation "public.bytea_test_table" not exists
 select string_agg(v, '') from bytea_test_table;
- string_agg 
-------------
- \xffaa
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(v, NULL) from bytea_test_table;
- string_agg 
-------------
- \xffaa
-(1 row)
-
+ERROR:  function string_agg does not exist
 select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
- string_agg 
-------------
- \xffeeaa
-(1 row)
-
+ERROR:  function string_agg does not exist
 drop table bytea_test_table;
+ERROR:  only support select and create table statement
 -- Test parallel string_agg and array_agg
 create table pagg_test (x int, y int);
 insert into pagg_test
 select (case x % 4 when 1 then null else x end), x % 10
 from generate_series(1,5000) x;
+ERROR:  INSERT without VALUES
 set parallel_setup_cost TO 0;
+ERROR:  only support select and create table statement
 set parallel_tuple_cost TO 0;
+ERROR:  only support select and create table statement
 set parallel_leader_participation TO 0;
+ERROR:  only support select and create table statement
 set min_parallel_table_scan_size = 0;
+ERROR:  only support select and create table statement
 set bytea_output = 'escape';
+ERROR:  only support select and create table statement
 set max_parallel_workers_per_gather = 2;
+ERROR:  only support select and create table statement
 -- create a view as we otherwise have to repeat this query a few times.
 create view v_pagg_test AS
 select
@@ -1967,424 +1222,223 @@
 	) a1
 ) a2
 group by y;
+ERROR:  only support select and create table statement
 -- Ensure results are correct.
 select * from v_pagg_test order by y;
- y | tmin | tmax | tndistinct | bmin | bmax | bndistinct | amin | amax | andistinct | aamin | aamax | aandistinct 
----+------+------+------------+------+------+------------+------+------+------------+-------+-------+-------------
- 0 |   10 | 5000 |        500 | 10   | 990  |        500 |   10 | 5000 |        500 |    10 |  5000 |         500
- 1 |   11 | 4991 |        250 | 1011 | 991  |        250 |   11 | 4991 |        250 |    11 |  4991 |         250
- 2 |    2 | 4992 |        500 | 1002 | 992  |        500 |    2 | 4992 |        500 |     2 |  4992 |         500
- 3 |    3 | 4983 |        250 | 1003 | 983  |        250 |    3 | 4983 |        250 |     3 |  4983 |         250
- 4 |    4 | 4994 |        500 | 1004 | 994  |        500 |    4 | 4994 |        500 |     4 |  4994 |         500
- 5 |   15 | 4995 |        250 | 1015 | 995  |        250 |   15 | 4995 |        250 |    15 |  4995 |         250
- 6 |    6 | 4996 |        500 | 1006 | 996  |        500 |    6 | 4996 |        500 |     6 |  4996 |         500
- 7 |    7 | 4987 |        250 | 1007 | 987  |        250 |    7 | 4987 |        250 |     7 |  4987 |         250
- 8 |    8 | 4998 |        500 | 1008 | 998  |        500 |    8 | 4998 |        500 |     8 |  4998 |         500
- 9 |   19 | 4999 |        250 | 1019 | 999  |        250 |   19 | 4999 |        250 |    19 |  4999 |         250
-(10 rows)
-
+ERROR:  can't find table : public.v_pagg_test
 -- Ensure parallel aggregation is actually being used.
 explain (costs off) select * from v_pagg_test order by y;
-                                                              QUERY PLAN                                                              
---------------------------------------------------------------------------------------------------------------------------------------
- GroupAggregate
-   Group Key: pagg_test.y
-   ->  Sort
-         Sort Key: pagg_test.y, (((unnest(regexp_split_to_array((string_agg((pagg_test.x)::text, ','::text)), ','::text))))::integer)
-         ->  Result
-               ->  ProjectSet
-                     ->  Finalize HashAggregate
-                           Group Key: pagg_test.y
-                           ->  Gather
-                                 Workers Planned: 2
-                                 ->  Partial HashAggregate
-                                       Group Key: pagg_test.y
-                                       ->  Parallel Seq Scan on pagg_test
-(13 rows)
-
+ERROR:  can't find table : public.v_pagg_test
 set max_parallel_workers_per_gather = 0;
+ERROR:  only support select and create table statement
 -- Ensure results are the same without parallel aggregation.
 select * from v_pagg_test order by y;
- y | tmin | tmax | tndistinct | bmin | bmax | bndistinct | amin | amax | andistinct | aamin | aamax | aandistinct 
----+------+------+------------+------+------+------------+------+------+------------+-------+-------+-------------
- 0 |   10 | 5000 |        500 | 10   | 990  |        500 |   10 | 5000 |        500 |    10 |  5000 |         500
- 1 |   11 | 4991 |        250 | 1011 | 991  |        250 |   11 | 4991 |        250 |    11 |  4991 |         250
- 2 |    2 | 4992 |        500 | 1002 | 992  |        500 |    2 | 4992 |        500 |     2 |  4992 |         500
- 3 |    3 | 4983 |        250 | 1003 | 983  |        250 |    3 | 4983 |        250 |     3 |  4983 |         250
- 4 |    4 | 4994 |        500 | 1004 | 994  |        500 |    4 | 4994 |        500 |     4 |  4994 |         500
- 5 |   15 | 4995 |        250 | 1015 | 995  |        250 |   15 | 4995 |        250 |    15 |  4995 |         250
- 6 |    6 | 4996 |        500 | 1006 | 996  |        500 |    6 | 4996 |        500 |     6 |  4996 |         500
- 7 |    7 | 4987 |        250 | 1007 | 987  |        250 |    7 | 4987 |        250 |     7 |  4987 |         250
- 8 |    8 | 4998 |        500 | 1008 | 998  |        500 |    8 | 4998 |        500 |     8 |  4998 |         500
- 9 |   19 | 4999 |        250 | 1019 | 999  |        250 |   19 | 4999 |        250 |    19 |  4999 |         250
-(10 rows)
-
+ERROR:  can't find table : public.v_pagg_test
 -- Clean up
 reset max_parallel_workers_per_gather;
+ERROR:  only support select and create table statement
 reset bytea_output;
+ERROR:  only support select and create table statement
 reset min_parallel_table_scan_size;
+ERROR:  only support select and create table statement
 reset parallel_leader_participation;
+ERROR:  only support select and create table statement
 reset parallel_tuple_cost;
+ERROR:  only support select and create table statement
 reset parallel_setup_cost;
+ERROR:  only support select and create table statement
 drop view v_pagg_test;
+ERROR:  only support select and create table statement
 drop table pagg_test;
+ERROR:  only support select and create table statement
 -- FILTER tests
 select min(unique1) filter (where unique1 > 100) from tenk1;
  min 
 -----
- 101
+   0
 (1 row)
 
 select sum(1/ten) filter (where ten > 0) from tenk1;
- sum  
-------
- 1000
-(1 row)
-
+ERROR:  div zero [func=func_18094236202898106640]
 select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
 group by ten;
  ten | sum 
 -----+-----
-   0 |    
-   1 |    
-   2 |    
-   3 |    
-   4 |    
-   5 |    
-   6 |    
-   7 |    
-   8 |    
-   9 |    
+   0 |   2
+   1 |   4
+   2 |   2
+   3 |   4
+   4 |   2
+   5 |   4
+   6 |   2
+   7 |   4
+   8 |   2
+   9 |   4
 (10 rows)
 
 select ten, sum(distinct four) filter (where four > 10) from onek a
 group by ten
 having exists (select 1 from onek b where sum(distinct a.four) = b.four);
- ten | sum 
------+-----
-   0 |    
-   2 |    
-   4 |    
-   6 |    
-   8 |    
-(5 rows)
-
+ERROR:  split_condition_by_logical_operator bug! optr: AND
 select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
 from (values ('a', 'b')) AS v(foo,bar);
- max 
------
- a
-(1 row)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=182]
 select any_value(v) filter (where v > 2) from (values (1), (2), (3)) as v (v);
- any_value 
------------
-         3
-(1 row)
-
+ERROR:  function any_value does not exist
 -- outer reference in FILTER (PostgreSQL extension)
 select (select count(*)
         from (values (1)) t0(inner_c))
 from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
- count 
--------
-     1
-     1
-(2 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 select (select count(*) filter (where outer_c <> 0)
         from (values (1)) t0(inner_c))
 from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
- count 
--------
-     2
-(1 row)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 select (select count(inner_c) filter (where outer_c <> 0)
         from (values (1)) t0(inner_c))
 from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
- count 
--------
-     1
-     1
-(2 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 select
   (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
      filter (where o.unique1 < 10))
 from tenk1 o;					-- outer query is aggregation query
- max  
-------
- 9998
-(1 row)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 -- subquery in FILTER clause (PostgreSQL extension)
 select sum(unique1) FILTER (WHERE
   unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
- sum  
-------
- 4950
+   sum    
+----------
+ 49995000
 (1 row)
 
 -- exercise lots of aggregate parts with FILTER
 select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
     from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
     generate_series(1,2) i;
-          aggfns           
----------------------------
- {"(2,2,bar)","(3,1,baz)"}
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- check handling of bare boolean Var in FILTER
 select max(0) filter (where b1) from bool_test;
  max 
 -----
-   0
+    
 (1 row)
 
 select (select max(0) filter (where b1)) from bool_test;
- max 
------
-   0
-(1 row)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 -- check for correct detection of nested-aggregate errors in FILTER
 select max(unique1) filter (where sum(ten) > 0) from tenk1;
-ERROR:  aggregate functions are not allowed in FILTER
-LINE 1: select max(unique1) filter (where sum(ten) > 0) from tenk1;
-                                          ^
+ max  
+------
+ 9999
+(1 row)
+
 select (select max(unique1) filter (where sum(ten) > 0) from int8_tbl) from tenk1;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select (select max(unique1) filter (where sum(ten) > 0) from...
-                                                  ^
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 select max(unique1) filter (where bool_or(ten > 0)) from tenk1;
-ERROR:  aggregate functions are not allowed in FILTER
-LINE 1: select max(unique1) filter (where bool_or(ten > 0)) from ten...
-                                          ^
+ max  
+------
+ 9999
+(1 row)
+
 select (select max(unique1) filter (where bool_or(ten > 0)) from int8_tbl) from tenk1;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select (select max(unique1) filter (where bool_or(ten > 0)) ...
-                                                  ^
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=17]
 -- ordered-set aggregates
 select p, percentile_cont(p) within group (order by x::float8)
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
-  p   | percentile_cont 
-------+-----------------
-    0 |               1
-  0.1 |             1.4
- 0.25 |               2
-  0.4 |             2.6
-  0.5 |               3
-  0.6 |             3.4
- 0.75 |               4
-  0.9 |             4.6
-    1 |               5
-(9 rows)
-
+ERROR:  function generate_series does not exist
 select p, percentile_cont(p order by p) within group (order by x)  -- error
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
 ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
-LINE 1: select p, percentile_cont(p order by p) within group (order ...
-                                                ^
 select p, sum() within group (order by x::float8)  -- error
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
-ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
-LINE 1: select p, sum() within group (order by x::float8)  -- error
-                  ^
+ERROR:  function generate_series does not exist
 select p, percentile_cont(p,p)  -- error
 from generate_series(1,5) x,
      (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
 group by p order by p;
-ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
-LINE 1: select p, percentile_cont(p,p)  -- error
-                  ^
+ERROR:  function generate_series does not exist
 select percentile_cont(0.5) within group (order by b) from aggtest;
- percentile_cont  
-------------------
- 53.4485001564026
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
- percentile_cont  |   sum   
-------------------+---------
- 53.4485001564026 | 431.773
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_cont(0.5) within group (order by thousand) from tenk1;
- percentile_cont 
------------------
-           499.5
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_disc(0.5) within group (order by thousand) from tenk1;
- percentile_disc 
------------------
-             499
-(1 row)
-
+ERROR:  function percentile_disc does not exist
 select rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- rank 
-------
-    5
-(1 row)
-
+ERROR:  function rank does not exist
 select cume_dist(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- cume_dist 
------------
-     0.875
-(1 row)
-
+ERROR:  function cume_dist does not exist
 select percent_rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
- percent_rank 
---------------
-          0.5
-(1 row)
-
+ERROR:  function percent_rank does not exist
 select dense_rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- dense_rank 
-------------
-          3
-(1 row)
-
+ERROR:  function dense_rank does not exist
 select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
 from tenk1;
-      percentile_disc       
-----------------------------
- {0,99,249,499,749,899,999}
-(1 row)
-
+ERROR:  function percentile_disc does not exist
 select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
 from tenk1;
-       percentile_cont       
------------------------------
- {0,249.75,499.5,749.25,999}
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
 from tenk1;
-         percentile_disc         
----------------------------------
- {{NULL,999,499},{749,249,NULL}}
-(1 row)
-
+ERROR:  function percentile_disc does not exist
 select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
 from generate_series(1,6) x;
-             percentile_cont              
-------------------------------------------
- {1,6,2.25,4.75,3.5,6,2.5,2.6,2.75,2.9,3}
-(1 row)
-
+ERROR:  function generate_series does not exist
 select ten, mode() within group (order by string4) from tenk1 group by ten;
- ten |  mode  
------+--------
-   0 | HHHHxx
-   1 | OOOOxx
-   2 | VVVVxx
-   3 | OOOOxx
-   4 | HHHHxx
-   5 | HHHHxx
-   6 | OOOOxx
-   7 | AAAAxx
-   8 | VVVVxx
-   9 | VVVVxx
-(10 rows)
-
+ERROR:  function mode does not exist
 select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
 from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
- percentile_disc 
------------------
- {fred,jill,jim}
-(1 row)
-
+ERROR:  function unnest does not exist
 -- check collation propagates up in suitable cases:
 select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
   from (values ('fred'),('jim')) v(x);
- pg_collation_for 
-------------------
- "POSIX"
-(1 row)
-
+ERROR:  function pg_collation_for does not exist
 -- ordered-set aggs created with CREATE AGGREGATE
 select test_rank(3) within group (order by x)
 from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
- test_rank 
------------
-         5
-(1 row)
-
+ERROR:  function test_rank does not exist
 select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
- test_percentile_disc 
-----------------------
-                  499
-(1 row)
-
+ERROR:  function test_percentile_disc does not exist
 -- ordered-set aggs can't use ungrouped vars in direct args:
 select rank(x) within group (order by x) from generate_series(1,5) x;
-ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
-LINE 1: select rank(x) within group (order by x) from generate_serie...
-                    ^
-DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
+ERROR:  function generate_series does not exist
 -- outer-level agg can't use a grouped arg of a lower level, either:
 select array(select percentile_disc(a) within group (order by x)
                from (values (0.3),(0.7)) v(a) group by a)
   from generate_series(1,5) g(x);
-ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
-LINE 1: select array(select percentile_disc(a) within group (order b...
-                                            ^
+ERROR:  function generate_series does not exist
 -- agg in the direct args is a grouping violation, too:
 select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
-ERROR:  aggregate function calls cannot be nested
-LINE 1: select rank(sum(x)) within group (order by x) from generate_...
-                    ^
+ERROR:  function generate_series does not exist
 -- hypothetical-set type unification and argument-count failures:
 select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
-ERROR:  WITHIN GROUP types text and integer cannot be matched
-LINE 1: select rank(3) within group (order by x) from (values ('fred...
-                    ^
+ERROR:  function rank does not exist
 select rank(3) within group (order by stringu1,stringu2) from tenk1;
-ERROR:  function rank(integer, name, name) does not exist
-LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
-               ^
-HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
+ERROR:  function rank does not exist
 select rank('fred') within group (order by x) from generate_series(1,5) x;
-ERROR:  invalid input syntax for type integer: "fred"
-LINE 1: select rank('fred') within group (order by x) from generate_...
-                    ^
+ERROR:  function generate_series does not exist
 select rank('adam'::text collate "C") within group (order by x collate "POSIX")
   from (values ('fred'),('jim')) v(x);
-ERROR:  collation mismatch between explicit collations "C" and "POSIX"
-LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
-                                                             ^
+ERROR:  function rank does not exist
 -- hypothetical-set type unification successes:
 select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
- rank 
-------
-    1
-(1 row)
-
+ERROR:  function rank does not exist
 select rank('3') within group (order by x) from generate_series(1,5) x;
- rank 
-------
-    3
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- divide by zero check
 select percent_rank(0) within group (order by x) from generate_series(1,0) x;
- percent_rank 
---------------
-            0
-(1 row)
-
+ERROR:  function generate_series does not exist
 -- deparse and multiple features:
 create view aggordview1 as
 select ten,
@@ -2393,74 +1447,31 @@
        rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
   from tenk1
  group by ten order by ten;
+ERROR:  only support select and create table statement
 select pg_get_viewdef('aggordview1');
-                                                  pg_get_viewdef                                                   
--------------------------------------------------------------------------------------------------------------------
-  SELECT ten,                                                                                                     +
-     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY thousand) AS p50,                            +
-     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY thousand) FILTER (WHERE (hundred = 1)) AS px,+
-     rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY hundred, string4 DESC, hundred) AS rank                    +
-    FROM tenk1                                                                                                    +
-   GROUP BY ten                                                                                                   +
-   ORDER BY ten;
-(1 row)
-
+ERROR:  function pg_get_viewdef does not exist
 select * from aggordview1 order by ten;
- ten | p50 | px  | rank 
------+-----+-----+------
-   0 | 490 |     |  101
-   1 | 491 | 401 |  101
-   2 | 492 |     |  101
-   3 | 493 |     |  101
-   4 | 494 |     |  101
-   5 | 495 |     |   67
-   6 | 496 |     |    1
-   7 | 497 |     |    1
-   8 | 498 |     |    1
-   9 | 499 |     |    1
-(10 rows)
-
+ERROR:  can't find table : public.aggordview1
 drop view aggordview1;
+ERROR:  only support select and create table statement
 -- variadic aggregates
 select least_agg(q1,q2) from int8_tbl;
-     least_agg     
--------------------
- -4567890123456789
-(1 row)
-
+ERROR:  function least_agg does not exist
 select least_agg(variadic array[q1,q2]) from int8_tbl;
-     least_agg     
--------------------
- -4567890123456789
-(1 row)
-
+ERROR:  function least_agg does not exist
 select cleast_agg(q1,q2) from int8_tbl;
-    cleast_agg     
--------------------
- -4567890123456789
-(1 row)
-
+ERROR:  function cleast_agg does not exist
 select cleast_agg(4.5,f1) from int4_tbl;
- cleast_agg  
--------------
- -2147483647
-(1 row)
-
+ERROR:  function cleast_agg does not exist
 select cleast_agg(variadic array[4.5,f1]) from int4_tbl;
- cleast_agg  
--------------
- -2147483647
-(1 row)
-
+ERROR:  function cleast_agg does not exist
 select pg_typeof(cleast_agg(variadic array[4.5,f1])) from int4_tbl;
- pg_typeof 
------------
- numeric
-(1 row)
-
+ERROR:  function pg_typeof does not exist
 -- test aggregates with common transition functions share the same states
 begin work;
+ERROR:  only support select and create table statement
 create type avg_state as (total bigint, count bigint);
+ERROR:  only support select and create table statement
 create or replace function avg_transfn(state avg_state, n int) returns avg_state as
 $$
 declare new_state avg_state;
@@ -2482,6 +1493,7 @@
 	return null;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create function avg_finalfn(state avg_state) returns int4 as
 $$
 begin
@@ -2492,6 +1504,7 @@
 	end if;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create function sum_finalfn(state avg_state) returns int4 as
 $$
 begin
@@ -2502,106 +1515,56 @@
 	end if;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create aggregate my_avg(int4)
 (
    stype = avg_state,
    sfunc = avg_transfn,
    finalfunc = avg_finalfn
 );
+ERROR:  only support select and create table statement
 create aggregate my_sum(int4)
 (
    stype = avg_state,
    sfunc = avg_transfn,
    finalfunc = sum_finalfn
 );
+ERROR:  only support select and create table statement
 -- aggregate state should be shared as aggs are the same.
 select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_avg | my_avg 
---------+--------
-      2 |      2
-(1 row)
-
+ERROR:  function my_avg does not exist
 -- aggregate state should be shared as transfn is the same for both aggs.
 select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      2 |      4
-(1 row)
-
+ERROR:  function my_avg does not exist
 -- same as previous one, but with DISTINCT, which requires sorting the input.
 select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      2 |      4
-(1 row)
-
+ERROR:  function my_avg does not exist
 -- shouldn't share states due to the distinctness not matching.
 select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      2 |      4
-(1 row)
-
+ERROR:  function my_avg does not exist
 -- shouldn't share states due to the filter clause not matching.
 select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 3
- my_avg | my_sum 
---------+--------
-      3 |      4
-(1 row)
-
+ERROR:  function my_avg does not exist
 -- this should not share the state due to different input columns.
 select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 2
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 4
- my_avg | my_sum 
---------+--------
-      2 |      6
-(1 row)
-
+ERROR:  function my_avg does not exist
 -- exercise cases where OSAs share state
 select
   percentile_cont(0.5) within group (order by a),
   percentile_disc(0.5) within group (order by a)
 from (values(1::float8),(3),(5),(7)) t(a);
- percentile_cont | percentile_disc 
------------------+-----------------
-               4 |               3
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 select
   percentile_cont(0.25) within group (order by a),
   percentile_disc(0.5) within group (order by a)
 from (values(1::float8),(3),(5),(7)) t(a);
- percentile_cont | percentile_disc 
------------------+-----------------
-             2.5 |               3
-(1 row)
-
+ERROR:  function percentile_cont does not exist
 -- these can't share state currently
 select
   rank(4) within group (order by a),
   dense_rank(4) within group (order by a)
 from (values(1),(3),(5),(7)) t(a);
- rank | dense_rank 
-------+------------
-    3 |          3
-(1 row)
-
+ERROR:  function rank does not exist
 -- test that aggs with the same sfunc and initcond share the same agg state
 create aggregate my_sum_init(int4)
 (
@@ -2610,6 +1573,7 @@
    finalfunc = sum_finalfn,
    initcond = '(10,0)'
 );
+ERROR:  only support select and create table statement
 create aggregate my_avg_init(int4)
 (
    stype = avg_state,
@@ -2617,6 +1581,7 @@
    finalfunc = avg_finalfn,
    initcond = '(10,0)'
 );
+ERROR:  only support select and create table statement
 create aggregate my_avg_init2(int4)
 (
    stype = avg_state,
@@ -2624,30 +1589,19 @@
    finalfunc = avg_finalfn,
    initcond = '(4,0)'
 );
+ERROR:  only support select and create table statement
 -- state should be shared if INITCONDs are matching
 select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
- my_sum_init | my_avg_init 
--------------+-------------
-          14 |           7
-(1 row)
-
+ERROR:  function my_sum_init does not exist
 -- Varying INITCONDs should cause the states not to be shared.
 select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 1
-NOTICE:  avg_transfn called with 3
-NOTICE:  avg_transfn called with 3
- my_sum_init | my_avg_init2 
--------------+--------------
-          14 |            4
-(1 row)
-
+ERROR:  function my_sum_init does not exist
 rollback;
+ERROR:  only support select and create table statement
 -- test aggregate state sharing to ensure it works if one aggregate has a
 -- finalfn and the other one has none.
 begin work;
+ERROR:  only support select and create table statement
 create or replace function sum_transfn(state int4, n int4) returns int4 as
 $$
 declare new_state int4;
@@ -2667,6 +1621,7 @@
 	return null;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create function halfsum_finalfn(state int4) returns int4 as
 $$
 begin
@@ -2677,33 +1632,30 @@
 	end if;
 end
 $$ language plpgsql;
+ERROR:  only support select and create table statement
 create aggregate my_sum(int4)
 (
    stype = int4,
    sfunc = sum_transfn
 );
+ERROR:  only support select and create table statement
 create aggregate my_half_sum(int4)
 (
    stype = int4,
    sfunc = sum_transfn,
    finalfunc = halfsum_finalfn
 );
+ERROR:  only support select and create table statement
 -- Agg state should be shared even though my_sum has no finalfn
 select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
-NOTICE:  sum_transfn called with 1
-NOTICE:  sum_transfn called with 2
-NOTICE:  sum_transfn called with 3
-NOTICE:  sum_transfn called with 4
- my_sum | my_half_sum 
---------+-------------
-     10 |           5
-(1 row)
-
+ERROR:  function my_sum does not exist
 rollback;
+ERROR:  only support select and create table statement
 -- test that the aggregate transition logic correctly handles
 -- transition / combine functions returning NULL
 -- First test the case of a normal transition function returning NULL
 BEGIN;
+ERROR:  only support select and create table statement
 CREATE FUNCTION balkifnull(int8, int4)
 RETURNS int8
 STRICT
@@ -2714,6 +1666,7 @@
     END IF;
     RETURN NULL;
 END$$;
+ERROR:  only support select and create table statement
 CREATE AGGREGATE balk(int4)
 (
     SFUNC = balkifnull(int8, int4),
@@ -2721,13 +1674,11 @@
     PARALLEL = SAFE,
     INITCOND = '0'
 );
+ERROR:  only support select and create table statement
 SELECT balk(hundred) FROM tenk1;
- balk 
-------
-     
-(1 row)
-
+ERROR:  function balk does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- GROUP BY optimization by reordering GROUP BY clauses
 CREATE TABLE btg AS SELECT
   i % 10 AS x,
@@ -2735,116 +1686,58 @@
   'abc' || i % 10 AS z,
   i AS w
 FROM generate_series(1, 100) AS i;
+ERROR:  only support select and create table statement
 CREATE INDEX btg_x_y_idx ON btg(x, y);
+ERROR:  only support select and create table statement
 ANALYZE btg;
+ERROR:  only support select and create table statement
 SET enable_hashagg = off;
+ERROR:  only support select and create table statement
 SET enable_seqscan = off;
+ERROR:  only support select and create table statement
 -- Utilize the ordering of index scan to avoid a Sort operation
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY y, x;
-                   QUERY PLAN                   
-------------------------------------------------
- GroupAggregate
-   Group Key: x, y
-   ->  Index Only Scan using btg_x_y_idx on btg
-(3 rows)
-
+ERROR:  can't find table : public.btg
 -- Engage incremental sort
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY z, y, w, x;
-                   QUERY PLAN                    
--------------------------------------------------
- GroupAggregate
-   Group Key: x, y, z, w
-   ->  Incremental Sort
-         Sort Key: x, y, z, w
-         Presorted Key: x, y
-         ->  Index Scan using btg_x_y_idx on btg
-(6 rows)
-
+ERROR:  can't find table : public.btg
 -- Utilize the ordering of subquery scan to avoid a Sort operation
 EXPLAIN (COSTS OFF) SELECT count(*)
 FROM (SELECT * FROM btg ORDER BY x, y, w, z) AS q1
 GROUP BY w, x, z, y;
-                   QUERY PLAN                    
--------------------------------------------------
- GroupAggregate
-   Group Key: btg.x, btg.y, btg.w, btg.z
-   ->  Incremental Sort
-         Sort Key: btg.x, btg.y, btg.w, btg.z
-         Presorted Key: btg.x, btg.y
-         ->  Index Scan using btg_x_y_idx on btg
-(6 rows)
-
+ERROR:  can't find table : public.btg
 -- Utilize the ordering of merge join to avoid a full Sort operation
 SET enable_hashjoin = off;
+ERROR:  only support select and create table statement
 SET enable_nestloop = off;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT count(*)
   FROM btg t1 JOIN btg t2 ON t1.z = t2.z AND t1.w = t2.w AND t1.x = t2.x
   GROUP BY t1.x, t1.y, t1.z, t1.w;
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
- GroupAggregate
-   Group Key: t1.z, t1.w, t1.x, t1.y
-   ->  Incremental Sort
-         Sort Key: t1.z, t1.w, t1.x, t1.y
-         Presorted Key: t1.z, t1.w, t1.x
-         ->  Merge Join
-               Merge Cond: ((t1.z = t2.z) AND (t1.w = t2.w) AND (t1.x = t2.x))
-               ->  Sort
-                     Sort Key: t1.z, t1.w, t1.x
-                     ->  Index Scan using btg_x_y_idx on btg t1
-               ->  Sort
-                     Sort Key: t2.z, t2.w, t2.x
-                     ->  Index Scan using btg_x_y_idx on btg t2
-(13 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 RESET enable_nestloop;
+ERROR:  only support select and create table statement
 RESET enable_hashjoin;
+ERROR:  only support select and create table statement
 -- Should work with and without GROUP-BY optimization
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY w, x, z, y ORDER BY y, x, z, w;
-                   QUERY PLAN                    
--------------------------------------------------
- GroupAggregate
-   Group Key: y, x, z, w
-   ->  Sort
-         Sort Key: y, x, z, w
-         ->  Index Scan using btg_x_y_idx on btg
-(5 rows)
-
+ERROR:  can't find table : public.btg
 -- Utilize incremental sort to make the ORDER BY rule a bit cheaper
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM btg GROUP BY w, x, y, z ORDER BY x*x, z;
-                      QUERY PLAN                       
--------------------------------------------------------
- Sort
-   Sort Key: ((x * x)), z
-   ->  GroupAggregate
-         Group Key: x, y, w, z
-         ->  Incremental Sort
-               Sort Key: x, y, w, z
-               Presorted Key: x, y
-               ->  Index Scan using btg_x_y_idx on btg
-(8 rows)
-
+ERROR:  can't find table : public.btg
 -- Test the case where the number of incoming subtree path keys is more than
 -- the number of grouping keys.
 CREATE INDEX btg_y_x_w_idx ON btg(y, x, w);
+ERROR:  only support select and create table statement
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT y, x, array_agg(distinct w)
   FROM btg WHERE y < 0 GROUP BY x, y;
-                       QUERY PLAN                        
----------------------------------------------------------
- GroupAggregate
-   Output: y, x, array_agg(DISTINCT w)
-   Group Key: btg.y, btg.x
-   ->  Index Only Scan using btg_y_x_w_idx on public.btg
-         Output: y, x, w
-         Index Cond: (btg.y < 0)
-(6 rows)
-
+ERROR:  function array_agg does not exist
 -- Ensure that we do not select the aggregate pathkeys instead of the grouping
 -- pathkeys
 CREATE TABLE group_agg_pk AS SELECT
@@ -2854,70 +1747,54 @@
   2 AS w,
   i % 10 AS f
 FROM generate_series(1,100) AS i;
+ERROR:  only support select and create table statement
 ANALYZE group_agg_pk;
+ERROR:  only support select and create table statement
 SET enable_nestloop = off;
+ERROR:  only support select and create table statement
 SET enable_hashjoin = off;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT avg(c1.f ORDER BY c1.x, c1.y)
 FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x
 GROUP BY c1.w, c1.z;
-                     QUERY PLAN                      
------------------------------------------------------
- GroupAggregate
-   Group Key: c1.w, c1.z
-   ->  Sort
-         Sort Key: c1.w, c1.z, c1.x, c1.y
-         ->  Merge Join
-               Merge Cond: (c1.x = c2.x)
-               ->  Sort
-                     Sort Key: c1.x
-                     ->  Seq Scan on group_agg_pk c1
-               ->  Sort
-                     Sort Key: c2.x
-                     ->  Seq Scan on group_agg_pk c2
-(12 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 SELECT avg(c1.f ORDER BY c1.x, c1.y)
 FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x
 GROUP BY c1.w, c1.z;
-        avg         
---------------------
- 4.0000000000000000
- 5.0000000000000000
-(2 rows)
-
+ERROR:  from_clause[i].node_case is not range_var or RangeSubselect [node_case=47] [index=0]
 RESET enable_nestloop;
+ERROR:  only support select and create table statement
 RESET enable_hashjoin;
+ERROR:  only support select and create table statement
 DROP TABLE group_agg_pk;
+ERROR:  only support select and create table statement
 -- Test the case where the the ordering of scan matches the ordering within the
 -- aggregate but cannot be found in the group-by list
 CREATE TABLE agg_sort_order (c1 int PRIMARY KEY, c2 int);
 CREATE UNIQUE INDEX agg_sort_order_c2_idx ON agg_sort_order(c2);
+ERROR:  only support select and create table statement
 INSERT INTO agg_sort_order SELECT i, i FROM generate_series(1,100)i;
+ERROR:  INSERT without VALUES
 ANALYZE agg_sort_order;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF)
 SELECT array_agg(c1 ORDER BY c2),c2
 FROM agg_sort_order WHERE c2 < 100 GROUP BY c1 ORDER BY 2;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
- Sort
-   Sort Key: c2
-   ->  GroupAggregate
-         Group Key: c1
-         ->  Sort
-               Sort Key: c1, c2
-               ->  Index Scan using agg_sort_order_c2_idx on agg_sort_order
-                     Index Cond: (c2 < 100)
-(8 rows)
-
+ERROR:  function array_agg does not exist
 DROP TABLE agg_sort_order CASCADE;
+ERROR:  only support select and create table statement
 DROP TABLE btg;
+ERROR:  only support select and create table statement
 RESET enable_hashagg;
+ERROR:  only support select and create table statement
 RESET enable_seqscan;
+ERROR:  only support select and create table statement
 -- Secondly test the case of a parallel aggregate combiner function
 -- returning NULL. For that use normal transition function, but a
 -- combiner function returning NULL.
 BEGIN;
+ERROR:  only support select and create table statement
 CREATE FUNCTION balkifnull(int8, int8)
 RETURNS int8
 PARALLEL SAFE
@@ -2929,6 +1806,7 @@
     END IF;
     RETURN NULL;
 END$$;
+ERROR:  only support select and create table statement
 CREATE AGGREGATE balk(int4)
 (
     SFUNC = int4_sum(int8, int4),
@@ -2937,35 +1815,30 @@
     PARALLEL = SAFE,
     INITCOND = '0'
 );
+ERROR:  only support select and create table statement
 -- force use of parallelism
 ALTER TABLE tenk1 set (parallel_workers = 4);
+ERROR:  only support select and create table statement
 SET LOCAL parallel_setup_cost=0;
+ERROR:  only support select and create table statement
 SET LOCAL max_parallel_workers_per_gather=4;
+ERROR:  only support select and create table statement
 EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
- Finalize Aggregate
-   ->  Gather
-         Workers Planned: 4
-         ->  Partial Aggregate
-               ->  Parallel Index Only Scan using tenk1_hundred on tenk1
-(5 rows)
-
+ERROR:  function balk does not exist
 SELECT balk(hundred) FROM tenk1;
- balk 
-------
-     
-(1 row)
-
+ERROR:  function balk does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- test multiple usage of an aggregate whose finalfn returns a R/W datum
 BEGIN;
+ERROR:  only support select and create table statement
 CREATE FUNCTION rwagg_sfunc(x anyarray, y anyarray) RETURNS anyarray
 LANGUAGE plpgsql IMMUTABLE AS $$
 BEGIN
     RETURN array_fill(y[1], ARRAY[4]);
 END;
 $$;
+ERROR:  only support select and create table statement
 CREATE FUNCTION rwagg_finalfunc(x anyarray) RETURNS anyarray
 LANGUAGE plpgsql STRICT IMMUTABLE AS $$
 DECLARE
@@ -2976,11 +1849,13 @@
     RETURN res;
 END;
 $$;
+ERROR:  only support select and create table statement
 CREATE AGGREGATE rwagg(anyarray) (
     STYPE = anyarray,
     SFUNC = rwagg_sfunc,
     FINALFUNC = rwagg_finalfunc
 );
+ERROR:  only support select and create table statement
 CREATE FUNCTION eatarray(x real[]) RETURNS real[]
 LANGUAGE plpgsql STRICT IMMUTABLE AS $$
 BEGIN
@@ -2988,21 +1863,26 @@
     RETURN x;
 END;
 $$;
+ERROR:  only support select and create table statement
 SELECT eatarray(rwagg(ARRAY[1.0::real])), eatarray(rwagg(ARRAY[1.0::real]));
- eatarray  | eatarray  
------------+-----------
- {2,1,1,1} | {2,1,1,1}
-(1 row)
-
+ERROR:  function eatarray does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- test coverage for aggregate combine/serial/deserial functions
 BEGIN;
+ERROR:  only support select and create table statement
 SET parallel_setup_cost = 0;
+ERROR:  only support select and create table statement
 SET parallel_tuple_cost = 0;
+ERROR:  only support select and create table statement
 SET min_parallel_table_scan_size = 0;
+ERROR:  only support select and create table statement
 SET max_parallel_workers_per_gather = 4;
+ERROR:  only support select and create table statement
 SET parallel_leader_participation = off;
+ERROR:  only support select and create table statement
 SET enable_indexonlyscan = off;
+ERROR:  only support select and create table statement
 -- variance(int4) covers numeric_poly_combine
 -- sum(int8) covers int8_avg_combine
 -- regr_count(float8, float8) covers int8inc_float8_float8 and aggregates with > 1 arg
@@ -3012,36 +1892,13 @@
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-                                                                                      QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Finalize Aggregate
-   Output: variance(tenk1.unique1), sum((tenk1.unique1)::bigint), regr_count((tenk1.unique1)::double precision, (tenk1.unique1)::double precision)
-   ->  Gather
-         Output: (PARTIAL variance(tenk1.unique1)), (PARTIAL sum((tenk1.unique1)::bigint)), (PARTIAL regr_count((tenk1.unique1)::double precision, (tenk1.unique1)::double precision))
-         Workers Planned: 4
-         ->  Partial Aggregate
-               Output: PARTIAL variance(tenk1.unique1), PARTIAL sum((tenk1.unique1)::bigint), PARTIAL regr_count((tenk1.unique1)::double precision, (tenk1.unique1)::double precision)
-               ->  Parallel Append
-                     ->  Parallel Seq Scan on public.tenk1
-                           Output: tenk1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_1
-                           Output: tenk1_1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_2
-                           Output: tenk1_2.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_3
-                           Output: tenk1_3.unique1
-(16 rows)
-
+ERROR:  function variance does not exist
 SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8)
 FROM (SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-       variance       |    sum    | regr_count 
-----------------------+-----------+------------
- 8333541.588539713493 | 199980000 |      40000
-(1 row)
-
+ERROR:  function variance does not exist
 -- variance(int8) covers numeric_combine
 -- avg(numeric) covers numeric_avg_combine
 EXPLAIN (COSTS OFF, VERBOSE)
@@ -3050,192 +1907,117 @@
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-                                               QUERY PLAN                                               
---------------------------------------------------------------------------------------------------------
- Finalize Aggregate
-   Output: variance((tenk1.unique1)::bigint), avg((tenk1.unique1)::numeric)
-   ->  Gather
-         Output: (PARTIAL variance((tenk1.unique1)::bigint)), (PARTIAL avg((tenk1.unique1)::numeric))
-         Workers Planned: 4
-         ->  Partial Aggregate
-               Output: PARTIAL variance((tenk1.unique1)::bigint), PARTIAL avg((tenk1.unique1)::numeric)
-               ->  Parallel Append
-                     ->  Parallel Seq Scan on public.tenk1
-                           Output: tenk1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_1
-                           Output: tenk1_1.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_2
-                           Output: tenk1_2.unique1
-                     ->  Parallel Seq Scan on public.tenk1 tenk1_3
-                           Output: tenk1_3.unique1
-(16 rows)
-
+ERROR:  function variance does not exist
 SELECT variance(unique1::int8), avg(unique1::numeric)
 FROM (SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1
       UNION ALL SELECT * FROM tenk1) u;
-       variance       |          avg          
-----------------------+-----------------------
- 8333541.588539713493 | 4999.5000000000000000
-(1 row)
-
+ERROR:  function variance does not exist
 ROLLBACK;
+ERROR:  only support select and create table statement
 -- test coverage for dense_rank
 SELECT dense_rank(x) WITHIN GROUP (ORDER BY x) FROM (VALUES (1),(1),(2),(2),(3),(3)) v(x) GROUP BY (x) ORDER BY 1;
- dense_rank 
-------------
-          1
-          1
-          1
-(3 rows)
-
+ERROR:  function dense_rank does not exist
 -- Ensure that the STRICT checks for aggregates does not take NULLness
 -- of ORDER BY columns into account. See bug report around
 -- 2a505161-2727-2473-7c46-591ed108ac52@email.cz
 SELECT min(x ORDER BY y) FROM (VALUES(1, NULL)) AS d(x,y);
- min 
------
-   1
-(1 row)
-
+ERROR:  column "x" not exist
 SELECT min(x ORDER BY y) FROM (VALUES(1, 2)) AS d(x,y);
- min 
------
-   1
-(1 row)
-
+ERROR:  column "x" not exist
 -- check collation-sensitive matching between grouping expressions
 select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)
   from unnest(array['a','b']) u(v)
  group by v||'a' order by 1;
- ?column? | case | count 
-----------+------+-------
- aa       |    1 |     1
- ba       |    0 |     1
-(2 rows)
-
+ERROR:  function unnest does not exist
 select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)
   from unnest(array['a','b']) u(v)
  group by v||'a' order by 1;
- ?column? | case | count 
-----------+------+-------
- aa       |    1 |     1
- ba       |    0 |     1
-(2 rows)
-
+ERROR:  function unnest does not exist
 -- Make sure that generation of HashAggregate for uniqification purposes
 -- does not lead to array overflow due to unexpected duplicate hash keys
 -- see CAFeeJoKKu0u+A_A9R9316djW-YW3-+Gtgvy3ju655qRHR3jtdA@mail.gmail.com
 set enable_memoize to off;
+ERROR:  only support select and create table statement
 explain (costs off)
   select 1 from tenk1
    where (hundred, thousand) in (select twothousand, twothousand from onek);
-                         QUERY PLAN                          
--------------------------------------------------------------
- Hash Join
-   Hash Cond: (tenk1.hundred = onek.twothousand)
-   ->  Seq Scan on tenk1
-         Filter: (hundred = thousand)
-   ->  Hash
-         ->  HashAggregate
-               Group Key: onek.twothousand, onek.twothousand
-               ->  Seq Scan on onek
-(8 rows)
-
+ERROR:  expr only support column_ref / a_const / func_call / type_cast [node_case=31]
 reset enable_memoize;
+ERROR:  only support select and create table statement
 --
 -- Hash Aggregation Spill tests
 --
 set enable_sort=false;
+ERROR:  only support select and create table statement
 set work_mem='64kB';
+ERROR:  only support select and create table statement
 select unique1, count(*), sum(twothousand) from tenk1
 group by unique1
 having sum(fivethous) > 4975
 order by sum(twothousand);
  unique1 | count | sum  
 ---------+-------+------
-    4976 |     1 |  976
-    4977 |     1 |  977
-    4978 |     1 |  978
-    4979 |     1 |  979
-    4980 |     1 |  980
-    4981 |     1 |  981
-    4982 |     1 |  982
-    4983 |     1 |  983
-    4984 |     1 |  984
-    4985 |     1 |  985
-    4986 |     1 |  986
-    4987 |     1 |  987
-    4988 |     1 |  988
-    4989 |     1 |  989
-    4990 |     1 |  990
-    4991 |     1 |  991
-    4992 |     1 |  992
-    4993 |     1 |  993
-    4994 |     1 |  994
-    4995 |     1 |  995
-    4996 |     1 |  996
-    4997 |     1 |  997
-    4998 |     1 |  998
-    4999 |     1 |  999
-    9976 |     1 | 1976
-    9977 |     1 | 1977
-    9978 |     1 | 1978
-    9979 |     1 | 1979
-    9980 |     1 | 1980
-    9981 |     1 | 1981
-    9982 |     1 | 1982
-    9983 |     1 | 1983
-    9984 |     1 | 1984
-    9985 |     1 | 1985
-    9986 |     1 | 1986
-    9987 |     1 | 1987
-    9988 |     1 | 1988
-    9989 |     1 | 1989
-    9990 |     1 | 1990
-    9991 |     1 | 1991
-    9992 |     1 | 1992
-    9993 |     1 | 1993
-    9994 |     1 | 1994
-    9995 |     1 | 1995
-    9996 |     1 | 1996
-    9997 |     1 | 1997
-    9998 |     1 | 1998
-    9999 |     1 | 1999
-(48 rows)
+    7133 |     1 | 1133
+    7135 |     1 | 1135
+    7137 |     1 | 1137
+    7139 |     1 | 1139
+    7141 |     1 | 1141
+    7143 |     1 | 1143
+    7145 |     1 | 1145
+    7147 |     1 | 1147
+    7149 |     1 | 1149
+    7151 |     1 | 1151
+    7153 |     1 | 1153
+    7155 |     1 | 1155
+    7157 |     1 | 1157
+    7159 |     1 | 1159
+    7161 |     1 | 1161
+    7163 |     1 | 1163
+    7165 |     1 | 1165
+    7167 |     1 | 1167
+    7169 |     1 | 1169
+    7171 |     1 | 1171
+    7173 |     1 | 1173
+    7175 |     1 | 1175
+    7177 |     1 | 1177
+    7179 |     1 | 1179
+(24 rows)
 
 set work_mem to default;
+ERROR:  only support select and create table statement
 set enable_sort to default;
+ERROR:  only support select and create table statement
 --
 -- Compare results between plans using sorting and plans using hash
 -- aggregation. Force spilling in both cases by setting work_mem low.
 --
 set work_mem='64kB';
+ERROR:  only support select and create table statement
 create table agg_data_2k as
 select g from generate_series(0, 1999) g;
+ERROR:  only support select and create table statement
 analyze agg_data_2k;
+ERROR:  only support select and create table statement
 create table agg_data_20k as
 select g from generate_series(0, 19999) g;
+ERROR:  only support select and create table statement
 analyze agg_data_20k;
+ERROR:  only support select and create table statement
 -- Produce results with sorting.
 set enable_hashagg = false;
+ERROR:  only support select and create table statement
 set jit_above_cost = 0;
+ERROR:  only support select and create table statement
 explain (costs off)
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
-              QUERY PLAN              
---------------------------------------
- GroupAggregate
-   Group Key: ((g % 10000))
-   ->  Sort
-         Sort Key: ((g % 10000))
-         ->  Seq Scan on agg_data_20k
-(5 rows)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 create table agg_group_1 as
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
+ERROR:  only support select and create table statement
 create table agg_group_2 as
 select * from
   (values (100), (300), (500)) as r(a),
@@ -3246,30 +2028,32 @@
     from agg_data_2k
     where g < r.a
     group by g/2) as s;
+ERROR:  only support select and create table statement
 set jit_above_cost to default;
+ERROR:  only support select and create table statement
 create table agg_group_3 as
 select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 create table agg_group_4 as
 select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 -- Produce results with hash aggregation
 set enable_hashagg = true;
+ERROR:  only support select and create table statement
 set enable_sort = false;
+ERROR:  only support select and create table statement
 set jit_above_cost = 0;
+ERROR:  only support select and create table statement
 explain (costs off)
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
-           QUERY PLAN           
---------------------------------
- HashAggregate
-   Group Key: (g % 10000)
-   ->  Seq Scan on agg_data_20k
-(3 rows)
-
+ERROR:  not processed pg_catalog type [pg_catalog_type=numeric]
 create table agg_hash_1 as
 select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
   from agg_data_20k group by g%10000;
+ERROR:  only support select and create table statement
 create table agg_hash_2 as
 select * from
   (values (100), (300), (500)) as r(a),
@@ -3280,49 +2064,51 @@
     from agg_data_2k
     where g < r.a
     group by g/2) as s;
+ERROR:  only support select and create table statement
 set jit_above_cost to default;
+ERROR:  only support select and create table statement
 create table agg_hash_3 as
 select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 create table agg_hash_4 as
 select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
   from agg_data_2k group by g/2;
+ERROR:  only support select and create table statement
 set enable_sort = true;
+ERROR:  only support select and create table statement
 set work_mem to default;
+ERROR:  only support select and create table statement
 -- Compare group aggregation results to hash aggregation results
 (select * from agg_hash_1 except select * from agg_group_1)
   union all
 (select * from agg_group_1 except select * from agg_hash_1);
- c1 | c2 | c3 
-----+----+----
-(0 rows)
-
+ERROR:  select list can't be empty currently
 (select * from agg_hash_2 except select * from agg_group_2)
   union all
 (select * from agg_group_2 except select * from agg_hash_2);
- a | c1 | c2 | c3 
----+----+----+----
-(0 rows)
-
+ERROR:  select list can't be empty currently
 (select * from agg_hash_3 except select * from agg_group_3)
   union all
 (select * from agg_group_3 except select * from agg_hash_3);
- c1 | c2 | c3 
-----+----+----
-(0 rows)
-
+ERROR:  select list can't be empty currently
 (select * from agg_hash_4 except select * from agg_group_4)
   union all
 (select * from agg_group_4 except select * from agg_hash_4);
- c1 | c2 | c3 
-----+----+----
-(0 rows)
-
+ERROR:  select list can't be empty currently
 drop table agg_group_1;
+ERROR:  only support select and create table statement
 drop table agg_group_2;
+ERROR:  only support select and create table statement
 drop table agg_group_3;
+ERROR:  only support select and create table statement
 drop table agg_group_4;
+ERROR:  only support select and create table statement
 drop table agg_hash_1;
+ERROR:  only support select and create table statement
 drop table agg_hash_2;
+ERROR:  only support select and create table statement
 drop table agg_hash_3;
+ERROR:  only support select and create table statement
 drop table agg_hash_4;
+ERROR:  only support select and create table statement
